!
function (window, undefined) {
    function isArraylike(obj) {
        var length = obj.length,
            type = jQuery.type(obj);
        return jQuery.isWindow(obj) ? !1 : 1 === obj.nodeType && length ? !0 : "array" === type || "function" !== type && (0 === length || "number" == typeof length && length > 0 && length - 1 in obj)
    }

    function createOptions(options) {
        var object = optionsCache[options] = {};
        return jQuery.each(options.match(core_rnotwhite) || [],
                function (_, flag) {
                    object[flag] = !0
                }),
            object
    }

    function Data() {
        Object.defineProperty(this.cache = {},
                0, {
                    get: function () {
                        return {}
                    }
                }),
            this.expando = jQuery.expando + Math.random()
    }

    function dataAttr(elem, key, data) {
        var name;
        if (data === undefined && 1 === elem.nodeType)
            if (name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase(), data = elem.getAttribute(name), "string" == typeof data) {
                try {
                    data = "true" === data ? !0 : "false" === data ? !1 : "null" === data ? null : +data + "" === data ? +data : rbrace.test(data) ? JSON.parse(data) : data
                } catch (e) {}
                data_user.set(elem, key, data)
            } else data = undefined;
        return data
    }

    function returnTrue() {
        return !0
    }

    function returnFalse() {
        return !1
    }

    function safeActiveElement() {
        try {
            return document.activeElement
        } catch (err) {}
    }

    function sibling(cur, dir) {
        for (;
            (cur = cur[dir]) && 1 !== cur.nodeType;);
        return cur
    }

    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) return jQuery.grep(elements,
            function (elem, i) {
                return !!qualifier.call(elem, i, elem) !== not
            });
        if (qualifier.nodeType) return jQuery.grep(elements,
            function (elem) {
                return elem === qualifier !== not
            });
        if ("string" == typeof qualifier) {
            if (isSimple.test(qualifier)) return jQuery.filter(qualifier, elements, not);
            qualifier = jQuery.filter(qualifier, elements)
        }
        return jQuery.grep(elements,
            function (elem) {
                return core_indexOf.call(qualifier, elem) >= 0 !== not
            })
    }

    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") && jQuery.nodeName(1 === content.nodeType ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem
    }

    function disableScript(elem) {
        return elem.type = (null !== elem.getAttribute("type")) + "/" + elem.type,
            elem
    }

    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        return match ? elem.type = match[1] : elem.removeAttribute("type"),
            elem
    }

    function setGlobalEval(elems, refElements) {
        for (var l = elems.length,
                i = 0; l > i; i++) data_priv.set(elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"))
    }

    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (1 === dest.nodeType) {
            if (data_priv.hasData(src) && (pdataOld = data_priv.access(src), pdataCur = data_priv.set(dest, pdataOld), events = pdataOld.events)) {
                delete pdataCur.handle,
                    pdataCur.events = {};
                for (type in events)
                    for (i = 0, l = events[type].length; l > i; i++) jQuery.event.add(dest, type, events[type][i])
            }
            data_user.hasData(src) && (udataOld = data_user.access(src), udataCur = jQuery.extend({},
                udataOld), data_user.set(dest, udataCur))
        }
    }

    function getAll(context, tag) {
        var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];
        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret
    }

    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        "input" === nodeName && manipulation_rcheckableType.test(src.type) ? dest.checked = src.checked : ("input" === nodeName || "textarea" === nodeName) && (dest.defaultValue = src.defaultValue)
    }

    function vendorPropName(style, name) {
        if (name in style) return name;
        for (var capName = name.charAt(0).toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length; i--;)
            if (name = cssPrefixes[i] + capName, name in style) return name;
        return origName
    }

    function isHidden(elem, el) {
        return elem = el || elem,
            "none" === jQuery.css(elem, "display") || !jQuery.contains(elem.ownerDocument, elem)
    }

    function getStyles(elem) {
        return window.getComputedStyle(elem, null)
    }

    function showHide(elements, show) {
        for (var display, elem, hidden, values = [], index = 0, length = elements.length; length > index; index++) elem = elements[index],
            elem.style && (values[index] = data_priv.get(elem, "olddisplay"), display = elem.style.display, show ? (values[index] || "none" !== display || (elem.style.display = ""), "" === elem.style.display && isHidden(elem) && (values[index] = data_priv.access(elem, "olddisplay", css_defaultDisplay(elem.nodeName)))) : values[index] || (hidden = isHidden(elem), (display && "none" !== display || !hidden) && data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"))));
        for (index = 0; length > index; index++) elem = elements[index],
            elem.style && (show && "none" !== elem.style.display && "" !== elem.style.display || (elem.style.display = show ? values[index] || "" : "none"));
        return elements
    }

    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value
    }

    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        for (var i = extra === (isBorderBox ? "border" : "content") ? 4 : "width" === name ? 1 : 0, val = 0; 4 > i; i += 2) "margin" === extra && (val += jQuery.css(elem, extra + cssExpand[i], !0, styles)),
            isBorderBox ? ("content" === extra && (val -= jQuery.css(elem, "padding" + cssExpand[i], !0, styles)), "margin" !== extra && (val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles))) : (val += jQuery.css(elem, "padding" + cssExpand[i], !0, styles), "padding" !== extra && (val += jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles)));
        return val
    }

    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = !0,
            val = "width" === name ? elem.offsetWidth : elem.offsetHeight,
            styles = getStyles(elem),
            isBorderBox = jQuery.support.boxSizing && "border-box" === jQuery.css(elem, "boxSizing", !1, styles);
        if (0 >= val || null == val) {
            if (val = curCSS(elem, name, styles), (0 > val || null == val) && (val = elem.style[name]), rnumnonpx.test(val)) return val;
            valueIsBorderBox = isBorderBox && (jQuery.support.boxSizingReliable || val === elem.style[name]),
                val = parseFloat(val) || 0
        }
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px"
    }

    function css_defaultDisplay(nodeName) {
        var doc = document,
            display = elemdisplay[nodeName];
        return display || (display = actualDisplay(nodeName, doc), "none" !== display && display || (iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>").css("cssText", "display:block !important")).appendTo(doc.documentElement), doc = (iframe[0].contentWindow || iframe[0].contentDocument).document, doc.write("<!doctype html><html><body>"), doc.close(), display = actualDisplay(nodeName, doc), iframe.detach()), elemdisplay[nodeName] = display),
            display
    }

    function actualDisplay(name, doc) {
        var elem = jQuery(doc.createElement(name)).appendTo(doc.body),
            display = jQuery.css(elem[0], "display");
        return elem.remove(),
            display
    }

    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) jQuery.each(obj,
            function (i, v) {
                traditional || rbracket.test(prefix) ? add(prefix, v) : buildParams(prefix + "[" + ("object" == typeof v ? i : "") + "]", v, traditional, add)
            });
        else if (traditional || "object" !== jQuery.type(obj)) add(prefix, obj);
        else
            for (name in obj) buildParams(prefix + "[" + name + "]", obj[name], traditional, add)
    }

    function addToPrefiltersOrTransports(structure) {
        return function (dataTypeExpression, func) {
            "string" != typeof dataTypeExpression && (func = dataTypeExpression, dataTypeExpression = "*");
            var dataType, i = 0,
                dataTypes = dataTypeExpression.toLowerCase().match(core_rnotwhite) || [];
            if (jQuery.isFunction(func))
                for (; dataType = dataTypes[i++];) "+" === dataType[0] ? (dataType = dataType.slice(1) || "*", (structure[dataType] = structure[dataType] || []).unshift(func)) : (structure[dataType] = structure[dataType] || []).push(func)
        }
    }

    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        function inspect(dataType) {
            var selected;
            return inspected[dataType] = !0,
                jQuery.each(structure[dataType] || [],
                    function (_, prefilterOrFactory) {
                        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                        return "string" != typeof dataTypeOrTransport || seekingTransport || inspected[dataTypeOrTransport] ? seekingTransport ? !(selected = dataTypeOrTransport) : void 0 : (options.dataTypes.unshift(dataTypeOrTransport), inspect(dataTypeOrTransport), !1)
                    }),
                selected
        }
        var inspected = {},
            seekingTransport = structure === transports;
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*")
    }

    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) src[key] !== undefined && ((flatOptions[key] ? target : deep || (deep = {}))[key] = src[key]);
        return deep && jQuery.extend(!0, target, deep),
            target
    }

    function ajaxHandleResponses(s, jqXHR, responses) {
        for (var ct, type, finalDataType, firstDataType, contents = s.contents,
                dataTypes = s.dataTypes;
            "*" === dataTypes[0];) dataTypes.shift(),
            ct === undefined && (ct = s.mimeType || jqXHR.getResponseHeader("Content-Type"));
        if (ct)
            for (type in contents)
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break
                }
        if (dataTypes[0] in responses) finalDataType = dataTypes[0];
        else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break
                }
                firstDataType || (firstDataType = type)
            }
            finalDataType = finalDataType || firstDataType
        }
        return finalDataType ? (finalDataType !== dataTypes[0] && dataTypes.unshift(finalDataType), responses[finalDataType]) : void 0
    }

    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {},
            dataTypes = s.dataTypes.slice();
        if (dataTypes[1])
            for (conv in s.converters) converters[conv.toLowerCase()] = s.converters[conv];
        for (current = dataTypes.shift(); current;)
            if (s.responseFields[current] && (jqXHR[s.responseFields[current]] = response), !prev && isSuccess && s.dataFilter && (response = s.dataFilter(response, s.dataType)), prev = current, current = dataTypes.shift())
                if ("*" === current) current = prev;
                else if ("*" !== prev && prev !== current) {
            if (conv = converters[prev + " " + current] || converters["* " + current], !conv)
                for (conv2 in converters)
                    if (tmp = conv2.split(" "), tmp[1] === current && (conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]])) {
                        conv === !0 ? conv = converters[conv2] : converters[conv2] !== !0 && (current = tmp[0], dataTypes.unshift(tmp[1]));
                        break
                    }
            if (conv !== !0)
                if (conv && s["throws"]) response = conv(response);
                else try {
                    response = conv(response)
                } catch (e) {
                    return {
                        state: "parsererror",
                        error: conv ? e : "No conversion from " + prev + " to " + current
                    }
                }
        }
        return {
            state: "success",
            data: response
        }
    }

    function createFxNow() {
        return setTimeout(function () {
                fxNow = undefined
            }),
            fxNow = jQuery.now()
    }

    function createTween(value, prop, animation) {
        for (var tween, collection = (tweeners[prop] || []).concat(tweeners["*"]), index = 0, length = collection.length; length > index; index++)
            if (tween = collection[index].call(animation, prop, value)) return tween
    }

    function Animation(elem, properties, options) {
        var result, stopped, index = 0,
            length = animationPrefilters.length,
            deferred = jQuery.Deferred().always(function () {
                delete tick.elem
            }),
            tick = function () {
                if (stopped) return !1;
                for (var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length; length > index; index++) animation.tweens[index].run(percent);
                return deferred.notifyWith(elem, [animation, percent, remaining]),
                    1 > percent && length ? remaining : (deferred.resolveWith(elem, [animation]), !1)
            },
            animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({},
                    properties),
                opts: jQuery.extend(!0, {
                        specialEasing: {}
                    },
                    options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function (prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                    return animation.tweens.push(tween),
                        tween
                },
                stop: function (gotoEnd) {
                    var index = 0,
                        length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped) return this;
                    for (stopped = !0; length > index; index++) animation.tweens[index].run(1);
                    return gotoEnd ? deferred.resolveWith(elem, [animation, gotoEnd]) : deferred.rejectWith(elem, [animation, gotoEnd]),
                        this
                }
            }),
            props = animation.props;
        for (propFilter(props, animation.opts.specialEasing); length > index; index++)
            if (result = animationPrefilters[index].call(animation, elem, props, animation.opts)) return result;
        return jQuery.map(props, createTween, animation),
            jQuery.isFunction(animation.opts.start) && animation.opts.start.call(elem, animation),
            jQuery.fx.timer(jQuery.extend(tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
            })),
            animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always)
    }

    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props)
            if (name = jQuery.camelCase(index), easing = specialEasing[name], value = props[index], jQuery.isArray(value) && (easing = value[1], value = props[index] = value[0]), index !== name && (props[name] = value, delete props[index]), hooks = jQuery.cssHooks[name], hooks && "expand" in hooks) {
                value = hooks.expand(value),
                    delete props[name];
                for (index in value) index in props || (props[index] = value[index], specialEasing[index] = easing)
            } else specialEasing[name] = easing
    }

    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, tween, hooks, oldfire, anim = this,
            orig = {},
            style = elem.style,
            hidden = elem.nodeType && isHidden(elem),
            dataShow = data_priv.get(elem, "fxshow");
        opts.queue || (hooks = jQuery._queueHooks(elem, "fx"), null == hooks.unqueued && (hooks.unqueued = 0, oldfire = hooks.empty.fire, hooks.empty.fire = function () {
                hooks.unqueued || oldfire()
            }), hooks.unqueued++, anim.always(function () {
                anim.always(function () {
                    hooks.unqueued--,
                        jQuery.queue(elem, "fx").length || hooks.empty.fire()
                })
            })),
            1 === elem.nodeType && ("height" in props || "width" in props) && (opts.overflow = [style.overflow, style.overflowX, style.overflowY], "inline" === jQuery.css(elem, "display") && "none" === jQuery.css(elem, "float") && (style.display = "inline-block")),
            opts.overflow && (style.overflow = "hidden", anim.always(function () {
                style.overflow = opts.overflow[0],
                    style.overflowX = opts.overflow[1],
                    style.overflowY = opts.overflow[2]
            }));
        for (prop in props)
            if (value = props[prop], rfxtypes.exec(value)) {
                if (delete props[prop], toggle = toggle || "toggle" === value, value === (hidden ? "hide" : "show")) {
                    if ("show" !== value || !dataShow || dataShow[prop] === undefined) continue;
                    hidden = !0
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop)
            }
        if (!jQuery.isEmptyObject(orig)) {
            dataShow ? "hidden" in dataShow && (hidden = dataShow.hidden) : dataShow = data_priv.access(elem, "fxshow", {}),
                toggle && (dataShow.hidden = !hidden),
                hidden ? jQuery(elem).show() : anim.done(function () {
                    jQuery(elem).hide()
                }),
                anim.done(function () {
                    var prop;
                    data_priv.remove(elem, "fxshow");
                    for (prop in orig) jQuery.style(elem, prop, orig[prop])
                });
            for (prop in orig) tween = createTween(hidden ? dataShow[prop] : 0, prop, anim),
                prop in dataShow || (dataShow[prop] = tween.start, hidden && (tween.end = tween.start, tween.start = "width" === prop || "height" === prop ? 1 : 0))
        }
    }

    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing)
    }

    function genFx(type, includeWidth) {
        var which, attrs = {
                height: type
            },
            i = 0;
        for (includeWidth = includeWidth ? 1 : 0; 4 > i; i += 2 - includeWidth) which = cssExpand[i],
            attrs["margin" + which] = attrs["padding" + which] = type;
        return includeWidth && (attrs.opacity = attrs.width = type),
            attrs
    }

    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : 9 === elem.nodeType && elem.defaultView
    }
    var rootjQuery, readyList, core_strundefined = typeof undefined,
        location = window.location,
        document = window.document,
        docElem = document.documentElement,
        _jQuery = window.jQuery,
        _$ = window.$,
        class2type = {},
        core_deletedIds = [],
        core_version = "2.0.3",
        core_concat = core_deletedIds.concat,
        core_push = core_deletedIds.push,
        core_slice = core_deletedIds.slice,
        core_indexOf = core_deletedIds.indexOf,
        core_toString = class2type.toString,
        core_hasOwn = class2type.hasOwnProperty,
        core_trim = core_version.trim,
        jQuery = function (selector, context) {
            return new jQuery.fn.init(selector, context, rootjQuery)
        },
        core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
        core_rnotwhite = /\S+/g,
        rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
        rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
        rmsPrefix = /^-ms-/,
        rdashAlpha = /-([\da-z])/gi,
        fcamelCase = function (all, letter) {
            return letter.toUpperCase()
        },
        completed = function () {
            document.removeEventListener("DOMContentLoaded", completed, !1),
                window.removeEventListener("load", completed, !1),
                jQuery.ready()
        };
    jQuery.fn = jQuery.prototype = {
            jquery: core_version,
            constructor: jQuery,
            init: function (selector, context, rootjQuery) {
                var match, elem;
                if (!selector) return this;
                if ("string" == typeof selector) {
                    if (match = "<" === selector.charAt(0) && ">" === selector.charAt(selector.length - 1) && selector.length >= 3 ? [null, selector, null] : rquickExpr.exec(selector), !match || !match[1] && context) return !context || context.jquery ? (context || rootjQuery).find(selector) : this.constructor(context).find(selector);
                    if (match[1]) {
                        if (context = context instanceof jQuery ? context[0] : context, jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, !0)), rsingleTag.test(match[1]) && jQuery.isPlainObject(context))
                            for (match in context) jQuery.isFunction(this[match]) ? this[match](context[match]) : this.attr(match, context[match]);
                        return this
                    }
                    return elem = document.getElementById(match[2]),
                        elem && elem.parentNode && (this.length = 1, this[0] = elem),
                        this.context = document,
                        this.selector = selector,
                        this
                }
                return selector.nodeType ? (this.context = this[0] = selector, this.length = 1, this) : jQuery.isFunction(selector) ? rootjQuery.ready(selector) : (selector.selector !== undefined && (this.selector = selector.selector, this.context = selector.context), jQuery.makeArray(selector, this))
            },
            selector: "",
            length: 0,
            toArray: function () {
                return core_slice.call(this)
            },
            get: function (num) {
                return null == num ? this.toArray() : 0 > num ? this[this.length + num] : this[num]
            },
            pushStack: function (elems) {
                var ret = jQuery.merge(this.constructor(), elems);
                return ret.prevObject = this,
                    ret.context = this.context,
                    ret
            },
            each: function (callback, args) {
                return jQuery.each(this, callback, args)
            },
            ready: function (fn) {
                return jQuery.ready.promise().done(fn),
                    this
            },
            slice: function () {
                return this.pushStack(core_slice.apply(this, arguments))
            },
            first: function () {
                return this.eq(0)
            },
            last: function () {
                return this.eq(-1)
            },
            eq: function (i) {
                var len = this.length,
                    j = +i + (0 > i ? len : 0);
                return this.pushStack(j >= 0 && len > j ? [this[j]] : [])
            },
            map: function (callback) {
                return this.pushStack(jQuery.map(this,
                    function (elem, i) {
                        return callback.call(elem, i, elem)
                    }))
            },
            end: function () {
                return this.prevObject || this.constructor(null)
            },
            push: core_push,
            sort: [].sort,
            splice: [].splice
        },
        jQuery.fn.init.prototype = jQuery.fn,
        jQuery.extend = jQuery.fn.extend = function () {
            var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},
                i = 1,
                length = arguments.length,
                deep = !1;
            for ("boolean" == typeof target && (deep = target, target = arguments[1] || {},
                    i = 2), "object" == typeof target || jQuery.isFunction(target) || (target = {}), length === i && (target = this, --i); length > i; i++)
                if (null != (options = arguments[i]))
                    for (name in options) src = target[name],
                        copy = options[name],
                        target !== copy && (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy))) ? (copyIsArray ? (copyIsArray = !1, clone = src && jQuery.isArray(src) ? src : []) : clone = src && jQuery.isPlainObject(src) ? src : {},
                            target[name] = jQuery.extend(deep, clone, copy)) : copy !== undefined && (target[name] = copy));
            return target
        },
        jQuery.extend({
            expando: "jQuery" + (core_version + Math.random()).replace(/\D/g, ""),
            noConflict: function (deep) {
                return window.$ === jQuery && (window.$ = _$),
                    deep && window.jQuery === jQuery && (window.jQuery = _jQuery),
                    jQuery
            },
            isReady: !1,
            readyWait: 1,
            holdReady: function (hold) {
                hold ? jQuery.readyWait++ : jQuery.ready(!0)
            },
            ready: function (wait) {
                (wait === !0 ? --jQuery.readyWait : jQuery.isReady) || (jQuery.isReady = !0, wait !== !0 && --jQuery.readyWait > 0 || (readyList.resolveWith(document, [jQuery]), jQuery.fn.trigger && jQuery(document).trigger("ready").off("ready")))
            },
            isFunction: function (obj) {
                return "function" === jQuery.type(obj)
            },
            isArray: Array.isArray,
            isWindow: function (obj) {
                return null != obj && obj === obj.window
            },
            isNumeric: function (obj) {
                return !isNaN(parseFloat(obj)) && isFinite(obj)
            },
            type: function (obj) {
                return null == obj ? String(obj) : "object" == typeof obj || "function" == typeof obj ? class2type[core_toString.call(obj)] || "object" : typeof obj
            },
            isPlainObject: function (obj) {
                if ("object" !== jQuery.type(obj) || obj.nodeType || jQuery.isWindow(obj)) return !1;
                try {
                    if (obj.constructor && !core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) return !1
                } catch (e) {
                    return !1
                }
                return !0
            },
            isEmptyObject: function (obj) {
                var name;
                for (name in obj) return !1;
                return !0
            },
            error: function (msg) {
                throw new Error(msg)
            },
            parseHTML: function (data, context, keepScripts) {
                if (!data || "string" != typeof data) return null;
                "boolean" == typeof context && (keepScripts = context, context = !1),
                    context = context || document;
                var parsed = rsingleTag.exec(data),
                    scripts = !keepScripts && [];
                return parsed ? [context.createElement(parsed[1])] : (parsed = jQuery.buildFragment([data], context, scripts), scripts && jQuery(scripts).remove(), jQuery.merge([], parsed.childNodes))
            },
            parseJSON: JSON.parse,
            parseXML: function (data) {
                var xml, tmp;
                if (!data || "string" != typeof data) return null;
                try {
                    tmp = new DOMParser,
                        xml = tmp.parseFromString(data, "text/xml")
                } catch (e) {
                    xml = undefined
                }
                return (!xml || xml.getElementsByTagName("parsererror").length) && jQuery.error("Invalid XML: " + data),
                    xml
            },
            noop: function () {},
            globalEval: function (code) {
                var script, indirect = eval;
                code = jQuery.trim(code),
                    code && (1 === code.indexOf("use strict") ? (script = document.createElement("script"), script.text = code, document.head.appendChild(script).parentNode.removeChild(script)) : indirect(code))
            },
            camelCase: function (string) {
                return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase)
            },
            nodeName: function (elem, name) {
                return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase()
            },
            each: function (obj, callback, args) {
                var value, i = 0,
                    length = obj.length,
                    isArray = isArraylike(obj);
                if (args) {
                    if (isArray)
                        for (; length > i && (value = callback.apply(obj[i], args), value !== !1); i++);
                    else
                        for (i in obj)
                            if (value = callback.apply(obj[i], args), value === !1) break
                } else if (isArray)
                    for (; length > i && (value = callback.call(obj[i], i, obj[i]), value !== !1); i++);
                else
                    for (i in obj)
                        if (value = callback.call(obj[i], i, obj[i]), value === !1) break;
                return obj
            },
            trim: function (text) {
                return null == text ? "" : core_trim.call(text)
            },
            makeArray: function (arr, results) {
                var ret = results || [];
                return null != arr && (isArraylike(Object(arr)) ? jQuery.merge(ret, "string" == typeof arr ? [arr] : arr) : core_push.call(ret, arr)),
                    ret
            },
            inArray: function (elem, arr, i) {
                return null == arr ? -1 : core_indexOf.call(arr, elem, i)
            },
            merge: function (first, second) {
                var l = second.length,
                    i = first.length,
                    j = 0;
                if ("number" == typeof l)
                    for (; l > j; j++) first[i++] = second[j];
                else
                    for (; second[j] !== undefined;) first[i++] = second[j++];
                return first.length = i,
                    first
            },
            grep: function (elems, callback, inv) {
                var retVal, ret = [],
                    i = 0,
                    length = elems.length;
                for (inv = !!inv; length > i; i++) retVal = !!callback(elems[i], i),
                    inv !== retVal && ret.push(elems[i]);
                return ret
            },
            map: function (elems, callback, arg) {
                var value, i = 0,
                    length = elems.length,
                    isArray = isArraylike(elems),
                    ret = [];
                if (isArray)
                    for (; length > i; i++) value = callback(elems[i], i, arg),
                        null != value && (ret[ret.length] = value);
                else
                    for (i in elems) value = callback(elems[i], i, arg),
                        null != value && (ret[ret.length] = value);
                return core_concat.apply([], ret)
            },
            guid: 1,
            proxy: function (fn, context) {
                var tmp, args, proxy;
                return "string" == typeof context && (tmp = fn[context], context = fn, fn = tmp),
                    jQuery.isFunction(fn) ? (args = core_slice.call(arguments, 2), proxy = function () {
                            return fn.apply(context || this, args.concat(core_slice.call(arguments)))
                        },
                        proxy.guid = fn.guid = fn.guid || jQuery.guid++, proxy) : undefined
            },
            access: function (elems, fn, key, value, chainable, emptyGet, raw) {
                var i = 0,
                    length = elems.length,
                    bulk = null == key;
                if ("object" === jQuery.type(key)) {
                    chainable = !0;
                    for (i in key) jQuery.access(elems, fn, i, key[i], !0, emptyGet, raw)
                } else if (value !== undefined && (chainable = !0, jQuery.isFunction(value) || (raw = !0), bulk && (raw ? (fn.call(elems, value), fn = null) : (bulk = fn, fn = function (elem, key, value) {
                        return bulk.call(jQuery(elem), value)
                    })), fn))
                    for (; length > i; i++) fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                return chainable ? elems : bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet
            },
            now: Date.now,
            swap: function (elem, options, callback, args) {
                var ret, name, old = {};
                for (name in options) old[name] = elem.style[name],
                    elem.style[name] = options[name];
                ret = callback.apply(elem, args || []);
                for (name in options) elem.style[name] = old[name];
                return ret
            }
        }),
        jQuery.ready.promise = function (obj) {
            return readyList || (readyList = jQuery.Deferred(), "complete" === document.readyState ? setTimeout(jQuery.ready) : (document.addEventListener("DOMContentLoaded", completed, !1), window.addEventListener("load", completed, !1))),
                readyList.promise(obj)
        },
        jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),
            function (i, name) {
                class2type["[object " + name + "]"] = name.toLowerCase()
            }),
        rootjQuery = jQuery(document),
        function (window, undefined) {
            function Sizzle(selector, context, results, seed) {
                var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
                if ((context ? context.ownerDocument || context : preferredDoc) !== document && setDocument(context), context = context || document, results = results || [], !selector || "string" != typeof selector) return results;
                if (1 !== (nodeType = context.nodeType) && 9 !== nodeType) return [];
                if (documentIsHTML && !seed) {
                    if (match = rquickExpr.exec(selector))
                        if (m = match[1]) {
                            if (9 === nodeType) {
                                if (elem = context.getElementById(m), !elem || !elem.parentNode) return results;
                                if (elem.id === m) return results.push(elem),
                                    results
                            } else if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) return results.push(elem),
                                results
                        } else {
                            if (match[2]) return push.apply(results, context.getElementsByTagName(selector)),
                                results;
                            if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) return push.apply(results, context.getElementsByClassName(m)),
                                results
                        }
                    if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                        if (nid = old = expando, newContext = context, newSelector = 9 === nodeType && selector, 1 === nodeType && "object" !== context.nodeName.toLowerCase()) {
                            for (groups = tokenize(selector), (old = context.getAttribute("id")) ? nid = old.replace(rescape, "\\$&") : context.setAttribute("id", nid), nid = "[id='" + nid + "'] ", i = groups.length; i--;) groups[i] = nid + toSelector(groups[i]);
                            newContext = rsibling.test(selector) && context.parentNode || context,
                                newSelector = groups.join(",")
                        }
                        if (newSelector) try {
                            return push.apply(results, newContext.querySelectorAll(newSelector)),
                                results
                        } catch (qsaError) {} finally {
                            old || context.removeAttribute("id")
                        }
                    }
                }
                return select(selector.replace(rtrim, "$1"), context, results, seed)
            }

            function createCache() {
                function cache(key, value) {
                    return keys.push(key += " ") > Expr.cacheLength && delete cache[keys.shift()],
                        cache[key] = value
                }
                var keys = [];
                return cache
            }

            function markFunction(fn) {
                return fn[expando] = !0,
                    fn
            }

            function assert(fn) {
                var div = document.createElement("div");
                try {
                    return !!fn(div)
                } catch (e) {
                    return !1
                } finally {
                    div.parentNode && div.parentNode.removeChild(div),
                        div = null
                }
            }

            function addHandle(attrs, handler) {
                for (var arr = attrs.split("|"), i = attrs.length; i--;) Expr.attrHandle[arr[i]] = handler
            }

            function siblingCheck(a, b) {
                var cur = b && a,
                    diff = cur && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
                if (diff) return diff;
                if (cur)
                    for (; cur = cur.nextSibling;)
                        if (cur === b) return -1;
                return a ? 1 : -1
            }

            function createInputPseudo(type) {
                return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return "input" === name && elem.type === type
                }
            }

            function createButtonPseudo(type) {
                return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return ("input" === name || "button" === name) && elem.type === type
                }
            }

            function createPositionalPseudo(fn) {
                return markFunction(function (argument) {
                    return argument = +argument,
                        markFunction(function (seed, matches) {
                            for (var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length; i--;) seed[j = matchIndexes[i]] && (seed[j] = !(matches[j] = seed[j]))
                        })
                })
            }

            function setFilters() {}

            function tokenize(selector, parseOnly) {
                var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
                if (cached) return parseOnly ? 0 : cached.slice(0);
                for (soFar = selector, groups = [], preFilters = Expr.preFilter; soFar;) {
                    (!matched || (match = rcomma.exec(soFar))) && (match && (soFar = soFar.slice(match[0].length) || soFar), groups.push(tokens = [])),
                    matched = !1,
                        (match = rcombinators.exec(soFar)) && (matched = match.shift(), tokens.push({
                            value: matched,
                            type: match[0].replace(rtrim, " ")
                        }), soFar = soFar.slice(matched.length));
                    for (type in Expr.filter) !(match = matchExpr[type].exec(soFar)) || preFilters[type] && !(match = preFilters[type](match)) || (matched = match.shift(), tokens.push({
                        value: matched,
                        type: type,
                        matches: match
                    }), soFar = soFar.slice(matched.length));
                    if (!matched) break
                }
                return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0)
            }

            function toSelector(tokens) {
                for (var i = 0,
                        len = tokens.length,
                        selector = ""; len > i; i++) selector += tokens[i].value;
                return selector
            }

            function addCombinator(matcher, combinator, base) {
                var dir = combinator.dir,
                    checkNonElements = base && "parentNode" === dir,
                    doneName = done++;
                return combinator.first ?
                    function (elem, context, xml) {
                        for (; elem = elem[dir];)
                            if (1 === elem.nodeType || checkNonElements) return matcher(elem, context, xml)
                    } : function (elem, context, xml) {
                        var data, cache, outerCache, dirkey = dirruns + " " + doneName;
                        if (xml) {
                            for (; elem = elem[dir];)
                                if ((1 === elem.nodeType || checkNonElements) && matcher(elem, context, xml)) return !0
                        } else
                            for (; elem = elem[dir];)
                                if (1 === elem.nodeType || checkNonElements)
                                    if (outerCache = elem[expando] || (elem[expando] = {}), (cache = outerCache[dir]) && cache[0] === dirkey) {
                                        if ((data = cache[1]) === !0 || data === cachedruns) return data === !0
                                    } else if (cache = outerCache[dir] = [dirkey], cache[1] = matcher(elem, context, xml) || cachedruns, cache[1] === !0) return !0
                    }
            }

            function elementMatcher(matchers) {
                return matchers.length > 1 ?
                    function (elem, context, xml) {
                        for (var i = matchers.length; i--;)
                            if (!matchers[i](elem, context, xml)) return !1;
                        return !0
                    } : matchers[0]
            }

            function condense(unmatched, map, filter, context, xml) {
                for (var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = null != map; len > i; i++)(elem = unmatched[i]) && (!filter || filter(elem, context, xml)) && (newUnmatched.push(elem), mapped && map.push(i));
                return newUnmatched
            }

            function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                return postFilter && !postFilter[expando] && (postFilter = setMatcher(postFilter)),
                    postFinder && !postFinder[expando] && (postFinder = setMatcher(postFinder, postSelector)),
                    markFunction(function (seed, results, context, xml) {
                        var temp, i, elem, preMap = [],
                            postMap = [],
                            preexisting = results.length,
                            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
                            matcherIn = !preFilter || !seed && selector ? elems : condense(elems, preMap, preFilter, context, xml),
                            matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                        if (matcher && matcher(matcherIn, matcherOut, context, xml), postFilter)
                            for (temp = condense(matcherOut, postMap), postFilter(temp, [], context, xml), i = temp.length; i--;)(elem = temp[i]) && (matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem));
                        if (seed) {
                            if (postFinder || preFilter) {
                                if (postFinder) {
                                    for (temp = [], i = matcherOut.length; i--;)(elem = matcherOut[i]) && temp.push(matcherIn[i] = elem);
                                    postFinder(null, matcherOut = [], temp, xml)
                                }
                                for (i = matcherOut.length; i--;)(elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1 && (seed[temp] = !(results[temp] = elem))
                            }
                        } else matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut),
                            postFinder ? postFinder(null, results, matcherOut, xml) : push.apply(results, matcherOut)
                    })
            }

            function matcherFromTokens(tokens) {
                for (var checkContext, matcher, j, len = tokens.length,
                        leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
                                return elem === checkContext
                            },
                            implicitRelative, !0), matchAnyContext = addCombinator(function (elem) {
                                return indexOf.call(checkContext, elem) > -1
                            },
                            implicitRelative, !0), matchers = [function (elem, context, xml) {
                            return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml))
                        }]; len > i; i++)
                    if (matcher = Expr.relative[tokens[i].type]) matchers = [addCombinator(elementMatcher(matchers), matcher)];
                    else {
                        if (matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches), matcher[expando]) {
                            for (j = ++i; len > j && !Expr.relative[tokens[j].type]; j++);
                            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                                value: " " === tokens[i - 2].type ? "*" : ""
                            })).replace(rtrim, "$1"), matcher, j > i && matcherFromTokens(tokens.slice(i, j)), len > j && matcherFromTokens(tokens = tokens.slice(j)), len > j && toSelector(tokens))
                        }
                        matchers.push(matcher)
                    }
                return elementMatcher(matchers)
            }

            function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                var matcherCachedRuns = 0,
                    bySet = setMatchers.length > 0,
                    byElement = elementMatchers.length > 0,
                    superMatcher = function (seed, context, xml, results, expandContext) {
                        var elem, j, matcher, setMatched = [],
                            matchedCount = 0,
                            i = "0",
                            unmatched = seed && [],
                            outermost = null != expandContext,
                            contextBackup = outermostContext,
                            elems = seed || byElement && Expr.find.TAG("*", expandContext && context.parentNode || context),
                            dirrunsUnique = dirruns += null == contextBackup ? 1 : Math.random() || .1;
                        for (outermost && (outermostContext = context !== document && context, cachedruns = matcherCachedRuns); null != (elem = elems[i]); i++) {
                            if (byElement && elem) {
                                for (j = 0; matcher = elementMatchers[j++];)
                                    if (matcher(elem, context, xml)) {
                                        results.push(elem);
                                        break
                                    }
                                outermost && (dirruns = dirrunsUnique, cachedruns = ++matcherCachedRuns)
                            }
                            bySet && ((elem = !matcher && elem) && matchedCount--, seed && unmatched.push(elem))
                        }
                        if (matchedCount += i, bySet && i !== matchedCount) {
                            for (j = 0; matcher = setMatchers[j++];) matcher(unmatched, setMatched, context, xml);
                            if (seed) {
                                if (matchedCount > 0)
                                    for (; i--;) unmatched[i] || setMatched[i] || (setMatched[i] = pop.call(results));
                                setMatched = condense(setMatched)
                            }
                            push.apply(results, setMatched),
                                outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1 && Sizzle.uniqueSort(results)
                        }
                        return outermost && (dirruns = dirrunsUnique, outermostContext = contextBackup),
                            unmatched
                    };
                return bySet ? markFunction(superMatcher) : superMatcher
            }

            function multipleContexts(selector, contexts, results) {
                for (var i = 0,
                        len = contexts.length; len > i; i++) Sizzle(selector, contexts[i], results);
                return results
            }

            function select(selector, context, results, seed) {
                var i, tokens, token, type, find, match = tokenize(selector);
                if (!seed && 1 === match.length) {
                    if (tokens = match[0] = match[0].slice(0), tokens.length > 2 && "ID" === (token = tokens[0]).type && support.getById && 9 === context.nodeType && documentIsHTML && Expr.relative[tokens[1].type]) {
                        if (context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0], !context) return results;
                        selector = selector.slice(tokens.shift().value.length)
                    }
                    for (i = matchExpr.needsContext.test(selector) ? 0 : tokens.length; i-- && (token = tokens[i], !Expr.relative[type = token.type]);)
                        if ((find = Expr.find[type]) && (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && context.parentNode || context))) {
                            if (tokens.splice(i, 1), selector = seed.length && toSelector(tokens), !selector) return push.apply(results, seed),
                                results;
                            break
                        }
                }
                return compile(selector, match)(seed, context, !documentIsHTML, results, rsibling.test(selector)),
                    results
            }
            var i, support, cachedruns, Expr, getText, isXML, compile, outermostContext, sortInput, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + -new Date,
                preferredDoc = window.document,
                dirruns = 0,
                done = 0,
                classCache = createCache(),
                tokenCache = createCache(),
                compilerCache = createCache(),
                hasDuplicate = !1,
                sortOrder = function (a, b) {
                    return a === b ? (hasDuplicate = !0, 0) : 0
                },
                strundefined = typeof undefined,
                MAX_NEGATIVE = 1 << 31,
                hasOwn = {}.hasOwnProperty,
                arr = [],
                pop = arr.pop,
                push_native = arr.push,
                push = arr.push,
                slice = arr.slice,
                indexOf = arr.indexOf ||
                function (elem) {
                    for (var i = 0,
                            len = this.length; len > i; i++)
                        if (this[i] === elem) return i;
                    return -1
                },
                booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                whitespace = "[\\x20\\t\\r\\n\\f]",
                characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
                identifier = characterEncoding.replace("w", "w#"),
                attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace + "*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",
                pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace(3, 8) + ")*)|.*)\\)|)",
                rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
                rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
                rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
                rsibling = new RegExp(whitespace + "*[+~]"),
                rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*)" + whitespace + "*\\]", "g"),
                rpseudo = new RegExp(pseudos),
                ridentifier = new RegExp("^" + identifier + "$"),
                matchExpr = {
                    ID: new RegExp("^#(" + characterEncoding + ")"),
                    CLASS: new RegExp("^\\.(" + characterEncoding + ")"),
                    TAG: new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
                    ATTR: new RegExp("^" + attributes),
                    PSEUDO: new RegExp("^" + pseudos),
                    CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                    bool: new RegExp("^(?:" + booleans + ")$", "i"),
                    needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
                },
                rnative = /^[^{]+\{\s*\[native \w/,
                rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                rinputs = /^(?:input|select|textarea|button)$/i,
                rheader = /^h\d$/i,
                rescape = /'|\\/g,
                runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
                funescape = function (_, escaped, escapedWhitespace) {
                    var high = "0x" + escaped - 65536;
                    return high !== high || escapedWhitespace ? escaped : 0 > high ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, 1023 & high | 56320)
                };
            try {
                push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes),
                    arr[preferredDoc.childNodes.length].nodeType
            } catch (e) {
                push = {
                    apply: arr.length ?
                        function (target, els) {
                            push_native.apply(target, slice.call(els))
                        } : function (target, els) {
                            for (var j = target.length,
                                    i = 0; target[j++] = els[i++];);
                            target.length = j - 1
                        }
                }
            }
            isXML = Sizzle.isXML = function (elem) {
                    var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                    return documentElement ? "HTML" !== documentElement.nodeName : !1
                },
                support = Sizzle.support = {},
                setDocument = Sizzle.setDocument = function (node) {
                    var doc = node ? node.ownerDocument || node : preferredDoc,
                        parent = doc.defaultView;
                    return doc !== document && 9 === doc.nodeType && doc.documentElement ? (document = doc, docElem = doc.documentElement, documentIsHTML = !isXML(doc), parent && parent.attachEvent && parent !== parent.top && parent.attachEvent("onbeforeunload",
                            function () {
                                setDocument()
                            }), support.attributes = assert(function (div) {
                            return div.className = "i", !div.getAttribute("className")
                        }), support.getElementsByTagName = assert(function (div) {
                            return div.appendChild(doc.createComment("")), !div.getElementsByTagName("*").length
                        }), support.getElementsByClassName = assert(function (div) {
                            return div.innerHTML = "<div class='a'></div><div class='a i'></div>",
                                div.firstChild.className = "i",
                                2 === div.getElementsByClassName("i").length
                        }), support.getById = assert(function (div) {
                            return docElem.appendChild(div).id = expando, !doc.getElementsByName || !doc.getElementsByName(expando).length
                        }), support.getById ? (Expr.find.ID = function (id, context) {
                                if (typeof context.getElementById !== strundefined && documentIsHTML) {
                                    var m = context.getElementById(id);
                                    return m && m.parentNode ? [m] : []
                                }
                            },
                            Expr.filter.ID = function (id) {
                                var attrId = id.replace(runescape, funescape);
                                return function (elem) {
                                    return elem.getAttribute("id") === attrId
                                }
                            }) : (delete Expr.find.ID, Expr.filter.ID = function (id) {
                            var attrId = id.replace(runescape, funescape);
                            return function (elem) {
                                var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
                                return node && node.value === attrId
                            }
                        }), Expr.find.TAG = support.getElementsByTagName ?
                        function (tag, context) {
                            return typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName(tag) : void 0
                        } : function (tag, context) {
                            var elem, tmp = [],
                                i = 0,
                                results = context.getElementsByTagName(tag);
                            if ("*" === tag) {
                                for (; elem = results[i++];) 1 === elem.nodeType && tmp.push(elem);
                                return tmp
                            }
                            return results
                        },
                        Expr.find.CLASS = support.getElementsByClassName &&
                        function (className, context) {
                            return typeof context.getElementsByClassName !== strundefined && documentIsHTML ? context.getElementsByClassName(className) : void 0
                        },
                        rbuggyMatches = [], rbuggyQSA = [], (support.qsa = rnative.test(doc.querySelectorAll)) && (assert(function (div) {
                            div.innerHTML = "<select><option selected=''></option></select>",
                                div.querySelectorAll("[selected]").length || rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")"),
                                div.querySelectorAll(":checked").length || rbuggyQSA.push(":checked")
                        }), assert(function (div) {
                            var input = doc.createElement("input");
                            input.setAttribute("type", "hidden"),
                                div.appendChild(input).setAttribute("t", ""),
                                div.querySelectorAll("[t^='']").length && rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")"),
                                div.querySelectorAll(":enabled").length || rbuggyQSA.push(":enabled", ":disabled"),
                                div.querySelectorAll("*,:x"),
                                rbuggyQSA.push(",.*:")
                        })), (support.matchesSelector = rnative.test(matches = docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) && assert(function (div) {
                            support.disconnectedMatch = matches.call(div, "div"),
                                matches.call(div, "[s!='']:x"),
                                rbuggyMatches.push("!=", pseudos)
                        }), rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|")), rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|")), contains = rnative.test(docElem.contains) || docElem.compareDocumentPosition ?
                        function (a, b) {
                            var adown = 9 === a.nodeType ? a.documentElement : a,
                                bup = b && b.parentNode;
                            return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)))
                        } : function (a, b) {
                            if (b)
                                for (; b = b.parentNode;)
                                    if (b === a) return !0;
                            return !1
                        },
                        sortOrder = docElem.compareDocumentPosition ?
                        function (a, b) {
                            if (a === b) return hasDuplicate = !0,
                                0;
                            var compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition(b);
                            return compare ? 1 & compare || !support.sortDetached && b.compareDocumentPosition(a) === compare ? a === doc || contains(preferredDoc, a) ? -1 : b === doc || contains(preferredDoc, b) ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0 : 4 & compare ? -1 : 1 : a.compareDocumentPosition ? -1 : 1
                        } : function (a, b) {
                            var cur, i = 0,
                                aup = a.parentNode,
                                bup = b.parentNode,
                                ap = [a],
                                bp = [b];
                            if (a === b) return hasDuplicate = !0,
                                0;
                            if (!aup || !bup) return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                            if (aup === bup) return siblingCheck(a, b);
                            for (cur = a; cur = cur.parentNode;) ap.unshift(cur);
                            for (cur = b; cur = cur.parentNode;) bp.unshift(cur);
                            for (; ap[i] === bp[i];) i++;
                            return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0
                        },
                        doc) : document
                },
                Sizzle.matches = function (expr, elements) {
                    return Sizzle(expr, null, null, elements)
                },
                Sizzle.matchesSelector = function (elem, expr) {
                    if ((elem.ownerDocument || elem) !== document && setDocument(elem), expr = expr.replace(rattributeQuotes, "='$1']"), !(!support.matchesSelector || !documentIsHTML || rbuggyMatches && rbuggyMatches.test(expr) || rbuggyQSA && rbuggyQSA.test(expr))) try {
                        var ret = matches.call(elem, expr);
                        if (ret || support.disconnectedMatch || elem.document && 11 !== elem.document.nodeType) return ret
                    } catch (e) {}
                    return Sizzle(expr, document, null, [elem]).length > 0
                },
                Sizzle.contains = function (context, elem) {
                    return (context.ownerDocument || context) !== document && setDocument(context),
                        contains(context, elem)
                },
                Sizzle.attr = function (elem, name) {
                    (elem.ownerDocument || elem) !== document && setDocument(elem);
                    var fn = Expr.attrHandle[name.toLowerCase()],
                        val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
                    return val === undefined ? support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null : val
                },
                Sizzle.error = function (msg) {
                    throw new Error("Syntax error, unrecognized expression: " + msg)
                },
                Sizzle.uniqueSort = function (results) {
                    var elem, duplicates = [],
                        j = 0,
                        i = 0;
                    if (hasDuplicate = !support.detectDuplicates, sortInput = !support.sortStable && results.slice(0), results.sort(sortOrder), hasDuplicate) {
                        for (; elem = results[i++];) elem === results[i] && (j = duplicates.push(i));
                        for (; j--;) results.splice(duplicates[j], 1)
                    }
                    return results
                },
                getText = Sizzle.getText = function (elem) {
                    var node, ret = "",
                        i = 0,
                        nodeType = elem.nodeType;
                    if (nodeType) {
                        if (1 === nodeType || 9 === nodeType || 11 === nodeType) {
                            if ("string" == typeof elem.textContent) return elem.textContent;
                            for (elem = elem.firstChild; elem; elem = elem.nextSibling) ret += getText(elem)
                        } else if (3 === nodeType || 4 === nodeType) return elem.nodeValue
                    } else
                        for (; node = elem[i]; i++) ret += getText(node);
                    return ret
                },
                Expr = Sizzle.selectors = {
                    cacheLength: 50,
                    createPseudo: markFunction,
                    match: matchExpr,
                    attrHandle: {},
                    find: {},
                    relative: {
                        ">": {
                            dir: "parentNode",
                            first: !0
                        },
                        " ": {
                            dir: "parentNode"
                        },
                        "+": {
                            dir: "previousSibling",
                            first: !0
                        },
                        "~": {
                            dir: "previousSibling"
                        }
                    },
                    preFilter: {
                        ATTR: function (match) {
                            return match[1] = match[1].replace(runescape, funescape),
                                match[3] = (match[4] || match[5] || "").replace(runescape, funescape),
                                "~=" === match[2] && (match[3] = " " + match[3] + " "),
                                match.slice(0, 4)
                        },
                        CHILD: function (match) {
                            return match[1] = match[1].toLowerCase(),
                                "nth" === match[1].slice(0, 3) ? (match[3] || Sizzle.error(match[0]), match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * ("even" === match[3] || "odd" === match[3])), match[5] = +(match[7] + match[8] || "odd" === match[3])) : match[3] && Sizzle.error(match[0]),
                                match
                        },
                        PSEUDO: function (match) {
                            var excess, unquoted = !match[5] && match[2];
                            return matchExpr.CHILD.test(match[0]) ? null : (match[3] && match[4] !== undefined ? match[2] = match[4] : unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, !0)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length) && (match[0] = match[0].slice(0, excess), match[2] = unquoted.slice(0, excess)), match.slice(0, 3))
                        }
                    },
                    filter: {
                        TAG: function (nodeNameSelector) {
                            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                            return "*" === nodeNameSelector ?
                                function () {
                                    return !0
                                } : function (elem) {
                                    return elem.nodeName && elem.nodeName.toLowerCase() === nodeName
                                }
                        },
                        CLASS: function (className) {
                            var pattern = classCache[className + " "];
                            return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className,
                                function (elem) {
                                    return pattern.test("string" == typeof elem.className && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "")
                                })
                        },
                        ATTR: function (name, operator, check) {
                            return function (elem) {
                                var result = Sizzle.attr(elem, name);
                                return null == result ? "!=" === operator : operator ? (result += "", "=" === operator ? result === check : "!=" === operator ? result !== check : "^=" === operator ? check && 0 === result.indexOf(check) : "*=" === operator ? check && result.indexOf(check) > -1 : "$=" === operator ? check && result.slice(-check.length) === check : "~=" === operator ? (" " + result + " ").indexOf(check) > -1 : "|=" === operator ? result === check || result.slice(0, check.length + 1) === check + "-" : !1) : !0
                            }
                        },
                        CHILD: function (type, what, argument, first, last) {
                            var simple = "nth" !== type.slice(0, 3),
                                forward = "last" !== type.slice(-4),
                                ofType = "of-type" === what;
                            return 1 === first && 0 === last ?
                                function (elem) {
                                    return !!elem.parentNode
                                } : function (elem, context, xml) {
                                    var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling",
                                        parent = elem.parentNode,
                                        name = ofType && elem.nodeName.toLowerCase(),
                                        useCache = !xml && !ofType;
                                    if (parent) {
                                        if (simple) {
                                            for (; dir;) {
                                                for (node = elem; node = node[dir];)
                                                    if (ofType ? node.nodeName.toLowerCase() === name : 1 === node.nodeType) return !1;
                                                start = dir = "only" === type && !start && "nextSibling"
                                            }
                                            return !0
                                        }
                                        if (start = [forward ? parent.firstChild : parent.lastChild], forward && useCache) {
                                            for (outerCache = parent[expando] || (parent[expando] = {}), cache = outerCache[type] || [], nodeIndex = cache[0] === dirruns && cache[1], diff = cache[0] === dirruns && cache[2], node = nodeIndex && parent.childNodes[nodeIndex]; node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop();)
                                                if (1 === node.nodeType && ++diff && node === elem) {
                                                    outerCache[type] = [dirruns, nodeIndex, diff];
                                                    break
                                                }
                                        } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) diff = cache[1];
                                        else
                                            for (;
                                                (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) && ((ofType ? node.nodeName.toLowerCase() !== name : 1 !== node.nodeType) || !++diff || (useCache && ((node[expando] || (node[expando] = {}))[type] = [dirruns, diff]), node !== elem)););
                                        return diff -= last,
                                            diff === first || diff % first === 0 && diff / first >= 0
                                    }
                                }
                        },
                        PSEUDO: function (pseudo, argument) {
                            var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                            return fn[expando] ? fn(argument) : fn.length > 1 ? (args = [pseudo, pseudo, "", argument], Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                                for (var idx, matched = fn(seed, argument), i = matched.length; i--;) idx = indexOf.call(seed, matched[i]),
                                    seed[idx] = !(matches[idx] = matched[i])
                            }) : function (elem) {
                                return fn(elem, 0, args)
                            }) : fn
                        }
                    },
                    pseudos: {
                        not: markFunction(function (selector) {
                            var input = [],
                                results = [],
                                matcher = compile(selector.replace(rtrim, "$1"));
                            return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                                for (var elem, unmatched = matcher(seed, null, xml, []), i = seed.length; i--;)(elem = unmatched[i]) && (seed[i] = !(matches[i] = elem))
                            }) : function (elem, context, xml) {
                                return input[0] = elem,
                                    matcher(input, null, xml, results), !results.pop()
                            }
                        }),
                        has: markFunction(function (selector) {
                            return function (elem) {
                                return Sizzle(selector, elem).length > 0
                            }
                        }),
                        contains: markFunction(function (text) {
                            return function (elem) {
                                return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1
                            }
                        }),
                        lang: markFunction(function (lang) {
                            return ridentifier.test(lang || "") || Sizzle.error("unsupported lang: " + lang),
                                lang = lang.replace(runescape, funescape).toLowerCase(),
                                function (elem) {
                                    var elemLang;
                                    do
                                        if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) return elemLang = elemLang.toLowerCase(),
                                            elemLang === lang || 0 === elemLang.indexOf(lang + "-");
                                    while ((elem = elem.parentNode) && 1 === elem.nodeType);
                                    return !1
                                }
                        }),
                        target: function (elem) {
                            var hash = window.location && window.location.hash;
                            return hash && hash.slice(1) === elem.id
                        },
                        root: function (elem) {
                            return elem === docElem
                        },
                        focus: function (elem) {
                            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex)
                        },
                        enabled: function (elem) {
                            return elem.disabled === !1
                        },
                        disabled: function (elem) {
                            return elem.disabled === !0
                        },
                        checked: function (elem) {
                            var nodeName = elem.nodeName.toLowerCase();
                            return "input" === nodeName && !!elem.checked || "option" === nodeName && !!elem.selected
                        },
                        selected: function (elem) {
                            return elem.parentNode && elem.parentNode.selectedIndex,
                                elem.selected === !0
                        },
                        empty: function (elem) {
                            for (elem = elem.firstChild; elem; elem = elem.nextSibling)
                                if (elem.nodeName > "@" || 3 === elem.nodeType || 4 === elem.nodeType) return !1;
                            return !0
                        },
                        parent: function (elem) {
                            return !Expr.pseudos.empty(elem)
                        },
                        header: function (elem) {
                            return rheader.test(elem.nodeName)
                        },
                        input: function (elem) {
                            return rinputs.test(elem.nodeName)
                        },
                        button: function (elem) {
                            var name = elem.nodeName.toLowerCase();
                            return "input" === name && "button" === elem.type || "button" === name
                        },
                        text: function (elem) {
                            var attr;
                            return "input" === elem.nodeName.toLowerCase() && "text" === elem.type && (null == (attr = elem.getAttribute("type")) || attr.toLowerCase() === elem.type)
                        },
                        first: createPositionalPseudo(function () {
                            return [0]
                        }),
                        last: createPositionalPseudo(function (matchIndexes, length) {
                            return [length - 1]
                        }),
                        eq: createPositionalPseudo(function (matchIndexes, length, argument) {
                            return [0 > argument ? argument + length : argument]
                        }),
                        even: createPositionalPseudo(function (matchIndexes, length) {
                            for (var i = 0; length > i; i += 2) matchIndexes.push(i);
                            return matchIndexes
                        }),
                        odd: createPositionalPseudo(function (matchIndexes, length) {
                            for (var i = 1; length > i; i += 2) matchIndexes.push(i);
                            return matchIndexes
                        }),
                        lt: createPositionalPseudo(function (matchIndexes, length, argument) {
                            for (var i = 0 > argument ? argument + length : argument; --i >= 0;) matchIndexes.push(i);
                            return matchIndexes
                        }),
                        gt: createPositionalPseudo(function (matchIndexes, length, argument) {
                            for (var i = 0 > argument ? argument + length : argument; ++i < length;) matchIndexes.push(i);
                            return matchIndexes
                        })
                    }
                },
                Expr.pseudos.nth = Expr.pseudos.eq;
            for (i in {
                    radio: !0,
                    checkbox: !0,
                    file: !0,
                    password: !0,
                    image: !0
                }) Expr.pseudos[i] = createInputPseudo(i);
            for (i in {
                    submit: !0,
                    reset: !0
                }) Expr.pseudos[i] = createButtonPseudo(i);
            setFilters.prototype = Expr.filters = Expr.pseudos,
                Expr.setFilters = new setFilters,
                compile = Sizzle.compile = function (selector, group) {
                    var i, setMatchers = [],
                        elementMatchers = [],
                        cached = compilerCache[selector + " "];
                    if (!cached) {
                        for (group || (group = tokenize(selector)), i = group.length; i--;) cached = matcherFromTokens(group[i]),
                            cached[expando] ? setMatchers.push(cached) : elementMatchers.push(cached);
                        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers))
                    }
                    return cached
                },
                support.sortStable = expando.split("").sort(sortOrder).join("") === expando,
                support.detectDuplicates = hasDuplicate,
                setDocument(),
                support.sortDetached = assert(function (div1) {
                    return 1 & div1.compareDocumentPosition(document.createElement("div"))
                }),
                assert(function (div) {
                    return div.innerHTML = "<a href='#'></a>",
                        "#" === div.firstChild.getAttribute("href")
                }) || addHandle("type|href|height|width",
                    function (elem, name, isXML) {
                        return isXML ? void 0 : elem.getAttribute(name, "type" === name.toLowerCase() ? 1 : 2)
                    }),
                support.attributes && assert(function (div) {
                    return div.innerHTML = "<input/>",
                        div.firstChild.setAttribute("value", ""),
                        "" === div.firstChild.getAttribute("value")
                }) || addHandle("value",
                    function (elem, name, isXML) {
                        return isXML || "input" !== elem.nodeName.toLowerCase() ? void 0 : elem.defaultValue
                    }),
                assert(function (div) {
                    return null == div.getAttribute("disabled")
                }) || addHandle(booleans,
                    function (elem, name, isXML) {
                        var val;
                        return isXML ? void 0 : (val = elem.getAttributeNode(name)) && val.specified ? val.value : elem[name] === !0 ? name.toLowerCase() : null
                    }),
                jQuery.find = Sizzle,
                jQuery.expr = Sizzle.selectors,
                jQuery.expr[":"] = jQuery.expr.pseudos,
                jQuery.unique = Sizzle.uniqueSort,
                jQuery.text = Sizzle.getText,
                jQuery.isXMLDoc = Sizzle.isXML,
                jQuery.contains = Sizzle.contains
        }(window);
    var optionsCache = {};
    jQuery.Callbacks = function (options) {
            options = "string" == typeof options ? optionsCache[options] || createOptions(options) : jQuery.extend({},
                options);
            var memory, fired, firing, firingStart, firingLength, firingIndex, list = [],
                stack = !options.once && [],
                fire = function (data) {
                    for (memory = options.memory && data, fired = !0, firingIndex = firingStart || 0, firingStart = 0, firingLength = list.length, firing = !0; list && firingLength > firingIndex; firingIndex++)
                        if (list[firingIndex].apply(data[0], data[1]) === !1 && options.stopOnFalse) {
                            memory = !1;
                            break
                        }
                    firing = !1,
                        list && (stack ? stack.length && fire(stack.shift()) : memory ? list = [] : self.disable())
                },
                self = {
                    add: function () {
                        if (list) {
                            var start = list.length;
                            !
                            function add(args) {
                                jQuery.each(args,
                                    function (_, arg) {
                                        var type = jQuery.type(arg);
                                        "function" === type ? options.unique && self.has(arg) || list.push(arg) : arg && arg.length && "string" !== type && add(arg)
                                    })
                            }(arguments),
                            firing ? firingLength = list.length : memory && (firingStart = start, fire(memory))
                        }
                        return this
                    },
                    remove: function () {
                        return list && jQuery.each(arguments,
                                function (_, arg) {
                                    for (var index;
                                        (index = jQuery.inArray(arg, list, index)) > -1;) list.splice(index, 1),
                                        firing && (firingLength >= index && firingLength--, firingIndex >= index && firingIndex--)
                                }),
                            this
                    },
                    has: function (fn) {
                        return fn ? jQuery.inArray(fn, list) > -1 : !(!list || !list.length)
                    },
                    empty: function () {
                        return list = [],
                            firingLength = 0,
                            this
                    },
                    disable: function () {
                        return list = stack = memory = undefined,
                            this
                    },
                    disabled: function () {
                        return !list
                    },
                    lock: function () {
                        return stack = undefined,
                            memory || self.disable(),
                            this
                    },
                    locked: function () {
                        return !stack
                    },
                    fireWith: function (context, args) {
                        return !list || fired && !stack || (args = args || [], args = [context, args.slice ? args.slice() : args], firing ? stack.push(args) : fire(args)),
                            this
                    },
                    fire: function () {
                        return self.fireWith(this, arguments),
                            this
                    },
                    fired: function () {
                        return !!fired
                    }
                };
            return self
        },
        jQuery.extend({
            Deferred: function (func) {
                var tuples = [
                        ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
                        ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
                        ["notify", "progress", jQuery.Callbacks("memory")]
                    ],
                    state = "pending",
                    promise = {
                        state: function () {
                            return state
                        },
                        always: function () {
                            return deferred.done(arguments).fail(arguments),
                                this
                        },
                        then: function () {
                            var fns = arguments;
                            return jQuery.Deferred(function (newDefer) {
                                jQuery.each(tuples,
                                        function (i, tuple) {
                                            var action = tuple[0],
                                                fn = jQuery.isFunction(fns[i]) && fns[i];
                                            deferred[tuple[1]](function () {
                                                var returned = fn && fn.apply(this, arguments);
                                                returned && jQuery.isFunction(returned.promise) ? returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify) : newDefer[action + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments)
                                            })
                                        }),
                                    fns = null
                            }).promise()
                        },
                        promise: function (obj) {
                            return null != obj ? jQuery.extend(obj, promise) : promise
                        }
                    },
                    deferred = {};
                return promise.pipe = promise.then,
                    jQuery.each(tuples,
                        function (i, tuple) {
                            var list = tuple[2],
                                stateString = tuple[3];
                            promise[tuple[1]] = list.add,
                                stateString && list.add(function () {
                                        state = stateString
                                    },
                                    tuples[1 ^ i][2].disable, tuples[2][2].lock),
                                deferred[tuple[0]] = function () {
                                    return deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments),
                                        this
                                },
                                deferred[tuple[0] + "With"] = list.fireWith
                        }),
                    promise.promise(deferred),
                    func && func.call(deferred, deferred),
                    deferred
            },
            when: function (subordinate) {
                var progressValues, progressContexts, resolveContexts, i = 0,
                    resolveValues = core_slice.call(arguments),
                    length = resolveValues.length,
                    remaining = 1 !== length || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,
                    deferred = 1 === remaining ? subordinate : jQuery.Deferred(),
                    updateFunc = function (i, contexts, values) {
                        return function (value) {
                            contexts[i] = this,
                                values[i] = arguments.length > 1 ? core_slice.call(arguments) : value,
                                values === progressValues ? deferred.notifyWith(contexts, values) : --remaining || deferred.resolveWith(contexts, values)
                        }
                    };
                if (length > 1)
                    for (progressValues = new Array(length), progressContexts = new Array(length), resolveContexts = new Array(length); length > i; i++) resolveValues[i] && jQuery.isFunction(resolveValues[i].promise) ? resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues)) : --remaining;
                return remaining || deferred.resolveWith(resolveContexts, resolveValues),
                    deferred.promise()
            }
        }),
        jQuery.support = function (support) {
            var input = document.createElement("input"),
                fragment = document.createDocumentFragment(),
                div = document.createElement("div"),
                select = document.createElement("select"),
                opt = select.appendChild(document.createElement("option"));
            return input.type ? (input.type = "checkbox", support.checkOn = "" !== input.value, support.optSelected = opt.selected, support.reliableMarginRight = !0, support.boxSizingReliable = !0, support.pixelPosition = !1, input.checked = !0, support.noCloneChecked = input.cloneNode(!0).checked, select.disabled = !0, support.optDisabled = !opt.disabled, input = document.createElement("input"), input.value = "t", input.type = "radio", support.radioValue = "t" === input.value, input.setAttribute("checked", "t"), input.setAttribute("name", "t"), fragment.appendChild(input), support.checkClone = fragment.cloneNode(!0).cloneNode(!0).lastChild.checked, support.focusinBubbles = "onfocusin" in window, div.style.backgroundClip = "content-box", div.cloneNode(!0).style.backgroundClip = "", support.clearCloneStyle = "content-box" === div.style.backgroundClip, jQuery(function () {
                var container, marginDiv, divReset = "padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box",
                    body = document.getElementsByTagName("body")[0];
                body && (container = document.createElement("div"), container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px", body.appendChild(container).appendChild(div), div.innerHTML = "", div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%", jQuery.swap(body, null != body.style.zoom ? {
                        zoom: 1
                    } : {},
                    function () {
                        support.boxSizing = 4 === div.offsetWidth
                    }), window.getComputedStyle && (support.pixelPosition = "1%" !== (window.getComputedStyle(div, null) || {}).top, support.boxSizingReliable = "4px" === (window.getComputedStyle(div, null) || {
                    width: "4px"
                }).width, marginDiv = div.appendChild(document.createElement("div")), marginDiv.style.cssText = div.style.cssText = divReset, marginDiv.style.marginRight = marginDiv.style.width = "0", div.style.width = "1px", support.reliableMarginRight = !parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight)), body.removeChild(container))
            }), support) : support
        }({});
    var data_user, data_priv, rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
        rmultiDash = /([A-Z])/g;
    Data.uid = 1,
        Data.accepts = function (owner) {
            return owner.nodeType ? 1 === owner.nodeType || 9 === owner.nodeType : !0
        },
        Data.prototype = {
            key: function (owner) {
                if (!Data.accepts(owner)) return 0;
                var descriptor = {},
                    unlock = owner[this.expando];
                if (!unlock) {
                    unlock = Data.uid++;
                    try {
                        descriptor[this.expando] = {
                                value: unlock
                            },
                            Object.defineProperties(owner, descriptor)
                    } catch (e) {
                        descriptor[this.expando] = unlock,
                            jQuery.extend(owner, descriptor)
                    }
                }
                return this.cache[unlock] || (this.cache[unlock] = {}),
                    unlock
            },
            set: function (owner, data, value) {
                var prop, unlock = this.key(owner),
                    cache = this.cache[unlock];
                if ("string" == typeof data) cache[data] = value;
                else if (jQuery.isEmptyObject(cache)) jQuery.extend(this.cache[unlock], data);
                else
                    for (prop in data) cache[prop] = data[prop];
                return cache
            },
            get: function (owner, key) {
                var cache = this.cache[this.key(owner)];
                return key === undefined ? cache : cache[key]
            },
            access: function (owner, key, value) {
                var stored;
                return key === undefined || key && "string" == typeof key && value === undefined ? (stored = this.get(owner, key), stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key))) : (this.set(owner, key, value), value !== undefined ? value : key)
            },
            remove: function (owner, key) {
                var i, name, camel, unlock = this.key(owner),
                    cache = this.cache[unlock];
                if (key === undefined) this.cache[unlock] = {};
                else {
                    jQuery.isArray(key) ? name = key.concat(key.map(jQuery.camelCase)) : (camel = jQuery.camelCase(key), key in cache ? name = [key, camel] : (name = camel, name = name in cache ? [name] : name.match(core_rnotwhite) || [])),
                        i = name.length;
                    for (; i--;) delete cache[name[i]]
                }
            },
            hasData: function (owner) {
                return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {})
            },
            discard: function (owner) {
                owner[this.expando] && delete this.cache[owner[this.expando]]
            }
        },
        data_user = new Data,
        data_priv = new Data,
        jQuery.extend({
            acceptData: Data.accepts,
            hasData: function (elem) {
                return data_user.hasData(elem) || data_priv.hasData(elem)
            },
            data: function (elem, name, data) {
                return data_user.access(elem, name, data)
            },
            removeData: function (elem, name) {
                data_user.remove(elem, name)
            },
            _data: function (elem, name, data) {
                return data_priv.access(elem, name, data)
            },
            _removeData: function (elem, name) {
                data_priv.remove(elem, name)
            }
        }),
        jQuery.fn.extend({
            data: function (key, value) {
                var attrs, name, elem = this[0],
                    i = 0,
                    data = null;
                if (key === undefined) {
                    if (this.length && (data = data_user.get(elem), 1 === elem.nodeType && !data_priv.get(elem, "hasDataAttrs"))) {
                        for (attrs = elem.attributes; i < attrs.length; i++) name = attrs[i].name,
                            0 === name.indexOf("data-") && (name = jQuery.camelCase(name.slice(5)), dataAttr(elem, name, data[name]));
                        data_priv.set(elem, "hasDataAttrs", !0)
                    }
                    return data
                }
                return "object" == typeof key ? this.each(function () {
                    data_user.set(this, key)
                }) : jQuery.access(this,
                    function (value) {
                        var data, camelKey = jQuery.camelCase(key);
                        if (elem && value === undefined) {
                            if (data = data_user.get(elem, key), data !== undefined) return data;
                            if (data = data_user.get(elem, camelKey), data !== undefined) return data;
                            if (data = dataAttr(elem, camelKey, undefined), data !== undefined) return data
                        } else this.each(function () {
                            var data = data_user.get(this, camelKey);
                            data_user.set(this, camelKey, value), -1 !== key.indexOf("-") && data !== undefined && data_user.set(this, key, value)
                        })
                    },
                    null, value, arguments.length > 1, null, !0)
            },
            removeData: function (key) {
                return this.each(function () {
                    data_user.remove(this, key)
                })
            }
        }),
        jQuery.extend({
            queue: function (elem, type, data) {
                var queue;
                return elem ? (type = (type || "fx") + "queue", queue = data_priv.get(elem, type), data && (!queue || jQuery.isArray(data) ? queue = data_priv.access(elem, type, jQuery.makeArray(data)) : queue.push(data)), queue || []) : void 0
            },
            dequeue: function (elem, type) {
                type = type || "fx";
                var queue = jQuery.queue(elem, type),
                    startLength = queue.length,
                    fn = queue.shift(),
                    hooks = jQuery._queueHooks(elem, type),
                    next = function () {
                        jQuery.dequeue(elem, type)
                    };
                "inprogress" === fn && (fn = queue.shift(), startLength--),
                    fn && ("fx" === type && queue.unshift("inprogress"), delete hooks.stop, fn.call(elem, next, hooks)), !startLength && hooks && hooks.empty.fire()
            },
            _queueHooks: function (elem, type) {
                var key = type + "queueHooks";
                return data_priv.get(elem, key) || data_priv.access(elem, key, {
                    empty: jQuery.Callbacks("once memory").add(function () {
                        data_priv.remove(elem, [type + "queue", key])
                    })
                })
            }
        }),
        jQuery.fn.extend({
            queue: function (type, data) {
                var setter = 2;
                return "string" != typeof type && (data = type, type = "fx", setter--),
                    arguments.length < setter ? jQuery.queue(this[0], type) : data === undefined ? this : this.each(function () {
                        var queue = jQuery.queue(this, type, data);
                        jQuery._queueHooks(this, type),
                            "fx" === type && "inprogress" !== queue[0] && jQuery.dequeue(this, type)
                    })
            },
            dequeue: function (type) {
                return this.each(function () {
                    jQuery.dequeue(this, type)
                })
            },
            delay: function (time, type) {
                return time = jQuery.fx ? jQuery.fx.speeds[time] || time : time,
                    type = type || "fx",
                    this.queue(type,
                        function (next, hooks) {
                            var timeout = setTimeout(next, time);
                            hooks.stop = function () {
                                clearTimeout(timeout)
                            }
                        })
            },
            clearQueue: function (type) {
                return this.queue(type || "fx", [])
            },
            promise: function (type, obj) {
                var tmp, count = 1,
                    defer = jQuery.Deferred(),
                    elements = this,
                    i = this.length,
                    resolve = function () {
                        --count || defer.resolveWith(elements, [elements])
                    };
                for ("string" != typeof type && (obj = type, type = undefined), type = type || "fx"; i--;) tmp = data_priv.get(elements[i], type + "queueHooks"),
                    tmp && tmp.empty && (count++, tmp.empty.add(resolve));
                return resolve(),
                    defer.promise(obj)
            }
        });
    var nodeHook, boolHook, rclass = /[\t\r\n\f]/g,
        rreturn = /\r/g,
        rfocusable = /^(?:input|select|textarea|button)$/i;
    jQuery.fn.extend({
            attr: function (name, value) {
                return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1)
            },
            removeAttr: function (name) {
                return this.each(function () {
                    jQuery.removeAttr(this, name)
                })
            },
            prop: function (name, value) {
                return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1)
            },
            removeProp: function (name) {
                return this.each(function () {
                    delete this[jQuery.propFix[name] || name]
                })
            },
            addClass: function (value) {
                var classes, elem, cur, clazz, j, i = 0,
                    len = this.length,
                    proceed = "string" == typeof value && value;
                if (jQuery.isFunction(value)) return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, this.className))
                });
                if (proceed)
                    for (classes = (value || "").match(core_rnotwhite) || []; len > i; i++)
                        if (elem = this[i], cur = 1 === elem.nodeType && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ")) {
                            for (j = 0; clazz = classes[j++];) cur.indexOf(" " + clazz + " ") < 0 && (cur += clazz + " ");
                            elem.className = jQuery.trim(cur)
                        }
                return this
            },
            removeClass: function (value) {
                var classes, elem, cur, clazz, j, i = 0,
                    len = this.length,
                    proceed = 0 === arguments.length || "string" == typeof value && value;
                if (jQuery.isFunction(value)) return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, this.className))
                });
                if (proceed)
                    for (classes = (value || "").match(core_rnotwhite) || []; len > i; i++)
                        if (elem = this[i], cur = 1 === elem.nodeType && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "")) {
                            for (j = 0; clazz = classes[j++];)
                                for (; cur.indexOf(" " + clazz + " ") >= 0;) cur = cur.replace(" " + clazz + " ", " ");
                            elem.className = value ? jQuery.trim(cur) : ""
                        }
                return this
            },
            toggleClass: function (value, stateVal) {
                var type = typeof value;
                return "boolean" == typeof stateVal && "string" === type ? stateVal ? this.addClass(value) : this.removeClass(value) : this.each(jQuery.isFunction(value) ?
                    function (i) {
                        jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal)
                    } : function () {
                        if ("string" === type)
                            for (var className, i = 0,
                                    self = jQuery(this), classNames = value.match(core_rnotwhite) || []; className = classNames[i++];) self.hasClass(className) ? self.removeClass(className) : self.addClass(className);
                        else(type === core_strundefined || "boolean" === type) && (this.className && data_priv.set(this, "__className__", this.className), this.className = this.className || value === !1 ? "" : data_priv.get(this, "__className__") || "")
                    })
            },
            hasClass: function (selector) {
                for (var className = " " + selector + " ",
                        i = 0,
                        l = this.length; l > i; i++)
                    if (1 === this[i].nodeType && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) return !0;
                return !1
            },
            val: function (value) {
                var hooks, ret, isFunction, elem = this[0]; {
                    if (arguments.length) return isFunction = jQuery.isFunction(value),
                        this.each(function (i) {
                            var val;
                            1 === this.nodeType && (val = isFunction ? value.call(this, i, jQuery(this).val()) : value, null == val ? val = "" : "number" == typeof val ? val += "" : jQuery.isArray(val) && (val = jQuery.map(val,
                                function (value) {
                                    return null == value ? "" : value + ""
                                })), hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()], hooks && "set" in hooks && hooks.set(this, val, "value") !== undefined || (this.value = val))
                        });
                    if (elem) return hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()],
                        hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined ? ret : (ret = elem.value, "string" == typeof ret ? ret.replace(rreturn, "") : null == ret ? "" : ret)
                }
            }
        }),
        jQuery.extend({
            valHooks: {
                option: {
                    get: function (elem) {
                        var val = elem.attributes.value;
                        return !val || val.specified ? elem.value : elem.text
                    }
                },
                select: {
                    get: function (elem) {
                        for (var value, option, options = elem.options,
                                index = elem.selectedIndex,
                                one = "select-one" === elem.type || 0 > index,
                                values = one ? null : [], max = one ? index + 1 : options.length, i = 0 > index ? max : one ? index : 0; max > i; i++)
                            if (option = options[i], !(!option.selected && i !== index || (jQuery.support.optDisabled ? option.disabled : null !== option.getAttribute("disabled")) || option.parentNode.disabled && jQuery.nodeName(option.parentNode, "optgroup"))) {
                                if (value = jQuery(option).val(), one) return value;
                                values.push(value)
                            }
                        return values
                    },
                    set: function (elem, value) {
                        for (var optionSet, option, options = elem.options,
                                values = jQuery.makeArray(value), i = options.length; i--;) option = options[i],
                            (option.selected = jQuery.inArray(jQuery(option).val(), values) >= 0) && (optionSet = !0);
                        return optionSet || (elem.selectedIndex = -1),
                            values
                    }
                }
            },
            attr: function (elem, name, value) {
                var hooks, ret, nType = elem.nodeType;
                if (elem && 3 !== nType && 8 !== nType && 2 !== nType) return typeof elem.getAttribute === core_strundefined ? jQuery.prop(elem, name, value) : (1 === nType && jQuery.isXMLDoc(elem) || (name = name.toLowerCase(), hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook)), value === undefined ? hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : (ret = jQuery.find.attr(elem, name), null == ret ? undefined : ret) : null !== value ? hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : (elem.setAttribute(name, value + ""), value) : void jQuery.removeAttr(elem, name))
            },
            removeAttr: function (elem, value) {
                var name, propName, i = 0,
                    attrNames = value && value.match(core_rnotwhite);
                if (attrNames && 1 === elem.nodeType)
                    for (; name = attrNames[i++];) propName = jQuery.propFix[name] || name,
                        jQuery.expr.match.bool.test(name) && (elem[propName] = !1),
                        elem.removeAttribute(name)
            },
            attrHooks: {
                type: {
                    set: function (elem, value) {
                        if (!jQuery.support.radioValue && "radio" === value && jQuery.nodeName(elem, "input")) {
                            var val = elem.value;
                            return elem.setAttribute("type", value),
                                val && (elem.value = val),
                                value
                        }
                    }
                }
            },
            propFix: {
                "for": "htmlFor",
                "class": "className"
            },
            prop: function (elem, name, value) {
                var ret, hooks, notxml, nType = elem.nodeType;
                if (elem && 3 !== nType && 8 !== nType && 2 !== nType) return notxml = 1 !== nType || !jQuery.isXMLDoc(elem),
                    notxml && (name = jQuery.propFix[name] || name, hooks = jQuery.propHooks[name]),
                    value !== undefined ? hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value : hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : elem[name]
            },
            propHooks: {
                tabIndex: {
                    get: function (elem) {
                        return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1
                    }
                }
            }
        }),
        boolHook = {
            set: function (elem, value, name) {
                return value === !1 ? jQuery.removeAttr(elem, name) : elem.setAttribute(name, name),
                    name
            }
        },
        jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g),
            function (i, name) {
                var getter = jQuery.expr.attrHandle[name] || jQuery.find.attr;
                jQuery.expr.attrHandle[name] = function (elem, name, isXML) {
                    var fn = jQuery.expr.attrHandle[name],
                        ret = isXML ? undefined : (jQuery.expr.attrHandle[name] = undefined) != getter(elem, name, isXML) ? name.toLowerCase() : null;
                    return jQuery.expr.attrHandle[name] = fn,
                        ret
                }
            }),
        jQuery.support.optSelected || (jQuery.propHooks.selected = {
            get: function (elem) {
                var parent = elem.parentNode;
                return parent && parent.parentNode && parent.parentNode.selectedIndex,
                    null
            }
        }),
        jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"],
            function () {
                jQuery.propFix[this.toLowerCase()] = this
            }),
        jQuery.each(["radio", "checkbox"],
            function () {
                jQuery.valHooks[this] = {
                        set: function (elem, value) {
                            return jQuery.isArray(value) ? elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0 : void 0
                        }
                    },
                    jQuery.support.checkOn || (jQuery.valHooks[this].get = function (elem) {
                        return null === elem.getAttribute("value") ? "on" : elem.value
                    })
            });
    var rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|contextmenu)|click/,
        rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
        rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
    jQuery.event = {
            global: {},
            add: function (elem, types, handler, data, selector) {
                var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
                if (elemData) {
                    for (handler.handler && (handleObjIn = handler, handler = handleObjIn.handler, selector = handleObjIn.selector), handler.guid || (handler.guid = jQuery.guid++), (events = elemData.events) || (events = elemData.events = {}), (eventHandle = elemData.handle) || (eventHandle = elemData.handle = function (e) {
                                return typeof jQuery === core_strundefined || e && jQuery.event.triggered === e.type ? undefined : jQuery.event.dispatch.apply(eventHandle.elem, arguments)
                            },
                            eventHandle.elem = elem), types = (types || "").match(core_rnotwhite) || [""], t = types.length; t--;) tmp = rtypenamespace.exec(types[t]) || [],
                        type = origType = tmp[1],
                        namespaces = (tmp[2] || "").split(".").sort(),
                        type && (special = jQuery.event.special[type] || {},
                            type = (selector ? special.delegateType : special.bindType) || type, special = jQuery.event.special[type] || {},
                            handleObj = jQuery.extend({
                                    type: type,
                                    origType: origType,
                                    data: data,
                                    handler: handler,
                                    guid: handler.guid,
                                    selector: selector,
                                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                                    namespace: namespaces.join(".")
                                },
                                handleObjIn), (handlers = events[type]) || (handlers = events[type] = [], handlers.delegateCount = 0, special.setup && special.setup.call(elem, data, namespaces, eventHandle) !== !1 || elem.addEventListener && elem.addEventListener(type, eventHandle, !1)), special.add && (special.add.call(elem, handleObj), handleObj.handler.guid || (handleObj.handler.guid = handler.guid)), selector ? handlers.splice(handlers.delegateCount++, 0, handleObj) : handlers.push(handleObj), jQuery.event.global[type] = !0);
                    elem = null
                }
            },
            remove: function (elem, types, handler, selector, mappedTypes) {
                var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
                if (elemData && (events = elemData.events)) {
                    for (types = (types || "").match(core_rnotwhite) || [""], t = types.length; t--;)
                        if (tmp = rtypenamespace.exec(types[t]) || [], type = origType = tmp[1], namespaces = (tmp[2] || "").split(".").sort(), type) {
                            for (special = jQuery.event.special[type] || {},
                                type = (selector ? special.delegateType : special.bindType) || type, handlers = events[type] || [], tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"), origCount = j = handlers.length; j--;) handleObj = handlers[j], !mappedTypes && origType !== handleObj.origType || handler && handler.guid !== handleObj.guid || tmp && !tmp.test(handleObj.namespace) || selector && selector !== handleObj.selector && ("**" !== selector || !handleObj.selector) || (handlers.splice(j, 1), handleObj.selector && handlers.delegateCount--, special.remove && special.remove.call(elem, handleObj));
                            origCount && !handlers.length && (special.teardown && special.teardown.call(elem, namespaces, elemData.handle) !== !1 || jQuery.removeEvent(elem, type, elemData.handle), delete events[type])
                        } else
                            for (type in events) jQuery.event.remove(elem, type + types[t], handler, selector, !0);
                    jQuery.isEmptyObject(events) && (delete elemData.handle, data_priv.remove(elem, "events"))
                }
            },
            trigger: function (event, data, elem, onlyHandlers) {
                var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document],
                    type = core_hasOwn.call(event, "type") ? event.type : event,
                    namespaces = core_hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
                if (cur = tmp = elem = elem || document, 3 !== elem.nodeType && 8 !== elem.nodeType && !rfocusMorph.test(type + jQuery.event.triggered) && (type.indexOf(".") >= 0 && (namespaces = type.split("."), type = namespaces.shift(), namespaces.sort()), ontype = type.indexOf(":") < 0 && "on" + type, event = event[jQuery.expando] ? event : new jQuery.Event(type, "object" == typeof event && event), event.isTrigger = onlyHandlers ? 2 : 3, event.namespace = namespaces.join("."), event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, event.result = undefined, event.target || (event.target = elem), data = null == data ? [event] : jQuery.makeArray(data, [event]), special = jQuery.event.special[type] || {},
                        onlyHandlers || !special.trigger || special.trigger.apply(elem, data) !== !1)) {
                    if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                        for (bubbleType = special.delegateType || type, rfocusMorph.test(bubbleType + type) || (cur = cur.parentNode); cur; cur = cur.parentNode) eventPath.push(cur),
                            tmp = cur;
                        tmp === (elem.ownerDocument || document) && eventPath.push(tmp.defaultView || tmp.parentWindow || window)
                    }
                    for (i = 0;
                        (cur = eventPath[i++]) && !event.isPropagationStopped();) event.type = i > 1 ? bubbleType : special.bindType || type,
                        handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle"),
                        handle && handle.apply(cur, data),
                        handle = ontype && cur[ontype],
                        handle && jQuery.acceptData(cur) && handle.apply && handle.apply(cur, data) === !1 && event.preventDefault();
                    return event.type = type,
                        onlyHandlers || event.isDefaultPrevented() || special._default && special._default.apply(eventPath.pop(), data) !== !1 || !jQuery.acceptData(elem) || ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem) && (tmp = elem[ontype], tmp && (elem[ontype] = null), jQuery.event.triggered = type, elem[type](), jQuery.event.triggered = undefined, tmp && (elem[ontype] = tmp)),
                        event.result
                }
            },
            dispatch: function (event) {
                event = jQuery.event.fix(event);
                var i, j, ret, matched, handleObj, handlerQueue = [],
                    args = core_slice.call(arguments),
                    handlers = (data_priv.get(this, "events") || {})[event.type] || [],
                    special = jQuery.event.special[event.type] || {};
                if (args[0] = event, event.delegateTarget = this, !special.preDispatch || special.preDispatch.call(this, event) !== !1) {
                    for (handlerQueue = jQuery.event.handlers.call(this, event, handlers), i = 0;
                        (matched = handlerQueue[i++]) && !event.isPropagationStopped();)
                        for (event.currentTarget = matched.elem, j = 0;
                            (handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped();)(!event.namespace_re || event.namespace_re.test(handleObj.namespace)) && (event.handleObj = handleObj, event.data = handleObj.data, ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args), ret !== undefined && (event.result = ret) === !1 && (event.preventDefault(), event.stopPropagation()));
                    return special.postDispatch && special.postDispatch.call(this, event),
                        event.result
                }
            },
            handlers: function (event, handlers) {
                var i, matches, sel, handleObj, handlerQueue = [],
                    delegateCount = handlers.delegateCount,
                    cur = event.target;
                if (delegateCount && cur.nodeType && (!event.button || "click" !== event.type))
                    for (; cur !== this; cur = cur.parentNode || this)
                        if (cur.disabled !== !0 || "click" !== event.type) {
                            for (matches = [], i = 0; delegateCount > i; i++) handleObj = handlers[i],
                                sel = handleObj.selector + " ",
                                matches[sel] === undefined && (matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length),
                                matches[sel] && matches.push(handleObj);
                            matches.length && handlerQueue.push({
                                elem: cur,
                                handlers: matches
                            })
                        }
                return delegateCount < handlers.length && handlerQueue.push({
                        elem: this,
                        handlers: handlers.slice(delegateCount)
                    }),
                    handlerQueue
            },
            props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
            fixHooks: {},
            keyHooks: {
                props: "char charCode key keyCode".split(" "),
                filter: function (event, original) {
                    return null == event.which && (event.which = null != original.charCode ? original.charCode : original.keyCode),
                        event
                }
            },
            mouseHooks: {
                props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
                filter: function (event, original) {
                    var eventDoc, doc, body, button = original.button;
                    return null == event.pageX && null != original.clientX && (eventDoc = event.target.ownerDocument || document, doc = eventDoc.documentElement, body = eventDoc.body, event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0), event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0)),
                        event.which || button === undefined || (event.which = 1 & button ? 1 : 2 & button ? 3 : 4 & button ? 2 : 0),
                        event
                }
            },
            fix: function (event) {
                if (event[jQuery.expando]) return event;
                var i, prop, copy, type = event.type,
                    originalEvent = event,
                    fixHook = this.fixHooks[type];
                for (fixHook || (this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {}), copy = fixHook.props ? this.props.concat(fixHook.props) : this.props, event = new jQuery.Event(originalEvent), i = copy.length; i--;) prop = copy[i],
                    event[prop] = originalEvent[prop];
                return event.target || (event.target = document),
                    3 === event.target.nodeType && (event.target = event.target.parentNode),
                    fixHook.filter ? fixHook.filter(event, originalEvent) : event
            },
            special: {
                load: {
                    noBubble: !0
                },
                focus: {
                    trigger: function () {
                        return this !== safeActiveElement() && this.focus ? (this.focus(), !1) : void 0
                    },
                    delegateType: "focusin"
                },
                blur: {
                    trigger: function () {
                        return this === safeActiveElement() && this.blur ? (this.blur(), !1) : void 0
                    },
                    delegateType: "focusout"
                },
                click: {
                    trigger: function () {
                        return "checkbox" === this.type && this.click && jQuery.nodeName(this, "input") ? (this.click(), !1) : void 0
                    },
                    _default: function (event) {
                        return jQuery.nodeName(event.target, "a")
                    }
                },
                beforeunload: {
                    postDispatch: function (event) {
                        event.result !== undefined && (event.originalEvent.returnValue = event.result)
                    }
                }
            },
            simulate: function (type, elem, event, bubble) {
                var e = jQuery.extend(new jQuery.Event, event, {
                    type: type,
                    isSimulated: !0,
                    originalEvent: {}
                });
                bubble ? jQuery.event.trigger(e, null, elem) : jQuery.event.dispatch.call(elem, e),
                    e.isDefaultPrevented() && event.preventDefault()
            }
        },
        jQuery.removeEvent = function (elem, type, handle) {
            elem.removeEventListener && elem.removeEventListener(type, handle, !1)
        },
        jQuery.Event = function (src, props) {
            return this instanceof jQuery.Event ? (src && src.type ? (this.originalEvent = src, this.type = src.type, this.isDefaultPrevented = src.defaultPrevented || src.getPreventDefault && src.getPreventDefault() ? returnTrue : returnFalse) : this.type = src, props && jQuery.extend(this, props), this.timeStamp = src && src.timeStamp || jQuery.now(), void(this[jQuery.expando] = !0)) : new jQuery.Event(src, props)
        },
        jQuery.Event.prototype = {
            isDefaultPrevented: returnFalse,
            isPropagationStopped: returnFalse,
            isImmediatePropagationStopped: returnFalse,
            preventDefault: function () {
                var e = this.originalEvent;
                this.isDefaultPrevented = returnTrue,
                    e && e.preventDefault && e.preventDefault()
            },
            stopPropagation: function () {
                var e = this.originalEvent;
                this.isPropagationStopped = returnTrue,
                    e && e.stopPropagation && e.stopPropagation()
            },
            stopImmediatePropagation: function () {
                this.isImmediatePropagationStopped = returnTrue,
                    this.stopPropagation()
            }
        },
        jQuery.each({
                mouseenter: "mouseover",
                mouseleave: "mouseout"
            },
            function (orig, fix) {
                jQuery.event.special[orig] = {
                    delegateType: fix,
                    bindType: fix,
                    handle: function (event) {
                        var ret, target = this,
                            related = event.relatedTarget,
                            handleObj = event.handleObj;
                        return (!related || related !== target && !jQuery.contains(target, related)) && (event.type = handleObj.origType, ret = handleObj.handler.apply(this, arguments), event.type = fix),
                            ret
                    }
                }
            }),
        jQuery.support.focusinBubbles || jQuery.each({
                focus: "focusin",
                blur: "focusout"
            },
            function (orig, fix) {
                var attaches = 0,
                    handler = function (event) {
                        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), !0)
                    };
                jQuery.event.special[fix] = {
                    setup: function () {
                        0 === attaches++ && document.addEventListener(orig, handler, !0)
                    },
                    teardown: function () {
                        0 === --attaches && document.removeEventListener(orig, handler, !0)
                    }
                }
            }),
        jQuery.fn.extend({
            on: function (types, selector, data, fn, one) {
                var origFn, type;
                if ("object" == typeof types) {
                    "string" != typeof selector && (data = data || selector, selector = undefined);
                    for (type in types) this.on(type, selector, data, types[type], one);
                    return this
                }
                if (null == data && null == fn ? (fn = selector, data = selector = undefined) : null == fn && ("string" == typeof selector ? (fn = data, data = undefined) : (fn = data, data = selector, selector = undefined)), fn === !1) fn = returnFalse;
                else if (!fn) return this;
                return 1 === one && (origFn = fn, fn = function (event) {
                            return jQuery().off(event),
                                origFn.apply(this, arguments)
                        },
                        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)),
                    this.each(function () {
                        jQuery.event.add(this, types, fn, data, selector)
                    })
            },
            one: function (types, selector, data, fn) {
                return this.on(types, selector, data, fn, 1)
            },
            off: function (types, selector, fn) {
                var handleObj, type;
                if (types && types.preventDefault && types.handleObj) return handleObj = types.handleObj,
                    jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler),
                    this;
                if ("object" == typeof types) {
                    for (type in types) this.off(type, selector, types[type]);
                    return this
                }
                return (selector === !1 || "function" == typeof selector) && (fn = selector, selector = undefined),
                    fn === !1 && (fn = returnFalse),
                    this.each(function () {
                        jQuery.event.remove(this, types, fn, selector)
                    })
            },
            trigger: function (type, data) {
                return this.each(function () {
                    jQuery.event.trigger(type, data, this)
                })
            },
            triggerHandler: function (type, data) {
                var elem = this[0];
                return elem ? jQuery.event.trigger(type, data, elem, !0) : void 0
            }
        });
    var isSimple = /^.[^:#\[\.,]*$/,
        rparentsprev = /^(?:parents|prev(?:Until|All))/,
        rneedsContext = jQuery.expr.match.needsContext,
        guaranteedUnique = {
            children: !0,
            contents: !0,
            next: !0,
            prev: !0
        };
    jQuery.fn.extend({
            find: function (selector) {
                var i, ret = [],
                    self = this,
                    len = self.length;
                if ("string" != typeof selector) return this.pushStack(jQuery(selector).filter(function () {
                    for (i = 0; len > i; i++)
                        if (jQuery.contains(self[i], this)) return !0
                }));
                for (i = 0; len > i; i++) jQuery.find(selector, self[i], ret);
                return ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret),
                    ret.selector = this.selector ? this.selector + " " + selector : selector,
                    ret
            },
            has: function (target) {
                var targets = jQuery(target, this),
                    l = targets.length;
                return this.filter(function () {
                    for (var i = 0; l > i; i++)
                        if (jQuery.contains(this, targets[i])) return !0
                })
            },
            not: function (selector) {
                return this.pushStack(winnow(this, selector || [], !0))
            },
            filter: function (selector) {
                return this.pushStack(winnow(this, selector || [], !1))
            },
            is: function (selector) {
                return !!winnow(this, "string" == typeof selector && rneedsContext.test(selector) ? jQuery(selector) : selector || [], !1).length
            },
            closest: function (selectors, context) {
                for (var cur, i = 0,
                        l = this.length,
                        matched = [], pos = rneedsContext.test(selectors) || "string" != typeof selectors ? jQuery(selectors, context || this.context) : 0; l > i; i++)
                    for (cur = this[i]; cur && cur !== context; cur = cur.parentNode)
                        if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : 1 === cur.nodeType && jQuery.find.matchesSelector(cur, selectors))) {
                            cur = matched.push(cur);
                            break
                        }
                return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched)
            },
            index: function (elem) {
                return elem ? "string" == typeof elem ? core_indexOf.call(jQuery(elem), this[0]) : core_indexOf.call(this, elem.jquery ? elem[0] : elem) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
            },
            add: function (selector, context) {
                var set = "string" == typeof selector ? jQuery(selector, context) : jQuery.makeArray(selector && selector.nodeType ? [selector] : selector),
                    all = jQuery.merge(this.get(), set);
                return this.pushStack(jQuery.unique(all))
            },
            addBack: function (selector) {
                return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector))
            }
        }),
        jQuery.each({
                parent: function (elem) {
                    var parent = elem.parentNode;
                    return parent && 11 !== parent.nodeType ? parent : null
                },
                parents: function (elem) {
                    return jQuery.dir(elem, "parentNode")
                },
                parentsUntil: function (elem, i, until) {
                    return jQuery.dir(elem, "parentNode", until)
                },
                next: function (elem) {
                    return sibling(elem, "nextSibling")
                },
                prev: function (elem) {
                    return sibling(elem, "previousSibling")
                },
                nextAll: function (elem) {
                    return jQuery.dir(elem, "nextSibling")
                },
                prevAll: function (elem) {
                    return jQuery.dir(elem, "previousSibling")
                },
                nextUntil: function (elem, i, until) {
                    return jQuery.dir(elem, "nextSibling", until)
                },
                prevUntil: function (elem, i, until) {
                    return jQuery.dir(elem, "previousSibling", until)
                },
                siblings: function (elem) {
                    return jQuery.sibling((elem.parentNode || {}).firstChild, elem)
                },
                children: function (elem) {
                    return jQuery.sibling(elem.firstChild)
                },
                contents: function (elem) {
                    return elem.contentDocument || jQuery.merge([], elem.childNodes)
                }
            },
            function (name, fn) {
                jQuery.fn[name] = function (until, selector) {
                    var matched = jQuery.map(this, fn, until);
                    return "Until" !== name.slice(-5) && (selector = until),
                        selector && "string" == typeof selector && (matched = jQuery.filter(selector, matched)),
                        this.length > 1 && (guaranteedUnique[name] || jQuery.unique(matched), rparentsprev.test(name) && matched.reverse()),
                        this.pushStack(matched)
                }
            }),
        jQuery.extend({
            filter: function (expr, elems, not) {
                var elem = elems[0];
                return not && (expr = ":not(" + expr + ")"),
                    1 === elems.length && 1 === elem.nodeType ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems,
                        function (elem) {
                            return 1 === elem.nodeType
                        }))
            },
            dir: function (elem, dir, until) {
                for (var matched = [], truncate = until !== undefined;
                    (elem = elem[dir]) && 9 !== elem.nodeType;)
                    if (1 === elem.nodeType) {
                        if (truncate && jQuery(elem).is(until)) break;
                        matched.push(elem)
                    }
                return matched
            },
            sibling: function (n, elem) {
                for (var matched = []; n; n = n.nextSibling) 1 === n.nodeType && n !== elem && matched.push(n);
                return matched
            }
        });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
        rtagName = /<([\w:]+)/,
        rhtml = /<|&#?\w+;/,
        rnoInnerhtml = /<(?:script|style|link)/i,
        manipulation_rcheckableType = /^(?:checkbox|radio)$/i,
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rscriptType = /^$|\/(?:java|ecma)script/i,
        rscriptTypeMasked = /^true\/(.*)/,
        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
        wrapMap = {
            option: [1, "<select multiple='multiple'>", "</select>"],
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""]
        };
    wrapMap.optgroup = wrapMap.option,
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead,
        wrapMap.th = wrapMap.td,
        jQuery.fn.extend({
            text: function (value) {
                return jQuery.access(this,
                    function (value) {
                        return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value))
                    },
                    null, value, arguments.length)
            },
            append: function () {
                return this.domManip(arguments,
                    function (elem) {
                        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                            var target = manipulationTarget(this, elem);
                            target.appendChild(elem)
                        }
                    })
            },
            prepend: function () {
                return this.domManip(arguments,
                    function (elem) {
                        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                            var target = manipulationTarget(this, elem);
                            target.insertBefore(elem, target.firstChild)
                        }
                    })
            },
            before: function () {
                return this.domManip(arguments,
                    function (elem) {
                        this.parentNode && this.parentNode.insertBefore(elem, this)
                    })
            },
            after: function () {
                return this.domManip(arguments,
                    function (elem) {
                        this.parentNode && this.parentNode.insertBefore(elem, this.nextSibling)
                    })
            },
            remove: function (selector, keepData) {
                for (var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0; null != (elem = elems[i]); i++) keepData || 1 !== elem.nodeType || jQuery.cleanData(getAll(elem)),
                    elem.parentNode && (keepData && jQuery.contains(elem.ownerDocument, elem) && setGlobalEval(getAll(elem, "script")), elem.parentNode.removeChild(elem));
                return this
            },
            empty: function () {
                for (var elem, i = 0; null != (elem = this[i]); i++) 1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)), elem.textContent = "");
                return this
            },
            clone: function (dataAndEvents, deepDataAndEvents) {
                return dataAndEvents = null == dataAndEvents ? !1 : dataAndEvents,
                    deepDataAndEvents = null == deepDataAndEvents ? dataAndEvents : deepDataAndEvents,
                    this.map(function () {
                        return jQuery.clone(this, dataAndEvents, deepDataAndEvents)
                    })
            },
            html: function (value) {
                return jQuery.access(this,
                    function (value) {
                        var elem = this[0] || {},
                            i = 0,
                            l = this.length;
                        if (value === undefined && 1 === elem.nodeType) return elem.innerHTML;
                        if ("string" == typeof value && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
                            value = value.replace(rxhtmlTag, "<$1></$2>");
                            try {
                                for (; l > i; i++) elem = this[i] || {},
                                    1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)), elem.innerHTML = value);
                                elem = 0
                            } catch (e) {}
                        }
                        elem && this.empty().append(value)
                    },
                    null, value, arguments.length)
            },
            replaceWith: function () {
                var args = jQuery.map(this,
                        function (elem) {
                            return [elem.nextSibling, elem.parentNode]
                        }),
                    i = 0;
                return this.domManip(arguments,
                        function (elem) {
                            var next = args[i++],
                                parent = args[i++];
                            parent && (next && next.parentNode !== parent && (next = this.nextSibling), jQuery(this).remove(), parent.insertBefore(elem, next))
                        }, !0),
                    i ? this : this.remove()
            },
            detach: function (selector) {
                return this.remove(selector, !0)
            },
            domManip: function (args, callback, allowIntersection) {
                args = core_concat.apply([], args);
                var fragment, first, scripts, hasScripts, node, doc, i = 0,
                    l = this.length,
                    set = this,
                    iNoClone = l - 1,
                    value = args[0],
                    isFunction = jQuery.isFunction(value);
                if (isFunction || !(1 >= l || "string" != typeof value || jQuery.support.checkClone) && rchecked.test(value)) return this.each(function (index) {
                    var self = set.eq(index);
                    isFunction && (args[0] = value.call(this, index, self.html())),
                        self.domManip(args, callback, allowIntersection)
                });
                if (l && (fragment = jQuery.buildFragment(args, this[0].ownerDocument, !1, !allowIntersection && this), first = fragment.firstChild, 1 === fragment.childNodes.length && (fragment = first), first)) {
                    for (scripts = jQuery.map(getAll(fragment, "script"), disableScript), hasScripts = scripts.length; l > i; i++) node = fragment,
                        i !== iNoClone && (node = jQuery.clone(node, !0, !0), hasScripts && jQuery.merge(scripts, getAll(node, "script"))),
                        callback.call(this[i], node, i);
                    if (hasScripts)
                        for (doc = scripts[scripts.length - 1].ownerDocument, jQuery.map(scripts, restoreScript), i = 0; hasScripts > i; i++) node = scripts[i],
                            rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node) && (node.src ? jQuery._evalUrl(node.src) : jQuery.globalEval(node.textContent.replace(rcleanScript, "")))
                }
                return this
            }
        }),
        jQuery.each({
                appendTo: "append",
                prependTo: "prepend",
                insertBefore: "before",
                insertAfter: "after",
                replaceAll: "replaceWith"
            },
            function (name, original) {
                jQuery.fn[name] = function (selector) {
                    for (var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0; last >= i; i++) elems = i === last ? this : this.clone(!0),
                        jQuery(insert[i])[original](elems),
                        core_push.apply(ret, elems.get());
                    return this.pushStack(ret)
                }
            }),
        jQuery.extend({
            clone: function (elem, dataAndEvents, deepDataAndEvents) {
                var i, l, srcElements, destElements, clone = elem.cloneNode(!0),
                    inPage = jQuery.contains(elem.ownerDocument, elem);
                if (!(jQuery.support.noCloneChecked || 1 !== elem.nodeType && 11 !== elem.nodeType || jQuery.isXMLDoc(elem)))
                    for (destElements = getAll(clone), srcElements = getAll(elem), i = 0, l = srcElements.length; l > i; i++) fixInput(srcElements[i], destElements[i]);
                if (dataAndEvents)
                    if (deepDataAndEvents)
                        for (srcElements = srcElements || getAll(elem), destElements = destElements || getAll(clone), i = 0, l = srcElements.length; l > i; i++) cloneCopyEvent(srcElements[i], destElements[i]);
                    else cloneCopyEvent(elem, clone);
                return destElements = getAll(clone, "script"),
                    destElements.length > 0 && setGlobalEval(destElements, !inPage && getAll(elem, "script")),
                    clone
            },
            buildFragment: function (elems, context, scripts, selection) {
                for (var elem, tmp, tag, wrap, contains, j, i = 0,
                        l = elems.length,
                        fragment = context.createDocumentFragment(), nodes = []; l > i; i++)
                    if (elem = elems[i], elem || 0 === elem)
                        if ("object" === jQuery.type(elem)) jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                        else if (rhtml.test(elem)) {
                    for (tmp = tmp || fragment.appendChild(context.createElement("div")), tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase(), wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2], j = wrap[0]; j--;) tmp = tmp.lastChild;
                    jQuery.merge(nodes, tmp.childNodes),
                        tmp = fragment.firstChild,
                        tmp.textContent = ""
                } else nodes.push(context.createTextNode(elem));
                for (fragment.textContent = "", i = 0; elem = nodes[i++];)
                    if ((!selection || -1 === jQuery.inArray(elem, selection)) && (contains = jQuery.contains(elem.ownerDocument, elem), tmp = getAll(fragment.appendChild(elem), "script"), contains && setGlobalEval(tmp), scripts))
                        for (j = 0; elem = tmp[j++];) rscriptType.test(elem.type || "") && scripts.push(elem);
                return fragment
            },
            cleanData: function (elems) {
                for (var data, elem, events, type, key, j, special = jQuery.event.special,
                        i = 0;
                    (elem = elems[i]) !== undefined; i++) {
                    if (Data.accepts(elem) && (key = elem[data_priv.expando], key && (data = data_priv.cache[key]))) {
                        if (events = Object.keys(data.events || {}), events.length)
                            for (j = 0;
                                (type = events[j]) !== undefined; j++) special[type] ? jQuery.event.remove(elem, type) : jQuery.removeEvent(elem, type, data.handle);
                        data_priv.cache[key] && delete data_priv.cache[key]
                    }
                    delete data_user.cache[elem[data_user.expando]]
                }
            },
            _evalUrl: function (url) {
                return jQuery.ajax({
                    url: url,
                    type: "GET",
                    dataType: "script",
                    async: !1,
                    global: !1,
                    "throws": !0
                })
            }
        }),
        jQuery.fn.extend({
            wrapAll: function (html) {
                var wrap;
                return jQuery.isFunction(html) ? this.each(function (i) {
                    jQuery(this).wrapAll(html.call(this, i))
                }) : (this[0] && (wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && wrap.insertBefore(this[0]), wrap.map(function () {
                    for (var elem = this; elem.firstElementChild;) elem = elem.firstElementChild;
                    return elem
                }).append(this)), this)
            },
            wrapInner: function (html) {
                return this.each(jQuery.isFunction(html) ?
                    function (i) {
                        jQuery(this).wrapInner(html.call(this, i))
                    } : function () {
                        var self = jQuery(this),
                            contents = self.contents();
                        contents.length ? contents.wrapAll(html) : self.append(html)
                    })
            },
            wrap: function (html) {
                var isFunction = jQuery.isFunction(html);
                return this.each(function (i) {
                    jQuery(this).wrapAll(isFunction ? html.call(this, i) : html)
                })
            },
            unwrap: function () {
                return this.parent().each(function () {
                    jQuery.nodeName(this, "body") || jQuery(this).replaceWith(this.childNodes)
                }).end()
            }
        });
    var curCSS, iframe, rdisplayswap = /^(none|table(?!-c[ea]).+)/,
        rmargin = /^margin/,
        rnumsplit = new RegExp("^(" + core_pnum + ")(.*)$", "i"),
        rnumnonpx = new RegExp("^(" + core_pnum + ")(?!px)[a-z%]+$", "i"),
        rrelNum = new RegExp("^([+-])=(" + core_pnum + ")", "i"),
        elemdisplay = {
            BODY: "block"
        },
        cssShow = {
            position: "absolute",
            visibility: "hidden",
            display: "block"
        },
        cssNormalTransform = {
            letterSpacing: 0,
            fontWeight: 400
        },
        cssExpand = ["Top", "Right", "Bottom", "Left"],
        cssPrefixes = ["Webkit", "O", "Moz", "ms"];
    jQuery.fn.extend({
            css: function (name, value) {
                return jQuery.access(this,
                    function (elem, name, value) {
                        var styles, len, map = {},
                            i = 0;
                        if (jQuery.isArray(name)) {
                            for (styles = getStyles(elem), len = name.length; len > i; i++) map[name[i]] = jQuery.css(elem, name[i], !1, styles);
                            return map
                        }
                        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name)
                    },
                    name, value, arguments.length > 1)
            },
            show: function () {
                return showHide(this, !0)
            },
            hide: function () {
                return showHide(this)
            },
            toggle: function (state) {
                return "boolean" == typeof state ? state ? this.show() : this.hide() : this.each(function () {
                    isHidden(this) ? jQuery(this).show() : jQuery(this).hide()
                })
            }
        }),
        jQuery.extend({
            cssHooks: {
                opacity: {
                    get: function (elem, computed) {
                        if (computed) {
                            var ret = curCSS(elem, "opacity");
                            return "" === ret ? "1" : ret
                        }
                    }
                }
            },
            cssNumber: {
                columnCount: !0,
                fillOpacity: !0,
                fontWeight: !0,
                lineHeight: !0,
                opacity: !0,
                order: !0,
                orphans: !0,
                widows: !0,
                zIndex: !0,
                zoom: !0
            },
            cssProps: {
                "float": "cssFloat"
            },
            style: function (elem, name, value, extra) {
                if (elem && 3 !== elem.nodeType && 8 !== elem.nodeType && elem.style) {
                    var ret, type, hooks, origName = jQuery.camelCase(name),
                        style = elem.style;
                    return name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName)),
                        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName],
                        value === undefined ? hooks && "get" in hooks && (ret = hooks.get(elem, !1, extra)) !== undefined ? ret : style[name] : (type = typeof value, "string" === type && (ret = rrelNum.exec(value)) && (value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name)), type = "number"), null == value || "number" === type && isNaN(value) || ("number" !== type || jQuery.cssNumber[origName] || (value += "px"), jQuery.support.clearCloneStyle || "" !== value || 0 !== name.indexOf("background") || (style[name] = "inherit"), hooks && "set" in hooks && (value = hooks.set(elem, value, extra)) === undefined || (style[name] = value)), void 0)
                }
            },
            css: function (elem, name, extra, styles) {
                var val, num, hooks, origName = jQuery.camelCase(name);
                return name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName)),
                    hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName],
                    hooks && "get" in hooks && (val = hooks.get(elem, !0, extra)),
                    val === undefined && (val = curCSS(elem, name, styles)),
                    "normal" === val && name in cssNormalTransform && (val = cssNormalTransform[name]),
                    "" === extra || extra ? (num = parseFloat(val), extra === !0 || jQuery.isNumeric(num) ? num || 0 : val) : val
            }
        }),
        curCSS = function (elem, name, _computed) {
            var width, minWidth, maxWidth, computed = _computed || getStyles(elem),
                ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined,
                style = elem.style;
            return computed && ("" !== ret || jQuery.contains(elem.ownerDocument, elem) || (ret = jQuery.style(elem, name)), rnumnonpx.test(ret) && rmargin.test(name) && (width = style.width, minWidth = style.minWidth, maxWidth = style.maxWidth, style.minWidth = style.maxWidth = style.width = ret, ret = computed.width, style.width = width, style.minWidth = minWidth, style.maxWidth = maxWidth)),
                ret
        },
        jQuery.each(["height", "width"],
            function (i, name) {
                jQuery.cssHooks[name] = {
                    get: function (elem, computed, extra) {
                        return computed ? 0 === elem.offsetWidth && rdisplayswap.test(jQuery.css(elem, "display")) ? jQuery.swap(elem, cssShow,
                            function () {
                                return getWidthOrHeight(elem, name, extra)
                            }) : getWidthOrHeight(elem, name, extra) : void 0
                    },
                    set: function (elem, value, extra) {
                        var styles = extra && getStyles(elem);
                        return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.support.boxSizing && "border-box" === jQuery.css(elem, "boxSizing", !1, styles), styles) : 0)
                    }
                }
            }),
        jQuery(function () {
            jQuery.support.reliableMarginRight || (jQuery.cssHooks.marginRight = {
                get: function (elem, computed) {
                    return computed ? jQuery.swap(elem, {
                            display: "inline-block"
                        },
                        curCSS, [elem, "marginRight"]) : void 0
                }
            }), !jQuery.support.pixelPosition && jQuery.fn.position && jQuery.each(["top", "left"],
                function (i, prop) {
                    jQuery.cssHooks[prop] = {
                        get: function (elem, computed) {
                            return computed ? (computed = curCSS(elem, prop), rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed) : void 0
                        }
                    }
                })
        }),
        jQuery.expr && jQuery.expr.filters && (jQuery.expr.filters.hidden = function (elem) {
                return elem.offsetWidth <= 0 && elem.offsetHeight <= 0
            },
            jQuery.expr.filters.visible = function (elem) {
                return !jQuery.expr.filters.hidden(elem)
            }),
        jQuery.each({
                margin: "",
                padding: "",
                border: "Width"
            },
            function (prefix, suffix) {
                jQuery.cssHooks[prefix + suffix] = {
                        expand: function (value) {
                            for (var i = 0,
                                    expanded = {},
                                    parts = "string" == typeof value ? value.split(" ") : [value]; 4 > i; i++) expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                            return expanded
                        }
                    },
                    rmargin.test(prefix) || (jQuery.cssHooks[prefix + suffix].set = setPositiveNumber)
            });
    var r20 = /%20/g,
        rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i;
    jQuery.fn.extend({
            serialize: function () {
                return jQuery.param(this.serializeArray())
            },
            serializeArray: function () {
                return this.map(function () {
                    var elements = jQuery.prop(this, "elements");
                    return elements ? jQuery.makeArray(elements) : this
                }).filter(function () {
                    var type = this.type;
                    return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !manipulation_rcheckableType.test(type))
                }).map(function (i, elem) {
                    var val = jQuery(this).val();
                    return null == val ? null : jQuery.isArray(val) ? jQuery.map(val,
                        function (val) {
                            return {
                                name: elem.name,
                                value: val.replace(rCRLF, "\r\n")
                            }
                        }) : {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    }
                }).get()
            }
        }),
        jQuery.param = function (a, traditional) {
            var prefix, s = [],
                add = function (key, value) {
                    value = jQuery.isFunction(value) ? value() : null == value ? "" : value,
                        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value)
                };
            if (traditional === undefined && (traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional), jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) jQuery.each(a,
                function () {
                    add(this.name, this.value)
                });
            else
                for (prefix in a) buildParams(prefix, a[prefix], traditional, add);
            return s.join("&").replace(r20, "+")
        },
        jQuery.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),
            function (i, name) {
                jQuery.fn[name] = function (data, fn) {
                    return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name)
                }
            }),
        jQuery.fn.extend({
            hover: function (fnOver, fnOut) {
                return this.mouseenter(fnOver).mouseleave(fnOut || fnOver)
            },
            bind: function (types, data, fn) {
                return this.on(types, null, data, fn)
            },
            unbind: function (types, fn) {
                return this.off(types, null, fn)
            },
            delegate: function (selector, types, data, fn) {
                return this.on(types, selector, data, fn)
            },
            undelegate: function (selector, types, fn) {
                return 1 === arguments.length ? this.off(selector, "**") : this.off(types, selector || "**", fn)
            }
        });
    var ajaxLocParts, ajaxLocation, ajax_nonce = jQuery.now(),
        ajax_rquery = /\?/,
        rhash = /#.*$/,
        rts = /([?&])_=[^&]*/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm,
        rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,
        rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,
        _load = jQuery.fn.load,
        prefilters = {},
        transports = {},
        allTypes = "*/".concat("*");
    try {
        ajaxLocation = location.href
    } catch (e) {
        ajaxLocation = document.createElement("a"),
            ajaxLocation.href = "",
            ajaxLocation = ajaxLocation.href
    }
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [],
        jQuery.fn.load = function (url, params, callback) {
            if ("string" != typeof url && _load) return _load.apply(this, arguments);
            var selector, type, response, self = this,
                off = url.indexOf(" ");
            return off >= 0 && (selector = url.slice(off), url = url.slice(0, off)),
                jQuery.isFunction(params) ? (callback = params, params = undefined) : params && "object" == typeof params && (type = "POST"),
                self.length > 0 && jQuery.ajax({
                    url: url,
                    type: type,
                    dataType: "html",
                    data: params
                }).done(function (responseText) {
                    response = arguments,
                        self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText)
                }).complete(callback &&
                    function (jqXHR, status) {
                        self.each(callback, response || [jqXHR.responseText, status, jqXHR])
                    }),
                this
        },
        jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"],
            function (i, type) {
                jQuery.fn[type] = function (fn) {
                    return this.on(type, fn)
                }
            }),
        jQuery.extend({
            active: 0,
            lastModified: {},
            etag: {},
            ajaxSettings: {
                url: ajaxLocation,
                type: "GET",
                isLocal: rlocalProtocol.test(ajaxLocParts[1]),
                global: !0,
                processData: !0,
                async: !0,
                contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                accepts: {
                    "*": allTypes,
                    text: "text/plain",
                    html: "text/html",
                    xml: "application/xml, text/xml",
                    json: "application/json, text/javascript"
                },
                contents: {
                    xml: /xml/,
                    html: /html/,
                    json: /json/
                },
                responseFields: {
                    xml: "responseXML",
                    text: "responseText",
                    json: "responseJSON"
                },
                converters: {
                    "* text": String,
                    "text html": !0,
                    "text json": jQuery.parseJSON,
                    "text xml": jQuery.parseXML
                },
                flatOptions: {
                    url: !0,
                    context: !0
                }
            },
            ajaxSetup: function (target, settings) {
                return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target)
            },
            ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
            ajaxTransport: addToPrefiltersOrTransports(transports),
            ajax: function (url, options) {
                function done(status, nativeStatusText, responses, headers) {
                    var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                    2 !== state && (state = 2, timeoutTimer && clearTimeout(timeoutTimer), transport = undefined, responseHeadersString = headers || "", jqXHR.readyState = status > 0 ? 4 : 0, isSuccess = status >= 200 && 300 > status || 304 === status, responses && (response = ajaxHandleResponses(s, jqXHR, responses)), response = ajaxConvert(s, response, jqXHR, isSuccess), isSuccess ? (s.ifModified && (modified = jqXHR.getResponseHeader("Last-Modified"), modified && (jQuery.lastModified[cacheURL] = modified), modified = jqXHR.getResponseHeader("etag"), modified && (jQuery.etag[cacheURL] = modified)), 204 === status || "HEAD" === s.type ? statusText = "nocontent" : 304 === status ? statusText = "notmodified" : (statusText = response.state, success = response.data, error = response.error, isSuccess = !error)) : (error = statusText, (status || !statusText) && (statusText = "error", 0 > status && (status = 0))), jqXHR.status = status, jqXHR.statusText = (nativeStatusText || statusText) + "", isSuccess ? deferred.resolveWith(callbackContext, [success, statusText, jqXHR]) : deferred.rejectWith(callbackContext, [jqXHR, statusText, error]), jqXHR.statusCode(statusCode), statusCode = undefined, fireGlobals && globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]), completeDeferred.fireWith(callbackContext, [jqXHR, statusText]), fireGlobals && (globalEventContext.trigger("ajaxComplete", [jqXHR, s]), --jQuery.active || jQuery.event.trigger("ajaxStop")))
                }
                "object" == typeof url && (options = url, url = undefined),
                    options = options || {};
                var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({},
                        options),
                    callbackContext = s.context || s,
                    globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
                    deferred = jQuery.Deferred(),
                    completeDeferred = jQuery.Callbacks("once memory"),
                    statusCode = s.statusCode || {},
                    requestHeaders = {},
                    requestHeadersNames = {},
                    state = 0,
                    strAbort = "canceled",
                    jqXHR = {
                        readyState: 0,
                        getResponseHeader: function (key) {
                            var match;
                            if (2 === state) {
                                if (!responseHeaders)
                                    for (responseHeaders = {}; match = rheaders.exec(responseHeadersString);) responseHeaders[match[1].toLowerCase()] = match[2];
                                match = responseHeaders[key.toLowerCase()]
                            }
                            return null == match ? null : match
                        },
                        getAllResponseHeaders: function () {
                            return 2 === state ? responseHeadersString : null
                        },
                        setRequestHeader: function (name, value) {
                            var lname = name.toLowerCase();
                            return state || (name = requestHeadersNames[lname] = requestHeadersNames[lname] || name, requestHeaders[name] = value),
                                this
                        },
                        overrideMimeType: function (type) {
                            return state || (s.mimeType = type),
                                this
                        },
                        statusCode: function (map) {
                            var code;
                            if (map)
                                if (2 > state)
                                    for (code in map) statusCode[code] = [statusCode[code], map[code]];
                                else jqXHR.always(map[jqXHR.status]);
                            return this
                        },
                        abort: function (statusText) {
                            var finalText = statusText || strAbort;
                            return transport && transport.abort(finalText),
                                done(0, finalText),
                                this
                        }
                    };
                if (deferred.promise(jqXHR).complete = completeDeferred.add, jqXHR.success = jqXHR.done, jqXHR.error = jqXHR.fail, s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//"), s.type = options.method || options.type || s.method || s.type, s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(core_rnotwhite) || [""], null == s.crossDomain && (parts = rurl.exec(s.url.toLowerCase()), s.crossDomain = !(!parts || parts[1] === ajaxLocParts[1] && parts[2] === ajaxLocParts[2] && (parts[3] || ("http:" === parts[1] ? "80" : "443")) === (ajaxLocParts[3] || ("http:" === ajaxLocParts[1] ? "80" : "443")))), s.data && s.processData && "string" != typeof s.data && (s.data = jQuery.param(s.data, s.traditional)), inspectPrefiltersOrTransports(prefilters, s, options, jqXHR), 2 === state) return jqXHR;
                fireGlobals = s.global,
                    fireGlobals && 0 === jQuery.active++ && jQuery.event.trigger("ajaxStart"),
                    s.type = s.type.toUpperCase(),
                    s.hasContent = !rnoContent.test(s.type),
                    cacheURL = s.url,
                    s.hasContent || (s.data && (cacheURL = s.url += (ajax_rquery.test(cacheURL) ? "&" : "?") + s.data, delete s.data), s.cache === !1 && (s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + ajax_nonce++) : cacheURL + (ajax_rquery.test(cacheURL) ? "&" : "?") + "_=" + ajax_nonce++)),
                    s.ifModified && (jQuery.lastModified[cacheURL] && jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]), jQuery.etag[cacheURL] && jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])),
                    (s.data && s.hasContent && s.contentType !== !1 || options.contentType) && jqXHR.setRequestHeader("Content-Type", s.contentType),
                    jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + ("*" !== s.dataTypes[0] ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
                for (i in s.headers) jqXHR.setRequestHeader(i, s.headers[i]);
                if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === !1 || 2 === state)) return jqXHR.abort();
                strAbort = "abort";
                for (i in {
                        success: 1,
                        error: 1,
                        complete: 1
                    }) jqXHR[i](s[i]);
                if (transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR)) {
                    jqXHR.readyState = 1,
                        fireGlobals && globalEventContext.trigger("ajaxSend", [jqXHR, s]),
                        s.async && s.timeout > 0 && (timeoutTimer = setTimeout(function () {
                                jqXHR.abort("timeout")
                            },
                            s.timeout));
                    try {
                        state = 1,
                            transport.send(requestHeaders, done)
                    } catch (e) {
                        if (!(2 > state)) throw e;
                        done(-1, e)
                    }
                } else done(-1, "No Transport");
                return jqXHR
            },
            getJSON: function (url, data, callback) {
                return jQuery.get(url, data, callback, "json")
            },
            getScript: function (url, callback) {
                return jQuery.get(url, undefined, callback, "script")
            }
        }),
        jQuery.each(["get", "post"],
            function (i, method) {
                jQuery[method] = function (url, data, callback, type) {
                    return jQuery.isFunction(data) && (type = type || callback, callback = data, data = undefined),
                        jQuery.ajax({
                            url: url,
                            type: method,
                            dataType: type,
                            data: data,
                            success: callback
                        })
                }
            }),
        jQuery.ajaxSetup({
            accepts: {
                script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
            },
            contents: {
                script: /(?:java|ecma)script/
            },
            converters: {
                "text script": function (text) {
                    return jQuery.globalEval(text),
                        text
                }
            }
        }),
        jQuery.ajaxPrefilter("script",
            function (s) {
                s.cache === undefined && (s.cache = !1),
                    s.crossDomain && (s.type = "GET")
            }),
        jQuery.ajaxTransport("script",
            function (s) {
                if (s.crossDomain) {
                    var script, callback;
                    return {
                        send: function (_, complete) {
                            script = jQuery("<script>").prop({
                                    async: !0,
                                    charset: s.scriptCharset,
                                    src: s.url
                                }).on("load error", callback = function (evt) {
                                    script.remove(),
                                        callback = null,
                                        evt && complete("error" === evt.type ? 404 : 200, evt.type)
                                }),
                                document.head.appendChild(script[0])
                        },
                        abort: function () {
                            callback && callback()
                        }
                    }
                }
            });
    var oldCallbacks = [],
        rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
            jsonp: "callback",
            jsonpCallback: function () {
                var callback = oldCallbacks.pop() || jQuery.expando + "_" + ajax_nonce++;
                return this[callback] = !0,
                    callback
            }
        }),
        jQuery.ajaxPrefilter("json jsonp",
            function (s, originalSettings, jqXHR) {
                var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== !1 && (rjsonp.test(s.url) ? "url" : "string" == typeof s.data && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
                return jsonProp || "jsonp" === s.dataTypes[0] ? (callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback, jsonProp ? s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName) : s.jsonp !== !1 && (s.url += (ajax_rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName), s.converters["script json"] = function () {
                        return responseContainer || jQuery.error(callbackName + " was not called"),
                            responseContainer[0]
                    },
                    s.dataTypes[0] = "json", overwritten = window[callbackName], window[callbackName] = function () {
                        responseContainer = arguments
                    },
                    jqXHR.always(function () {
                        window[callbackName] = overwritten,
                            s[callbackName] && (s.jsonpCallback = originalSettings.jsonpCallback, oldCallbacks.push(callbackName)),
                            responseContainer && jQuery.isFunction(overwritten) && overwritten(responseContainer[0]),
                            responseContainer = overwritten = undefined
                    }), "script") : void 0
            }),
        jQuery.ajaxSettings.xhr = function () {
            try {
                return new XMLHttpRequest
            } catch (e) {}
        };
    var xhrSupported = jQuery.ajaxSettings.xhr(),
        xhrSuccessStatus = {
            0: 200,
            1223: 204
        },
        xhrId = 0,
        xhrCallbacks = {};
    window.ActiveXObject && jQuery(window).on("unload",
            function () {
                for (var key in xhrCallbacks) xhrCallbacks[key]();
                xhrCallbacks = undefined
            }),
        jQuery.support.cors = !!xhrSupported && "withCredentials" in xhrSupported,
        jQuery.support.ajax = xhrSupported = !!xhrSupported,
        jQuery.ajaxTransport(function (options) {
            var callback;
            return jQuery.support.cors || xhrSupported && !options.crossDomain ? {
                send: function (headers, complete) {
                    var i, id, xhr = options.xhr();
                    if (xhr.open(options.type, options.url, options.async, options.username, options.password), options.xhrFields)
                        for (i in options.xhrFields) xhr[i] = options.xhrFields[i];
                    options.mimeType && xhr.overrideMimeType && xhr.overrideMimeType(options.mimeType),
                        options.crossDomain || headers["X-Requested-With"] || (headers["X-Requested-With"] = "XMLHttpRequest");
                    for (i in headers) xhr.setRequestHeader(i, headers[i]);
                    callback = function (type) {
                            return function () {
                                callback && (delete xhrCallbacks[id], callback = xhr.onload = xhr.onerror = null, "abort" === type ? xhr.abort() : "error" === type ? complete(xhr.status || 404, xhr.statusText) : complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, "string" == typeof xhr.responseText ? {
                                    text: xhr.responseText
                                } : undefined, xhr.getAllResponseHeaders()))
                            }
                        },
                        xhr.onload = callback(),
                        xhr.onerror = callback("error"),
                        callback = xhrCallbacks[id = xhrId++] = callback("abort"),
                        xhr.send(options.hasContent && options.data || null)
                },
                abort: function () {
                    callback && callback()
                }
            } : void 0
        });
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/,
        rfxnum = new RegExp("^(?:([+-])=|)(" + core_pnum + ")([a-z%]*)$", "i"),
        rrun = /queueHooks$/,
        animationPrefilters = [defaultPrefilter],
        tweeners = {
            "*": [function (prop, value) {
                var tween = this.createTween(prop, value),
                    target = tween.cur(),
                    parts = rfxnum.exec(value),
                    unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
                    start = (jQuery.cssNumber[prop] || "px" !== unit && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)),
                    scale = 1,
                    maxIterations = 20;
                if (start && start[3] !== unit) {
                    unit = unit || start[3],
                        parts = parts || [],
                        start = +target || 1;
                    do scale = scale || ".5",
                        start /= scale,
                        jQuery.style(tween.elem, prop, start + unit);
                    while (scale !== (scale = tween.cur() / target) && 1 !== scale && --maxIterations)
                }
                return parts && (start = tween.start = +start || +target || 0, tween.unit = unit, tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2]),
                    tween
            }]
        };
    jQuery.Animation = jQuery.extend(Animation, {
            tweener: function (props, callback) {
                jQuery.isFunction(props) ? (callback = props, props = ["*"]) : props = props.split(" ");
                for (var prop, index = 0,
                        length = props.length; length > index; index++) prop = props[index],
                    tweeners[prop] = tweeners[prop] || [],
                    tweeners[prop].unshift(callback)
            },
            prefilter: function (callback, prepend) {
                prepend ? animationPrefilters.unshift(callback) : animationPrefilters.push(callback)
            }
        }),
        jQuery.Tween = Tween,
        Tween.prototype = {
            constructor: Tween,
            init: function (elem, options, prop, end, easing, unit) {
                this.elem = elem,
                    this.prop = prop,
                    this.easing = easing || "swing",
                    this.options = options,
                    this.start = this.now = this.cur(),
                    this.end = end,
                    this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px")
            },
            cur: function () {
                var hooks = Tween.propHooks[this.prop];
                return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this)
            },
            run: function (percent) {
                var eased, hooks = Tween.propHooks[this.prop];
                return this.pos = eased = this.options.duration ? jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration) : percent,
                    this.now = (this.end - this.start) * eased + this.start,
                    this.options.step && this.options.step.call(this.elem, this.now, this),
                    hooks && hooks.set ? hooks.set(this) : Tween.propHooks._default.set(this),
                    this
            }
        },
        Tween.prototype.init.prototype = Tween.prototype,
        Tween.propHooks = {
            _default: {
                get: function (tween) {
                    var result;
                    return null == tween.elem[tween.prop] || tween.elem.style && null != tween.elem.style[tween.prop] ? (result = jQuery.css(tween.elem, tween.prop, ""), result && "auto" !== result ? result : 0) : tween.elem[tween.prop]
                },
                set: function (tween) {
                    jQuery.fx.step[tween.prop] ? jQuery.fx.step[tween.prop](tween) : tween.elem.style && (null != tween.elem.style[jQuery.cssProps[tween.prop]] || jQuery.cssHooks[tween.prop]) ? jQuery.style(tween.elem, tween.prop, tween.now + tween.unit) : tween.elem[tween.prop] = tween.now
                }
            }
        },
        Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
            set: function (tween) {
                tween.elem.nodeType && tween.elem.parentNode && (tween.elem[tween.prop] = tween.now)
            }
        },
        jQuery.each(["toggle", "show", "hide"],
            function (i, name) {
                var cssFn = jQuery.fn[name];
                jQuery.fn[name] = function (speed, easing, callback) {
                    return null == speed || "boolean" == typeof speed ? cssFn.apply(this, arguments) : this.animate(genFx(name, !0), speed, easing, callback)
                }
            }),
        jQuery.fn.extend({
            fadeTo: function (speed, to, easing, callback) {
                return this.filter(isHidden).css("opacity", 0).show().end().animate({
                        opacity: to
                    },
                    speed, easing, callback)
            },
            animate: function (prop, speed, easing, callback) {
                var empty = jQuery.isEmptyObject(prop),
                    optall = jQuery.speed(speed, easing, callback),
                    doAnimation = function () {
                        var anim = Animation(this, jQuery.extend({},
                            prop), optall);
                        (empty || data_priv.get(this, "finish")) && anim.stop(!0)
                    };
                return doAnimation.finish = doAnimation,
                    empty || optall.queue === !1 ? this.each(doAnimation) : this.queue(optall.queue, doAnimation)
            },
            stop: function (type, clearQueue, gotoEnd) {
                var stopQueue = function (hooks) {
                    var stop = hooks.stop;
                    delete hooks.stop,
                        stop(gotoEnd)
                };
                return "string" != typeof type && (gotoEnd = clearQueue, clearQueue = type, type = undefined),
                    clearQueue && type !== !1 && this.queue(type || "fx", []),
                    this.each(function () {
                        var dequeue = !0,
                            index = null != type && type + "queueHooks",
                            timers = jQuery.timers,
                            data = data_priv.get(this);
                        if (index) data[index] && data[index].stop && stopQueue(data[index]);
                        else
                            for (index in data) data[index] && data[index].stop && rrun.test(index) && stopQueue(data[index]);
                        for (index = timers.length; index--;) timers[index].elem !== this || null != type && timers[index].queue !== type || (timers[index].anim.stop(gotoEnd), dequeue = !1, timers.splice(index, 1));
                        (dequeue || !gotoEnd) && jQuery.dequeue(this, type)
                    })
            },
            finish: function (type) {
                return type !== !1 && (type = type || "fx"),
                    this.each(function () {
                        var index, data = data_priv.get(this),
                            queue = data[type + "queue"],
                            hooks = data[type + "queueHooks"],
                            timers = jQuery.timers,
                            length = queue ? queue.length : 0;
                        for (data.finish = !0, jQuery.queue(this, type, []), hooks && hooks.stop && hooks.stop.call(this, !0), index = timers.length; index--;) timers[index].elem === this && timers[index].queue === type && (timers[index].anim.stop(!0), timers.splice(index, 1));
                        for (index = 0; length > index; index++) queue[index] && queue[index].finish && queue[index].finish.call(this);
                        delete data.finish
                    })
            }
        }),
        jQuery.each({
                slideDown: genFx("show"),
                slideUp: genFx("hide"),
                slideToggle: genFx("toggle"),
                fadeIn: {
                    opacity: "show"
                },
                fadeOut: {
                    opacity: "hide"
                },
                fadeToggle: {
                    opacity: "toggle"
                }
            },
            function (name, props) {
                jQuery.fn[name] = function (speed, easing, callback) {
                    return this.animate(props, speed, easing, callback)
                }
            }),
        jQuery.speed = function (speed, easing, fn) {
            var opt = speed && "object" == typeof speed ? jQuery.extend({},
                speed) : {
                complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
                duration: speed,
                easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
            };
            return opt.duration = jQuery.fx.off ? 0 : "number" == typeof opt.duration ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default,
                (null == opt.queue || opt.queue === !0) && (opt.queue = "fx"),
                opt.old = opt.complete,
                opt.complete = function () {
                    jQuery.isFunction(opt.old) && opt.old.call(this),
                        opt.queue && jQuery.dequeue(this, opt.queue)
                },
                opt
        },
        jQuery.easing = {
            linear: function (p) {
                return p
            },
            swing: function (p) {
                return .5 - Math.cos(p * Math.PI) / 2
            }
        },
        jQuery.timers = [],
        jQuery.fx = Tween.prototype.init,
        jQuery.fx.tick = function () {
            var timer, timers = jQuery.timers,
                i = 0;
            for (fxNow = jQuery.now(); i < timers.length; i++) timer = timers[i],
                timer() || timers[i] !== timer || timers.splice(i--, 1);
            timers.length || jQuery.fx.stop(),
                fxNow = undefined
        },
        jQuery.fx.timer = function (timer) {
            timer() && jQuery.timers.push(timer) && jQuery.fx.start()
        },
        jQuery.fx.interval = 13,
        jQuery.fx.start = function () {
            timerId || (timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval))
        },
        jQuery.fx.stop = function () {
            clearInterval(timerId),
                timerId = null
        },
        jQuery.fx.speeds = {
            slow: 600,
            fast: 200,
            _default: 400
        },
        jQuery.fx.step = {},
        jQuery.expr && jQuery.expr.filters && (jQuery.expr.filters.animated = function (elem) {
            return jQuery.grep(jQuery.timers,
                function (fn) {
                    return elem === fn.elem
                }).length
        }),
        jQuery.fn.offset = function (options) {
            if (arguments.length) return options === undefined ? this : this.each(function (i) {
                jQuery.offset.setOffset(this, options, i)
            });
            var docElem, win, elem = this[0],
                box = {
                    top: 0,
                    left: 0
                },
                doc = elem && elem.ownerDocument;
            if (doc) return docElem = doc.documentElement,
                jQuery.contains(docElem, elem) ? (typeof elem.getBoundingClientRect !== core_strundefined && (box = elem.getBoundingClientRect()), win = getWindow(doc), {
                    top: box.top + win.pageYOffset - docElem.clientTop,
                    left: box.left + win.pageXOffset - docElem.clientLeft
                }) : box
        },
        jQuery.offset = {
            setOffset: function (elem, options, i) {
                var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"),
                    curElem = jQuery(elem),
                    props = {};
                "static" === position && (elem.style.position = "relative"),
                    curOffset = curElem.offset(),
                    curCSSTop = jQuery.css(elem, "top"),
                    curCSSLeft = jQuery.css(elem, "left"),
                    calculatePosition = ("absolute" === position || "fixed" === position) && (curCSSTop + curCSSLeft).indexOf("auto") > -1,
                    calculatePosition ? (curPosition = curElem.position(), curTop = curPosition.top, curLeft = curPosition.left) : (curTop = parseFloat(curCSSTop) || 0, curLeft = parseFloat(curCSSLeft) || 0),
                    jQuery.isFunction(options) && (options = options.call(elem, i, curOffset)),
                    null != options.top && (props.top = options.top - curOffset.top + curTop),
                    null != options.left && (props.left = options.left - curOffset.left + curLeft),
                    "using" in options ? options.using.call(elem, props) : curElem.css(props)
            }
        },
        jQuery.fn.extend({
            position: function () {
                if (this[0]) {
                    var offsetParent, offset, elem = this[0],
                        parentOffset = {
                            top: 0,
                            left: 0
                        };
                    return "fixed" === jQuery.css(elem, "position") ? offset = elem.getBoundingClientRect() : (offsetParent = this.offsetParent(), offset = this.offset(), jQuery.nodeName(offsetParent[0], "html") || (parentOffset = offsetParent.offset()), parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", !0), parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", !0)), {
                        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", !0),
                        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", !0)
                    }
                }
            },
            offsetParent: function () {
                return this.map(function () {
                    for (var offsetParent = this.offsetParent || docElem; offsetParent && !jQuery.nodeName(offsetParent, "html") && "static" === jQuery.css(offsetParent, "position");) offsetParent = offsetParent.offsetParent;
                    return offsetParent || docElem
                })
            }
        }),
        jQuery.each({
                scrollLeft: "pageXOffset",
                scrollTop: "pageYOffset"
            },
            function (method, prop) {
                var top = "pageYOffset" === prop;
                jQuery.fn[method] = function (val) {
                    return jQuery.access(this,
                        function (elem, method, val) {
                            var win = getWindow(elem);
                            return val === undefined ? win ? win[prop] : elem[method] : void(win ? win.scrollTo(top ? window.pageXOffset : val, top ? val : window.pageYOffset) : elem[method] = val)
                        },
                        method, val, arguments.length, null)
                }
            }),
        jQuery.each({
                Height: "height",
                Width: "width"
            },
            function (name, type) {
                jQuery.each({
                        padding: "inner" + name,
                        content: type,
                        "": "outer" + name
                    },
                    function (defaultExtra, funcName) {
                        jQuery.fn[funcName] = function (margin, value) {
                            var chainable = arguments.length && (defaultExtra || "boolean" != typeof margin),
                                extra = defaultExtra || (margin === !0 || value === !0 ? "margin" : "border");
                            return jQuery.access(this,
                                function (elem, type, value) {
                                    var doc;
                                    return jQuery.isWindow(elem) ? elem.document.documentElement["client" + name] : 9 === elem.nodeType ? (doc = elem.documentElement, Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name])) : value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra)
                                },
                                type, chainable ? margin : undefined, chainable, null)
                        }
                    })
            }),
        jQuery.fn.size = function () {
            return this.length
        },
        jQuery.fn.andSelf = jQuery.fn.addBack,
        "object" == typeof module && module && "object" == typeof module.exports ? module.exports = jQuery : "function" == typeof define && define.amd && define("jquery", [],
            function () {
                return jQuery
            }),
        "object" == typeof window && "object" == typeof window.document && (window.jQuery = window.$ = jQuery)
}(window),
function ($, undefined) {
    function focusable(element, isTabIndexNotNaN) {
        var map, mapName, img, nodeName = element.nodeName.toLowerCase();
        return "area" === nodeName ? (map = element.parentNode, mapName = map.name, element.href && mapName && "map" === map.nodeName.toLowerCase() ? (img = $("img[usemap=#" + mapName + "]")[0], !!img && visible(img)) : !1) : (/input|select|textarea|button|object/.test(nodeName) ? !element.disabled : "a" === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && visible(element)
    }

    function visible(element) {
        return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function () {
            return "hidden" === $.css(this, "visibility")
        }).length
    }
    var uuid = 0,
        runiqueId = /^ui-id-\d+$/;
    $.ui = $.ui || {},
        $.extend($.ui, {
            version: "1.10.3",
            keyCode: {
                BACKSPACE: 8,
                COMMA: 188,
                DELETE: 46,
                DOWN: 40,
                END: 35,
                ENTER: 13,
                ESCAPE: 27,
                HOME: 36,
                LEFT: 37,
                NUMPAD_ADD: 107,
                NUMPAD_DECIMAL: 110,
                NUMPAD_DIVIDE: 111,
                NUMPAD_ENTER: 108,
                NUMPAD_MULTIPLY: 106,
                NUMPAD_SUBTRACT: 109,
                PAGE_DOWN: 34,
                PAGE_UP: 33,
                PERIOD: 190,
                RIGHT: 39,
                SPACE: 32,
                TAB: 9,
                UP: 38
            }
        }),
        $.fn.extend({
            focus: function (orig) {
                return function (delay, fn) {
                    return "number" == typeof delay ? this.each(function () {
                        var elem = this;
                        setTimeout(function () {
                                $(elem).focus(),
                                    fn && fn.call(elem)
                            },
                            delay)
                    }) : orig.apply(this, arguments)
                }
            }($.fn.focus),
            scrollParent: function () {
                var scrollParent;
                return scrollParent = $.ui.ie && /(static|relative)/.test(this.css("position")) || /absolute/.test(this.css("position")) ? this.parents().filter(function () {
                        return /(relative|absolute|fixed)/.test($.css(this, "position")) && /(auto|scroll)/.test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"))
                    }).eq(0) : this.parents().filter(function () {
                        return /(auto|scroll)/.test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"))
                    }).eq(0),
                    /fixed/.test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent
            },
            zIndex: function (zIndex) {
                if (zIndex !== undefined) return this.css("zIndex", zIndex);
                if (this.length)
                    for (var position, value, elem = $(this[0]); elem.length && elem[0] !== document;) {
                        if (position = elem.css("position"), ("absolute" === position || "relative" === position || "fixed" === position) && (value = parseInt(elem.css("zIndex"), 10), !isNaN(value) && 0 !== value)) return value;
                        elem = elem.parent()
                    }
                return 0
            },
            uniqueId: function () {
                return this.each(function () {
                    this.id || (this.id = "ui-id-" + ++uuid)
                })
            },
            removeUniqueId: function () {
                return this.each(function () {
                    runiqueId.test(this.id) && $(this).removeAttr("id")
                })
            }
        }),
        $.extend($.expr[":"], {
            data: $.expr.createPseudo ? $.expr.createPseudo(function (dataName) {
                return function (elem) {
                    return !!$.data(elem, dataName)
                }
            }) : function (elem, i, match) {
                return !!$.data(elem, match[3])
            },
            focusable: function (element) {
                return focusable(element, !isNaN($.attr(element, "tabindex")))
            },
            tabbable: function (element) {
                var tabIndex = $.attr(element, "tabindex"),
                    isTabIndexNaN = isNaN(tabIndex);
                return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN)
            }
        }),
        $("<a>").outerWidth(1).jquery || $.each(["Width", "Height"],
            function (i, name) {
                function reduce(elem, size, border, margin) {
                    return $.each(side,
                            function () {
                                size -= parseFloat($.css(elem, "padding" + this)) || 0,
                                    border && (size -= parseFloat($.css(elem, "border" + this + "Width")) || 0),
                                    margin && (size -= parseFloat($.css(elem, "margin" + this)) || 0)
                            }),
                        size
                }
                var side = "Width" === name ? ["Left", "Right"] : ["Top", "Bottom"],
                    type = name.toLowerCase(),
                    orig = {
                        innerWidth: $.fn.innerWidth,
                        innerHeight: $.fn.innerHeight,
                        outerWidth: $.fn.outerWidth,
                        outerHeight: $.fn.outerHeight
                    };
                $.fn["inner" + name] = function (size) {
                        return size === undefined ? orig["inner" + name].call(this) : this.each(function () {
                            $(this).css(type, reduce(this, size) + "px")
                        })
                    },
                    $.fn["outer" + name] = function (size, margin) {
                        return "number" != typeof size ? orig["outer" + name].call(this, size) : this.each(function () {
                            $(this).css(type, reduce(this, size, !0, margin) + "px")
                        })
                    }
            }),
        $.fn.addBack || ($.fn.addBack = function (selector) {
            return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector))
        }),
        $("<a>").data("a-b", "a").removeData("a-b").data("a-b") && ($.fn.removeData = function (removeData) {
            return function (key) {
                return arguments.length ? removeData.call(this, $.camelCase(key)) : removeData.call(this)
            }
        }($.fn.removeData)),
        $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()),
        $.support.selectstart = "onselectstart" in document.createElement("div"),
        $.fn.extend({
            disableSelection: function () {
                return this.bind(($.support.selectstart ? "selectstart" : "mousedown") + ".ui-disableSelection",
                    function (event) {
                        event.preventDefault()
                    })
            },
            enableSelection: function () {
                return this.unbind(".ui-disableSelection")
            }
        }),
        $.extend($.ui, {
            plugin: {
                add: function (module, option, set) {
                    var i, proto = $.ui[module].prototype;
                    for (i in set) proto.plugins[i] = proto.plugins[i] || [],
                        proto.plugins[i].push([option, set[i]])
                },
                call: function (instance, name, args) {
                    var i, set = instance.plugins[name];
                    if (set && instance.element[0].parentNode && 11 !== instance.element[0].parentNode.nodeType)
                        for (i = 0; i < set.length; i++) instance.options[set[i][0]] && set[i][1].apply(instance.element, args)
                }
            },
            hasScroll: function (el, a) {
                if ("hidden" === $(el).css("overflow")) return !1;
                var scroll = a && "left" === a ? "scrollLeft" : "scrollTop",
                    has = !1;
                return el[scroll] > 0 ? !0 : (el[scroll] = 1, has = el[scroll] > 0, el[scroll] = 0, has)
            }
        })
}(jQuery),
function ($, undefined) {
    var uuid = 0,
        slice = Array.prototype.slice,
        _cleanData = $.cleanData;
    $.cleanData = function (elems) {
            for (var elem, i = 0; null != (elem = elems[i]); i++) try {
                $(elem).triggerHandler("remove")
            } catch (e) {}
            _cleanData(elems)
        },
        $.widget = function (name, base, prototype) {
            var fullName, existingConstructor, constructor, basePrototype, proxiedPrototype = {},
                namespace = name.split(".")[0];
            name = name.split(".")[1],
                fullName = namespace + "-" + name,
                prototype || (prototype = base, base = $.Widget),
                $.expr[":"][fullName.toLowerCase()] = function (elem) {
                    return !!$.data(elem, fullName)
                },
                $[namespace] = $[namespace] || {},
                existingConstructor = $[namespace][name],
                constructor = $[namespace][name] = function (options, element) {
                    return this._createWidget ? void(arguments.length && this._createWidget(options, element)) : new constructor(options, element)
                },
                $.extend(constructor, existingConstructor, {
                    version: prototype.version,
                    _proto: $.extend({},
                        prototype),
                    _childConstructors: []
                }),
                basePrototype = new base,
                basePrototype.options = $.widget.extend({},
                    basePrototype.options),
                $.each(prototype,
                    function (prop, value) {
                        return $.isFunction(value) ? void(proxiedPrototype[prop] = function () {
                            var _super = function () {
                                    return base.prototype[prop].apply(this, arguments)
                                },
                                _superApply = function (args) {
                                    return base.prototype[prop].apply(this, args)
                                };
                            return function () {
                                var returnValue, __super = this._super,
                                    __superApply = this._superApply;
                                return this._super = _super,
                                    this._superApply = _superApply,
                                    returnValue = value.apply(this, arguments),
                                    this._super = __super,
                                    this._superApply = __superApply,
                                    returnValue
                            }
                        }()) : void(proxiedPrototype[prop] = value)
                    }),
                constructor.prototype = $.widget.extend(basePrototype, {
                        widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
                    },
                    proxiedPrototype, {
                        constructor: constructor,
                        namespace: namespace,
                        widgetName: name,
                        widgetFullName: fullName
                    }),
                existingConstructor ? ($.each(existingConstructor._childConstructors,
                    function (i, child) {
                        var childPrototype = child.prototype;
                        $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto)
                    }), delete existingConstructor._childConstructors) : base._childConstructors.push(constructor),
                $.widget.bridge(name, constructor)
        },
        $.widget.extend = function (target) {
            for (var key, value, input = slice.call(arguments, 1), inputIndex = 0, inputLength = input.length; inputLength > inputIndex; inputIndex++)
                for (key in input[inputIndex]) value = input[inputIndex][key],
                    input[inputIndex].hasOwnProperty(key) && value !== undefined && (target[key] = $.isPlainObject(value) ? $.isPlainObject(target[key]) ? $.widget.extend({},
                        target[key], value) : $.widget.extend({},
                        value) : value);
            return target
        },
        $.widget.bridge = function (name, object) {
            var fullName = object.prototype.widgetFullName || name;
            $.fn[name] = function (options) {
                var isMethodCall = "string" == typeof options,
                    args = slice.call(arguments, 1),
                    returnValue = this;
                return options = !isMethodCall && args.length ? $.widget.extend.apply(null, [options].concat(args)) : options,
                    this.each(isMethodCall ?
                        function () {
                            var methodValue, instance = $.data(this, fullName);
                            return instance ? $.isFunction(instance[options]) && "_" !== options.charAt(0) ? (methodValue = instance[options].apply(instance, args), methodValue !== instance && methodValue !== undefined ? (returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue, !1) : void 0) : $.error("no such method '" + options + "' for " + name + " widget instance") : $.error("cannot call methods on " + name + " prior to initialization; attempted to call method '" + options + "'")
                        } : function () {
                            var instance = $.data(this, fullName);
                            instance ? instance.option(options || {})._init() : $.data(this, fullName, new object(options, this))
                        }),
                    returnValue
            }
        },
        $.Widget = function () {},
        $.Widget._childConstructors = [],
        $.Widget.prototype = {
            widgetName: "widget",
            widgetEventPrefix: "",
            defaultElement: "<div>",
            options: {
                disabled: !1,
                create: null
            },
            _createWidget: function (options, element) {
                element = $(element || this.defaultElement || this)[0],
                    this.element = $(element),
                    this.uuid = uuid++,
                    this.eventNamespace = "." + this.widgetName + this.uuid,
                    this.options = $.widget.extend({},
                        this.options, this._getCreateOptions(), options),
                    this.bindings = $(),
                    this.hoverable = $(),
                    this.focusable = $(),
                    element !== this && ($.data(element, this.widgetFullName, this), this._on(!0, this.element, {
                        remove: function (event) {
                            event.target === element && this.destroy()
                        }
                    }), this.document = $(element.style ? element.ownerDocument : element.document || element), this.window = $(this.document[0].defaultView || this.document[0].parentWindow)),
                    this._create(),
                    this._trigger("create", null, this._getCreateEventData()),
                    this._init()
            },
            _getCreateOptions: $.noop,
            _getCreateEventData: $.noop,
            _create: $.noop,
            _init: $.noop,
            destroy: function () {
                this._destroy(),
                    this.element.unbind(this.eventNamespace).removeData(this.widgetName).removeData(this.widgetFullName).removeData($.camelCase(this.widgetFullName)),
                    this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName + "-disabled ui-state-disabled"),
                    this.bindings.unbind(this.eventNamespace),
                    this.hoverable.removeClass("ui-state-hover"),
                    this.focusable.removeClass("ui-state-focus")
            },
            _destroy: $.noop,
            widget: function () {
                return this.element
            },
            option: function (key, value) {
                var parts, curOption, i, options = key;
                if (0 === arguments.length) return $.widget.extend({},
                    this.options);
                if ("string" == typeof key)
                    if (options = {},
                        parts = key.split("."), key = parts.shift(), parts.length) {
                        for (curOption = options[key] = $.widget.extend({},
                                this.options[key]), i = 0; i < parts.length - 1; i++) curOption[parts[i]] = curOption[parts[i]] || {},
                            curOption = curOption[parts[i]];
                        if (key = parts.pop(), value === undefined) return curOption[key] === undefined ? null : curOption[key];
                        curOption[key] = value
                    } else {
                        if (value === undefined) return this.options[key] === undefined ? null : this.options[key];
                        options[key] = value
                    }
                return this._setOptions(options),
                    this
            },
            _setOptions: function (options) {
                var key;
                for (key in options) this._setOption(key, options[key]);
                return this
            },
            _setOption: function (key, value) {
                return this.options[key] = value,
                    "disabled" === key && (this.widget().toggleClass(this.widgetFullName + "-disabled ui-state-disabled", !!value).attr("aria-disabled", value), this.hoverable.removeClass("ui-state-hover"), this.focusable.removeClass("ui-state-focus")),
                    this
            },
            enable: function () {
                return this._setOption("disabled", !1)
            },
            disable: function () {
                return this._setOption("disabled", !0)
            },
            _on: function (suppressDisabledCheck, element, handlers) {
                var delegateElement, instance = this;
                "boolean" != typeof suppressDisabledCheck && (handlers = element, element = suppressDisabledCheck, suppressDisabledCheck = !1),
                    handlers ? (element = delegateElement = $(element), this.bindings = this.bindings.add(element)) : (handlers = element, element = this.element, delegateElement = this.widget()),
                    $.each(handlers,
                        function (event, handler) {
                            function handlerProxy() {
                                return suppressDisabledCheck || instance.options.disabled !== !0 && !$(this).hasClass("ui-state-disabled") ? ("string" == typeof handler ? instance[handler] : handler).apply(instance, arguments) : void 0
                            }
                            "string" != typeof handler && (handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++);
                            var match = event.match(/^(\w+)\s*(.*)$/),
                                eventName = match[1] + instance.eventNamespace,
                                selector = match[2];
                            selector ? delegateElement.delegate(selector, eventName, handlerProxy) : element.bind(eventName, handlerProxy)
                        })
            },
            _off: function (element, eventName) {
                eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace,
                    element.unbind(eventName).undelegate(eventName)
            },
            _delay: function (handler, delay) {
                function handlerProxy() {
                    return ("string" == typeof handler ? instance[handler] : handler).apply(instance, arguments)
                }
                var instance = this;
                return setTimeout(handlerProxy, delay || 0)
            },
            _hoverable: function (element) {
                this.hoverable = this.hoverable.add(element),
                    this._on(element, {
                        mouseenter: function (event) {
                            $(event.currentTarget).addClass("ui-state-hover")
                        },
                        mouseleave: function (event) {
                            $(event.currentTarget).removeClass("ui-state-hover")
                        }
                    })
            },
            _focusable: function (element) {
                this.focusable = this.focusable.add(element),
                    this._on(element, {
                        focusin: function (event) {
                            $(event.currentTarget).addClass("ui-state-focus")
                        },
                        focusout: function (event) {
                            $(event.currentTarget).removeClass("ui-state-focus")
                        }
                    })
            },
            _trigger: function (type, event, data) {
                var prop, orig, callback = this.options[type];
                if (data = data || {},
                    event = $.Event(event), event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase(), event.target = this.element[0], orig = event.originalEvent)
                    for (prop in orig) prop in event || (event[prop] = orig[prop]);
                return this.element.trigger(event, data), !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === !1 || event.isDefaultPrevented())
            }
        },
        $.each({
                show: "fadeIn",
                hide: "fadeOut"
            },
            function (method, defaultEffect) {
                $.Widget.prototype["_" + method] = function (element, options, callback) {
                    "string" == typeof options && (options = {
                        effect: options
                    });
                    var hasOptions, effectName = options ? options === !0 || "number" == typeof options ? defaultEffect : options.effect || defaultEffect : method;
                    options = options || {},
                        "number" == typeof options && (options = {
                            duration: options
                        }),
                        hasOptions = !$.isEmptyObject(options),
                        options.complete = callback,
                        options.delay && element.delay(options.delay),
                        hasOptions && $.effects && $.effects.effect[effectName] ? element[method](options) : effectName !== method && element[effectName] ? element[effectName](options.duration, options.easing, callback) : element.queue(function (next) {
                            $(this)[method](),
                                callback && callback.call(element[0]),
                                next()
                        })
                }
            })
}(jQuery),
function ($) {
    var mouseHandled = !1;
    $(document).mouseup(function () {
            mouseHandled = !1
        }),
        $.widget("ui.mouse", {
            version: "1.10.3",
            options: {
                cancel: "input,textarea,button,select,option",
                distance: 1,
                delay: 0
            },
            _mouseInit: function () {
                var that = this;
                this.element.bind("mousedown." + this.widgetName,
                        function (event) {
                            return that._mouseDown(event)
                        }).bind("click." + this.widgetName,
                        function (event) {
                            return !0 === $.data(event.target, that.widgetName + ".preventClickEvent") ? ($.removeData(event.target, that.widgetName + ".preventClickEvent"), event.stopImmediatePropagation(), !1) : void 0
                        }),
                    this.started = !1
            },
            _mouseDestroy: function () {
                this.element.unbind("." + this.widgetName),
                    this._mouseMoveDelegate && $(document).unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate)
            },
            _mouseDown: function (event) {
                if (!mouseHandled) {
                    this._mouseStarted && this._mouseUp(event),
                        this._mouseDownEvent = event;
                    var that = this,
                        btnIsLeft = 1 === event.which,
                        elIsCancel = "string" == typeof this.options.cancel && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : !1;
                    return btnIsLeft && !elIsCancel && this._mouseCapture(event) ? (this.mouseDelayMet = !this.options.delay, this.mouseDelayMet || (this._mouseDelayTimer = setTimeout(function () {
                            that.mouseDelayMet = !0
                        },
                        this.options.delay)), this._mouseDistanceMet(event) && this._mouseDelayMet(event) && (this._mouseStarted = this._mouseStart(event) !== !1, !this._mouseStarted) ? (event.preventDefault(), !0) : (!0 === $.data(event.target, this.widgetName + ".preventClickEvent") && $.removeData(event.target, this.widgetName + ".preventClickEvent"), this._mouseMoveDelegate = function (event) {
                            return that._mouseMove(event)
                        },
                        this._mouseUpDelegate = function (event) {
                            return that._mouseUp(event)
                        },
                        $(document).bind("mousemove." + this.widgetName, this._mouseMoveDelegate).bind("mouseup." + this.widgetName, this._mouseUpDelegate), event.preventDefault(), mouseHandled = !0, !0)) : !0
                }
            },
            _mouseMove: function (event) {
                return $.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button ? this._mouseUp(event) : this._mouseStarted ? (this._mouseDrag(event), event.preventDefault()) : (this._mouseDistanceMet(event) && this._mouseDelayMet(event) && (this._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== !1, this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event)), !this._mouseStarted)
            },
            _mouseUp: function (event) {
                return $(document).unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate),
                    this._mouseStarted && (this._mouseStarted = !1, event.target === this._mouseDownEvent.target && $.data(event.target, this.widgetName + ".preventClickEvent", !0), this._mouseStop(event)), !1
            },
            _mouseDistanceMet: function (event) {
                return Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance
            },
            _mouseDelayMet: function () {
                return this.mouseDelayMet
            },
            _mouseStart: function () {},
            _mouseDrag: function () {},
            _mouseStop: function () {},
            _mouseCapture: function () {
                return !0
            }
        })
}(jQuery),
function ($) {
    $.widget("ui.draggable", $.ui.mouse, {
            version: "1.10.3",
            widgetEventPrefix: "drag",
            options: {
                addClasses: !0,
                appendTo: "parent",
                axis: !1,
                connectToSortable: !1,
                containment: !1,
                cursor: "auto",
                cursorAt: !1,
                grid: !1,
                handle: !1,
                helper: "original",
                iframeFix: !1,
                opacity: !1,
                refreshPositions: !1,
                revert: !1,
                revertDuration: 500,
                scope: "default",
                scroll: !0,
                scrollSensitivity: 20,
                scrollSpeed: 20,
                snap: !1,
                snapMode: "both",
                snapTolerance: 20,
                stack: !1,
                zIndex: !1,
                drag: null,
                start: null,
                stop: null
            },
            _create: function () {
                "original" !== this.options.helper || /^(?:r|a|f)/.test(this.element.css("position")) || (this.element[0].style.position = "relative"),
                    this.options.addClasses && this.element.addClass("ui-draggable"),
                    this.options.disabled && this.element.addClass("ui-draggable-disabled"),
                    this._mouseInit()
            },
            _destroy: function () {
                this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"),
                    this._mouseDestroy()
            },
            _mouseCapture: function (event) {
                var o = this.options;
                return this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0 ? !1 : (this.handle = this._getHandle(event), this.handle ? ($(o.iframeFix === !0 ? "iframe" : o.iframeFix).each(function () {
                    $("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>").css({
                        width: this.offsetWidth + "px",
                        height: this.offsetHeight + "px",
                        position: "absolute",
                        opacity: "0.001",
                        zIndex: 1e3
                    }).css($(this).offset()).appendTo("body")
                }), !0) : !1)
            },
            _mouseStart: function (event) {
                var o = this.options;
                return this.helper = this._createHelper(event),
                    this.helper.addClass("ui-draggable-dragging"),
                    this._cacheHelperProportions(),
                    $.ui.ddmanager && ($.ui.ddmanager.current = this),
                    this._cacheMargins(),
                    this.cssPosition = this.helper.css("position"),
                    this.scrollParent = this.helper.scrollParent(),
                    this.offsetParent = this.helper.offsetParent(),
                    this.offsetParentCssPosition = this.offsetParent.css("position"),
                    this.offset = this.positionAbs = this.element.offset(),
                    this.offset = {
                        top: this.offset.top - this.margins.top,
                        left: this.offset.left - this.margins.left
                    },
                    this.offset.scroll = !1,
                    $.extend(this.offset, {
                        click: {
                            left: event.pageX - this.offset.left,
                            top: event.pageY - this.offset.top
                        },
                        parent: this._getParentOffset(),
                        relative: this._getRelativeOffset()
                    }),
                    this.originalPosition = this.position = this._generatePosition(event),
                    this.originalPageX = event.pageX,
                    this.originalPageY = event.pageY,
                    o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt),
                    this._setContainment(),
                    this._trigger("start", event) === !1 ? (this._clear(), !1) : (this._cacheHelperProportions(), $.ui.ddmanager && !o.dropBehaviour && $.ui.ddmanager.prepareOffsets(this, event), this._mouseDrag(event, !0), $.ui.ddmanager && $.ui.ddmanager.dragStart(this, event), !0)
            },
            _mouseDrag: function (event, noPropagation) {
                if ("fixed" === this.offsetParentCssPosition && (this.offset.parent = this._getParentOffset()), this.position = this._generatePosition(event), this.positionAbs = this._convertPositionTo("absolute"), !noPropagation) {
                    var ui = this._uiHash();
                    if (this._trigger("drag", event, ui) === !1) return this._mouseUp({}), !1;
                    this.position = ui.position
                }
                return this.options.axis && "y" === this.options.axis || (this.helper[0].style.left = this.position.left + "px"),
                    this.options.axis && "x" === this.options.axis || (this.helper[0].style.top = this.position.top + "px"),
                    $.ui.ddmanager && $.ui.ddmanager.drag(this, event), !1
            },
            _mouseStop: function (event) {
                var that = this,
                    dropped = !1;
                return $.ui.ddmanager && !this.options.dropBehaviour && (dropped = $.ui.ddmanager.drop(this, event)),
                    this.dropped && (dropped = this.dropped, this.dropped = !1),
                    "original" !== this.options.helper || $.contains(this.element[0].ownerDocument, this.element[0]) ? ("invalid" === this.options.revert && !dropped || "valid" === this.options.revert && dropped || this.options.revert === !0 || $.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped) ? $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10),
                        function () {
                            that._trigger("stop", event) !== !1 && that._clear()
                        }) : this._trigger("stop", event) !== !1 && this._clear(), !1) : !1
            },
            _mouseUp: function (event) {
                return $("div.ui-draggable-iframeFix").each(function () {
                        this.parentNode.removeChild(this)
                    }),
                    $.ui.ddmanager && $.ui.ddmanager.dragStop(this, event),
                    $.ui.mouse.prototype._mouseUp.call(this, event)
            },
            cancel: function () {
                return this.helper.is(".ui-draggable-dragging") ? this._mouseUp({}) : this._clear(),
                    this
            },
            _getHandle: function (event) {
                return this.options.handle ? !!$(event.target).closest(this.element.find(this.options.handle)).length : !0
            },
            _createHelper: function (event) {
                var o = this.options,
                    helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : "clone" === o.helper ? this.element.clone().removeAttr("id") : this.element;
                return helper.parents("body").length || helper.appendTo("parent" === o.appendTo ? this.element[0].parentNode : o.appendTo),
                    helper[0] === this.element[0] || /(fixed|absolute)/.test(helper.css("position")) || helper.css("position", "absolute"),
                    helper
            },
            _adjustOffsetFromHelper: function (obj) {
                "string" == typeof obj && (obj = obj.split(" ")),
                    $.isArray(obj) && (obj = {
                        left: +obj[0],
                        top: +obj[1] || 0
                    }),
                    "left" in obj && (this.offset.click.left = obj.left + this.margins.left),
                    "right" in obj && (this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left),
                    "top" in obj && (this.offset.click.top = obj.top + this.margins.top),
                    "bottom" in obj && (this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top)
            },
            _getParentOffset: function () {
                var po = this.offsetParent.offset();
                return "absolute" === this.cssPosition && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]) && (po.left += this.scrollParent.scrollLeft(), po.top += this.scrollParent.scrollTop()),
                    (this.offsetParent[0] === document.body || this.offsetParent[0].tagName && "html" === this.offsetParent[0].tagName.toLowerCase() && $.ui.ie) && (po = {
                        top: 0,
                        left: 0
                    }), {
                        top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                        left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
                    }
            },
            _getRelativeOffset: function () {
                if ("relative" === this.cssPosition) {
                    var p = this.element.position();
                    return {
                        top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                        left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                    }
                }
                return {
                    top: 0,
                    left: 0
                }
            },
            _cacheMargins: function () {
                this.margins = {
                    left: parseInt(this.element.css("marginLeft"), 10) || 0,
                    top: parseInt(this.element.css("marginTop"), 10) || 0,
                    right: parseInt(this.element.css("marginRight"), 10) || 0,
                    bottom: parseInt(this.element.css("marginBottom"), 10) || 0
                }
            },
            _cacheHelperProportions: function () {
                this.helperProportions = {
                    width: this.helper.outerWidth(),
                    height: this.helper.outerHeight()
                }
            },
            _setContainment: function () {
                var over, c, ce, o = this.options;
                return o.containment ? "window" === o.containment ? void(this.containment = [$(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, $(window).scrollLeft() + $(window).width() - this.helperProportions.width - this.margins.left, $(window).scrollTop() + ($(window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top]) : "document" === o.containment ? void(this.containment = [0, 0, $(document).width() - this.helperProportions.width - this.margins.left, ($(document).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top]) : o.containment.constructor === Array ? void(this.containment = o.containment) : ("parent" === o.containment && (o.containment = this.helper[0].parentNode), c = $(o.containment), ce = c[0], void(ce && (over = "hidden" !== c.css("overflow"), this.containment = [(parseInt(c.css("borderLeftWidth"), 10) || 0) + (parseInt(c.css("paddingLeft"), 10) || 0), (parseInt(c.css("borderTopWidth"), 10) || 0) + (parseInt(c.css("paddingTop"), 10) || 0), (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt(c.css("borderRightWidth"), 10) || 0) - (parseInt(c.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt(c.css("borderBottomWidth"), 10) || 0) - (parseInt(c.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom], this.relative_container = c))) : void(this.containment = null)
            },
            _convertPositionTo: function (d, pos) {
                pos || (pos = this.position);
                var mod = "absolute" === d ? 1 : -1,
                    scroll = "absolute" !== this.cssPosition || this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent;
                return this.offset.scroll || (this.offset.scroll = {
                    top: scroll.scrollTop(),
                    left: scroll.scrollLeft()
                }), {
                    top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : this.offset.scroll.top) * mod,
                    left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : this.offset.scroll.left) * mod
                }
            },
            _generatePosition: function (event) {
                var containment, co, top, left, o = this.options,
                    scroll = "absolute" !== this.cssPosition || this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent,
                    pageX = event.pageX,
                    pageY = event.pageY;
                return this.offset.scroll || (this.offset.scroll = {
                        top: scroll.scrollTop(),
                        left: scroll.scrollLeft()
                    }),
                    this.originalPosition && (this.containment && (this.relative_container ? (co = this.relative_container.offset(), containment = [this.containment[0] + co.left, this.containment[1] + co.top, this.containment[2] + co.left, this.containment[3] + co.top]) : containment = this.containment, event.pageX - this.offset.click.left < containment[0] && (pageX = containment[0] + this.offset.click.left), event.pageY - this.offset.click.top < containment[1] && (pageY = containment[1] + this.offset.click.top), event.pageX - this.offset.click.left > containment[2] && (pageX = containment[2] + this.offset.click.left), event.pageY - this.offset.click.top > containment[3] && (pageY = containment[3] + this.offset.click.top)), o.grid && (top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY, pageY = containment ? top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3] ? top : top - this.offset.click.top >= containment[1] ? top - o.grid[1] : top + o.grid[1] : top, left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX, pageX = containment ? left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2] ? left : left - this.offset.click.left >= containment[0] ? left - o.grid[0] : left + o.grid[0] : left)), {
                        top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : this.offset.scroll.top),
                        left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : this.offset.scroll.left)
                    }
            },
            _clear: function () {
                this.helper.removeClass("ui-draggable-dragging"),
                    this.helper[0] === this.element[0] || this.cancelHelperRemoval || this.helper.remove(),
                    this.helper = null,
                    this.cancelHelperRemoval = !1
            },
            _trigger: function (type, event, ui) {
                return ui = ui || this._uiHash(),
                    $.ui.plugin.call(this, type, [event, ui]),
                    "drag" === type && (this.positionAbs = this._convertPositionTo("absolute")),
                    $.Widget.prototype._trigger.call(this, type, event, ui)
            },
            plugins: {},
            _uiHash: function () {
                return {
                    helper: this.helper,
                    position: this.position,
                    originalPosition: this.originalPosition,
                    offset: this.positionAbs
                }
            }
        }),
        $.ui.plugin.add("draggable", "connectToSortable", {
            start: function (event, ui) {
                var inst = $(this).data("ui-draggable"),
                    o = inst.options,
                    uiSortable = $.extend({},
                        ui, {
                            item: inst.element
                        });
                inst.sortables = [],
                    $(o.connectToSortable).each(function () {
                        var sortable = $.data(this, "ui-sortable");
                        sortable && !sortable.options.disabled && (inst.sortables.push({
                            instance: sortable,
                            shouldRevert: sortable.options.revert
                        }), sortable.refreshPositions(), sortable._trigger("activate", event, uiSortable))
                    })
            },
            stop: function (event, ui) {
                var inst = $(this).data("ui-draggable"),
                    uiSortable = $.extend({},
                        ui, {
                            item: inst.element
                        });
                $.each(inst.sortables,
                    function () {
                        this.instance.isOver ? (this.instance.isOver = 0, inst.cancelHelperRemoval = !0, this.instance.cancelHelperRemoval = !1, this.shouldRevert && (this.instance.options.revert = this.shouldRevert), this.instance._mouseStop(event), this.instance.options.helper = this.instance.options._helper, "original" === inst.options.helper && this.instance.currentItem.css({
                            top: "auto",
                            left: "auto"
                        })) : (this.instance.cancelHelperRemoval = !1, this.instance._trigger("deactivate", event, uiSortable))
                    })
            },
            drag: function (event, ui) {
                var inst = $(this).data("ui-draggable"),
                    that = this;
                $.each(inst.sortables,
                    function () {
                        var innermostIntersecting = !1,
                            thisSortable = this;
                        this.instance.positionAbs = inst.positionAbs,
                            this.instance.helperProportions = inst.helperProportions,
                            this.instance.offset.click = inst.offset.click,
                            this.instance._intersectsWith(this.instance.containerCache) && (innermostIntersecting = !0, $.each(inst.sortables,
                                function () {
                                    return this.instance.positionAbs = inst.positionAbs,
                                        this.instance.helperProportions = inst.helperProportions,
                                        this.instance.offset.click = inst.offset.click,
                                        this !== thisSortable && this.instance._intersectsWith(this.instance.containerCache) && $.contains(thisSortable.instance.element[0], this.instance.element[0]) && (innermostIntersecting = !1),
                                        innermostIntersecting
                                })),
                            innermostIntersecting ? (this.instance.isOver || (this.instance.isOver = 1, this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", !0), this.instance.options._helper = this.instance.options.helper, this.instance.options.helper = function () {
                                    return ui.helper[0]
                                },
                                event.target = this.instance.currentItem[0], this.instance._mouseCapture(event, !0), this.instance._mouseStart(event, !0, !0), this.instance.offset.click.top = inst.offset.click.top, this.instance.offset.click.left = inst.offset.click.left, this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left, this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top, inst._trigger("toSortable", event), inst.dropped = this.instance.element, inst.currentItem = inst.element, this.instance.fromOutside = inst), this.instance.currentItem && this.instance._mouseDrag(event)) : this.instance.isOver && (this.instance.isOver = 0, this.instance.cancelHelperRemoval = !0, this.instance.options.revert = !1, this.instance._trigger("out", event, this.instance._uiHash(this.instance)), this.instance._mouseStop(event, !0), this.instance.options.helper = this.instance.options._helper, this.instance.currentItem.remove(), this.instance.placeholder && this.instance.placeholder.remove(), inst._trigger("fromSortable", event), inst.dropped = !1)
                    })
            }
        }),
        $.ui.plugin.add("draggable", "cursor", {
            start: function () {
                var t = $("body"),
                    o = $(this).data("ui-draggable").options;
                t.css("cursor") && (o._cursor = t.css("cursor")),
                    t.css("cursor", o.cursor)
            },
            stop: function () {
                var o = $(this).data("ui-draggable").options;
                o._cursor && $("body").css("cursor", o._cursor)
            }
        }),
        $.ui.plugin.add("draggable", "opacity", {
            start: function (event, ui) {
                var t = $(ui.helper),
                    o = $(this).data("ui-draggable").options;
                t.css("opacity") && (o._opacity = t.css("opacity")),
                    t.css("opacity", o.opacity)
            },
            stop: function (event, ui) {
                var o = $(this).data("ui-draggable").options;
                o._opacity && $(ui.helper).css("opacity", o._opacity)
            }
        }),
        $.ui.plugin.add("draggable", "scroll", {
            start: function () {
                var i = $(this).data("ui-draggable");
                i.scrollParent[0] !== document && "HTML" !== i.scrollParent[0].tagName && (i.overflowOffset = i.scrollParent.offset())
            },
            drag: function (event) {
                var i = $(this).data("ui-draggable"),
                    o = i.options,
                    scrolled = !1;
                i.scrollParent[0] !== document && "HTML" !== i.scrollParent[0].tagName ? (o.axis && "x" === o.axis || (i.overflowOffset.top + i.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity ? i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed : event.pageY - i.overflowOffset.top < o.scrollSensitivity && (i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed)), o.axis && "y" === o.axis || (i.overflowOffset.left + i.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity ? i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed : event.pageX - i.overflowOffset.left < o.scrollSensitivity && (i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed))) : (o.axis && "x" === o.axis || (event.pageY - $(document).scrollTop() < o.scrollSensitivity ? scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed) : $(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity && (scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed))), o.axis && "y" === o.axis || (event.pageX - $(document).scrollLeft() < o.scrollSensitivity ? scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed) : $(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity && (scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed)))),
                    scrolled !== !1 && $.ui.ddmanager && !o.dropBehaviour && $.ui.ddmanager.prepareOffsets(i, event)
            }
        }),
        $.ui.plugin.add("draggable", "snap", {
            start: function () {
                var i = $(this).data("ui-draggable"),
                    o = i.options;
                i.snapElements = [],
                    $(o.snap.constructor !== String ? o.snap.items || ":data(ui-draggable)" : o.snap).each(function () {
                        var $t = $(this),
                            $o = $t.offset();
                        this !== i.element[0] && i.snapElements.push({
                            item: this,
                            width: $t.outerWidth(),
                            height: $t.outerHeight(),
                            top: $o.top,
                            left: $o.left
                        })
                    })
            },
            drag: function (event, ui) {
                var ts, bs, ls, rs, l, r, t, b, i, first, inst = $(this).data("ui-draggable"),
                    o = inst.options,
                    d = o.snapTolerance,
                    x1 = ui.offset.left,
                    x2 = x1 + inst.helperProportions.width,
                    y1 = ui.offset.top,
                    y2 = y1 + inst.helperProportions.height;
                for (i = inst.snapElements.length - 1; i >= 0; i--) l = inst.snapElements[i].left,
                    r = l + inst.snapElements[i].width,
                    t = inst.snapElements[i].top,
                    b = t + inst.snapElements[i].height,
                    l - d > x2 || x1 > r + d || t - d > y2 || y1 > b + d || !$.contains(inst.snapElements[i].item.ownerDocument, inst.snapElements[i].item) ? (inst.snapElements[i].snapping && inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), {
                        snapItem: inst.snapElements[i].item
                    })), inst.snapElements[i].snapping = !1) : ("inner" !== o.snapMode && (ts = Math.abs(t - y2) <= d, bs = Math.abs(b - y1) <= d, ls = Math.abs(l - x2) <= d, rs = Math.abs(r - x1) <= d, ts && (ui.position.top = inst._convertPositionTo("relative", {
                        top: t - inst.helperProportions.height,
                        left: 0
                    }).top - inst.margins.top), bs && (ui.position.top = inst._convertPositionTo("relative", {
                        top: b,
                        left: 0
                    }).top - inst.margins.top), ls && (ui.position.left = inst._convertPositionTo("relative", {
                        top: 0,
                        left: l - inst.helperProportions.width
                    }).left - inst.margins.left), rs && (ui.position.left = inst._convertPositionTo("relative", {
                        top: 0,
                        left: r
                    }).left - inst.margins.left)), first = ts || bs || ls || rs, "outer" !== o.snapMode && (ts = Math.abs(t - y1) <= d, bs = Math.abs(b - y2) <= d, ls = Math.abs(l - x1) <= d, rs = Math.abs(r - x2) <= d, ts && (ui.position.top = inst._convertPositionTo("relative", {
                        top: t,
                        left: 0
                    }).top - inst.margins.top), bs && (ui.position.top = inst._convertPositionTo("relative", {
                        top: b - inst.helperProportions.height,
                        left: 0
                    }).top - inst.margins.top), ls && (ui.position.left = inst._convertPositionTo("relative", {
                        top: 0,
                        left: l
                    }).left - inst.margins.left), rs && (ui.position.left = inst._convertPositionTo("relative", {
                        top: 0,
                        left: r - inst.helperProportions.width
                    }).left - inst.margins.left)), !inst.snapElements[i].snapping && (ts || bs || ls || rs || first) && inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), {
                        snapItem: inst.snapElements[i].item
                    })), inst.snapElements[i].snapping = ts || bs || ls || rs || first)
            }
        }),
        $.ui.plugin.add("draggable", "stack", {
            start: function () {
                var min, o = this.data("ui-draggable").options,
                    group = $.makeArray($(o.stack)).sort(function (a, b) {
                        return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0)
                    });
                group.length && (min = parseInt($(group[0]).css("zIndex"), 10) || 0, $(group).each(function (i) {
                    $(this).css("zIndex", min + i)
                }), this.css("zIndex", min + group.length))
            }
        }),
        $.ui.plugin.add("draggable", "zIndex", {
            start: function (event, ui) {
                var t = $(ui.helper),
                    o = $(this).data("ui-draggable").options;
                t.css("zIndex") && (o._zIndex = t.css("zIndex")),
                    t.css("zIndex", o.zIndex)
            },
            stop: function (event, ui) {
                var o = $(this).data("ui-draggable").options;
                o._zIndex && $(ui.helper).css("zIndex", o._zIndex)
            }
        })
}(jQuery),
function ($) {
    function isOverAxis(x, reference, size) {
        return x > reference && reference + size > x
    }

    function isFloating(item) {
        return /left|right/.test(item.css("float")) || /inline|table-cell/.test(item.css("display"))
    }
    $.widget("ui.sortable", $.ui.mouse, {
        version: "1.10.3",
        widgetEventPrefix: "sort",
        ready: !1,
        options: {
            appendTo: "parent",
            axis: !1,
            connectWith: !1,
            containment: !1,
            cursor: "auto",
            cursorAt: !1,
            dropOnEmpty: !0,
            forcePlaceholderSize: !1,
            forceHelperSize: !1,
            grid: !1,
            handle: !1,
            helper: "original",
            items: "> *",
            opacity: !1,
            placeholder: !1,
            revert: !1,
            scroll: !0,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            scope: "default",
            tolerance: "intersect",
            zIndex: 1e3,
            activate: null,
            beforeStop: null,
            change: null,
            deactivate: null,
            out: null,
            over: null,
            receive: null,
            remove: null,
            sort: null,
            start: null,
            stop: null,
            update: null
        },
        _create: function () {
            var o = this.options;
            this.containerCache = {},
                this.element.addClass("ui-sortable"),
                this.refresh(),
                this.floating = this.items.length ? "x" === o.axis || isFloating(this.items[0].item) : !1,
                this.offset = this.element.offset(),
                this._mouseInit(),
                this.ready = !0
        },
        _destroy: function () {
            this.element.removeClass("ui-sortable ui-sortable-disabled"),
                this._mouseDestroy();
            for (var i = this.items.length - 1; i >= 0; i--) this.items[i].item.removeData(this.widgetName + "-item");
            return this
        },
        _setOption: function (key, value) {
            "disabled" === key ? (this.options[key] = value, this.widget().toggleClass("ui-sortable-disabled", !!value)) : $.Widget.prototype._setOption.apply(this, arguments)
        },
        _mouseCapture: function (event, overrideHandle) {
            var currentItem = null,
                validHandle = !1,
                that = this;
            return this.reverting ? !1 : this.options.disabled || "static" === this.options.type ? !1 : (this._refreshItems(event), $(event.target).parents().each(function () {
                return $.data(this, that.widgetName + "-item") === that ? (currentItem = $(this), !1) : void 0
            }), $.data(event.target, that.widgetName + "-item") === that && (currentItem = $(event.target)), currentItem ? !this.options.handle || overrideHandle || ($(this.options.handle, currentItem).find("*").addBack().each(function () {
                this === event.target && (validHandle = !0)
            }), validHandle) ? (this.currentItem = currentItem, this._removeCurrentsFromItems(), !0) : !1 : !1)
        },
        _mouseStart: function (event, overrideHandle, noActivation) {
            var i, body, o = this.options;
            if (this.currentContainer = this, this.refreshPositions(), this.helper = this._createHelper(event), this._cacheHelperProportions(), this._cacheMargins(), this.scrollParent = this.helper.scrollParent(), this.offset = this.currentItem.offset(), this.offset = {
                    top: this.offset.top - this.margins.top,
                    left: this.offset.left - this.margins.left
                },
                $.extend(this.offset, {
                    click: {
                        left: event.pageX - this.offset.left,
                        top: event.pageY - this.offset.top
                    },
                    parent: this._getParentOffset(),
                    relative: this._getRelativeOffset()
                }), this.helper.css("position", "absolute"), this.cssPosition = this.helper.css("position"), this.originalPosition = this._generatePosition(event), this.originalPageX = event.pageX, this.originalPageY = event.pageY, o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt), this.domPosition = {
                    prev: this.currentItem.prev()[0],
                    parent: this.currentItem.parent()[0]
                },
                this.helper[0] !== this.currentItem[0] && this.currentItem.hide(), this._createPlaceholder(), o.containment && this._setContainment(), o.cursor && "auto" !== o.cursor && (body = this.document.find("body"), this.storedCursor = body.css("cursor"), body.css("cursor", o.cursor), this.storedStylesheet = $("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(body)), o.opacity && (this.helper.css("opacity") && (this._storedOpacity = this.helper.css("opacity")), this.helper.css("opacity", o.opacity)), o.zIndex && (this.helper.css("zIndex") && (this._storedZIndex = this.helper.css("zIndex")), this.helper.css("zIndex", o.zIndex)), this.scrollParent[0] !== document && "HTML" !== this.scrollParent[0].tagName && (this.overflowOffset = this.scrollParent.offset()), this._trigger("start", event, this._uiHash()), this._preserveHelperProportions || this._cacheHelperProportions(), !noActivation)
                for (i = this.containers.length - 1; i >= 0; i--) this.containers[i]._trigger("activate", event, this._uiHash(this));
            return $.ui.ddmanager && ($.ui.ddmanager.current = this),
                $.ui.ddmanager && !o.dropBehaviour && $.ui.ddmanager.prepareOffsets(this, event),
                this.dragging = !0,
                this.helper.addClass("ui-sortable-helper"),
                this._mouseDrag(event), !0
        },
        _mouseDrag: function (event) {
            var i, item, itemElement, intersection, o = this.options,
                scrolled = !1;
            for (this.position = this._generatePosition(event), this.positionAbs = this._convertPositionTo("absolute"), this.lastPositionAbs || (this.lastPositionAbs = this.positionAbs), this.options.scroll && (this.scrollParent[0] !== document && "HTML" !== this.scrollParent[0].tagName ? (this.overflowOffset.top + this.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity ? this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed : event.pageY - this.overflowOffset.top < o.scrollSensitivity && (this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed), this.overflowOffset.left + this.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity ? this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed : event.pageX - this.overflowOffset.left < o.scrollSensitivity && (this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed)) : (event.pageY - $(document).scrollTop() < o.scrollSensitivity ? scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed) : $(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity && (scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed)), event.pageX - $(document).scrollLeft() < o.scrollSensitivity ? scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed) : $(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity && (scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed))), scrolled !== !1 && $.ui.ddmanager && !o.dropBehaviour && $.ui.ddmanager.prepareOffsets(this, event)), this.positionAbs = this._convertPositionTo("absolute"), this.options.axis && "y" === this.options.axis || (this.helper[0].style.left = this.position.left + "px"), this.options.axis && "x" === this.options.axis || (this.helper[0].style.top = this.position.top + "px"), i = this.items.length - 1; i >= 0; i--)
                if (item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item), intersection && item.instance === this.currentContainer && itemElement !== this.currentItem[0] && this.placeholder[1 === intersection ? "next" : "prev"]()[0] !== itemElement && !$.contains(this.placeholder[0], itemElement) && ("semi-dynamic" === this.options.type ? !$.contains(this.element[0], itemElement) : !0)) {
                    if (this.direction = 1 === intersection ? "down" : "up", "pointer" !== this.options.tolerance && !this._intersectsWithSides(item)) break;
                    this._rearrange(event, item),
                        this._trigger("change", event, this._uiHash());
                    break
                }
            return this._contactContainers(event),
                $.ui.ddmanager && $.ui.ddmanager.drag(this, event),
                this._trigger("sort", event, this._uiHash()),
                this.lastPositionAbs = this.positionAbs, !1
        },
        _mouseStop: function (event, noPropagation) {
            if (event) {
                if ($.ui.ddmanager && !this.options.dropBehaviour && $.ui.ddmanager.drop(this, event), this.options.revert) {
                    var that = this,
                        cur = this.placeholder.offset(),
                        axis = this.options.axis,
                        animation = {};
                    axis && "x" !== axis || (animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft)),
                        axis && "y" !== axis || (animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop)),
                        this.reverting = !0,
                        $(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500,
                            function () {
                                that._clear(event)
                            })
                } else this._clear(event, noPropagation);
                return !1
            }
        },
        cancel: function () {
            if (this.dragging) {
                this._mouseUp({
                        target: null
                    }),
                    "original" === this.options.helper ? this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper") : this.currentItem.show();
                for (var i = this.containers.length - 1; i >= 0; i--) this.containers[i]._trigger("deactivate", null, this._uiHash(this)),
                    this.containers[i].containerCache.over && (this.containers[i]._trigger("out", null, this._uiHash(this)), this.containers[i].containerCache.over = 0)
            }
            return this.placeholder && (this.placeholder[0].parentNode && this.placeholder[0].parentNode.removeChild(this.placeholder[0]), "original" !== this.options.helper && this.helper && this.helper[0].parentNode && this.helper.remove(), $.extend(this, {
                    helper: null,
                    dragging: !1,
                    reverting: !1,
                    _noFinalSort: null
                }), this.domPosition.prev ? $(this.domPosition.prev).after(this.currentItem) : $(this.domPosition.parent).prepend(this.currentItem)),
                this
        },
        serialize: function (o) {
            var items = this._getItemsAsjQuery(o && o.connected),
                str = [];
            return o = o || {},
                $(items).each(function () {
                    var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || /(.+)[\-=_](.+)/);
                    res && str.push((o.key || res[1] + "[]") + "=" + (o.key && o.expression ? res[1] : res[2]))
                }), !str.length && o.key && str.push(o.key + "="),
                str.join("&")
        },
        toArray: function (o) {
            var items = this._getItemsAsjQuery(o && o.connected),
                ret = [];
            return o = o || {},
                items.each(function () {
                    ret.push($(o.item || this).attr(o.attribute || "id") || "")
                }),
                ret
        },
        _intersectsWith: function (item) {
            var x1 = this.positionAbs.left,
                x2 = x1 + this.helperProportions.width,
                y1 = this.positionAbs.top,
                y2 = y1 + this.helperProportions.height,
                l = item.left,
                r = l + item.width,
                t = item.top,
                b = t + item.height,
                dyClick = this.offset.click.top,
                dxClick = this.offset.click.left,
                isOverElementHeight = "x" === this.options.axis || y1 + dyClick > t && b > y1 + dyClick,
                isOverElementWidth = "y" === this.options.axis || x1 + dxClick > l && r > x1 + dxClick,
                isOverElement = isOverElementHeight && isOverElementWidth;
            return "pointer" === this.options.tolerance || this.options.forcePointerForContainers || "pointer" !== this.options.tolerance && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"] ? isOverElement : l < x1 + this.helperProportions.width / 2 && x2 - this.helperProportions.width / 2 < r && t < y1 + this.helperProportions.height / 2 && y2 - this.helperProportions.height / 2 < b
        },
        _intersectsWithPointer: function (item) {
            var isOverElementHeight = "x" === this.options.axis || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
                isOverElementWidth = "y" === this.options.axis || isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
                isOverElement = isOverElementHeight && isOverElementWidth,
                verticalDirection = this._getDragVerticalDirection(),
                horizontalDirection = this._getDragHorizontalDirection();
            return isOverElement ? this.floating ? horizontalDirection && "right" === horizontalDirection || "down" === verticalDirection ? 2 : 1 : verticalDirection && ("down" === verticalDirection ? 2 : 1) : !1
        },
        _intersectsWithSides: function (item) {
            var isOverBottomHalf = isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + item.height / 2, item.height),
                isOverRightHalf = isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + item.width / 2, item.width),
                verticalDirection = this._getDragVerticalDirection(),
                horizontalDirection = this._getDragHorizontalDirection();
            return this.floating && horizontalDirection ? "right" === horizontalDirection && isOverRightHalf || "left" === horizontalDirection && !isOverRightHalf : verticalDirection && ("down" === verticalDirection && isOverBottomHalf || "up" === verticalDirection && !isOverBottomHalf)
        },
        _getDragVerticalDirection: function () {
            var delta = this.positionAbs.top - this.lastPositionAbs.top;
            return 0 !== delta && (delta > 0 ? "down" : "up")
        },
        _getDragHorizontalDirection: function () {
            var delta = this.positionAbs.left - this.lastPositionAbs.left;
            return 0 !== delta && (delta > 0 ? "right" : "left")
        },
        refresh: function (event) {
            return this._refreshItems(event),
                this.refreshPositions(),
                this
        },
        _connectWith: function () {
            var options = this.options;
            return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith
        },
        _getItemsAsjQuery: function (connected) {
            var i, j, cur, inst, items = [],
                queries = [],
                connectWith = this._connectWith();
            if (connectWith && connected)
                for (i = connectWith.length - 1; i >= 0; i--)
                    for (cur = $(connectWith[i]), j = cur.length - 1; j >= 0; j--) inst = $.data(cur[j], this.widgetFullName),
                        inst && inst !== this && !inst.options.disabled && queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
            for (queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
                    options: this.options,
                    item: this.currentItem
                }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]), i = queries.length - 1; i >= 0; i--) queries[i][0].each(function () {
                items.push(this)
            });
            return $(items)
        },
        _removeCurrentsFromItems: function () {
            var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
            this.items = $.grep(this.items,
                function (item) {
                    for (var j = 0; j < list.length; j++)
                        if (list[j] === item.item[0]) return !1;
                    return !0
                })
        },
        _refreshItems: function (event) {
            this.items = [],
                this.containers = [this];
            var i, j, cur, inst, targetData, _queries, item, queriesLength, items = this.items,
                queries = [
                    [$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, {
                        item: this.currentItem
                    }) : $(this.options.items, this.element), this]
                ],
                connectWith = this._connectWith();
            if (connectWith && this.ready)
                for (i = connectWith.length - 1; i >= 0; i--)
                    for (cur = $(connectWith[i]), j = cur.length - 1; j >= 0; j--) inst = $.data(cur[j], this.widgetFullName),
                        inst && inst !== this && !inst.options.disabled && (queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, {
                            item: this.currentItem
                        }) : $(inst.options.items, inst.element), inst]), this.containers.push(inst));
            for (i = queries.length - 1; i >= 0; i--)
                for (targetData = queries[i][1], _queries = queries[i][0], j = 0, queriesLength = _queries.length; queriesLength > j; j++) item = $(_queries[j]),
                    item.data(this.widgetName + "-item", targetData),
                    items.push({
                        item: item,
                        instance: targetData,
                        width: 0,
                        height: 0,
                        left: 0,
                        top: 0
                    })
        },
        refreshPositions: function (fast) {
            this.offsetParent && this.helper && (this.offset.parent = this._getParentOffset());
            var i, item, t, p;
            for (i = this.items.length - 1; i >= 0; i--) item = this.items[i],
                item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0] || (t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item, fast || (item.width = t.outerWidth(), item.height = t.outerHeight()), p = t.offset(), item.left = p.left, item.top = p.top);
            if (this.options.custom && this.options.custom.refreshContainers) this.options.custom.refreshContainers.call(this);
            else
                for (i = this.containers.length - 1; i >= 0; i--) p = this.containers[i].element.offset(),
                    this.containers[i].containerCache.left = p.left,
                    this.containers[i].containerCache.top = p.top,
                    this.containers[i].containerCache.width = this.containers[i].element.outerWidth(),
                    this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
            return this
        },
        _createPlaceholder: function (that) {
            that = that || this;
            var className, o = that.options;
            o.placeholder && o.placeholder.constructor !== String || (className = o.placeholder, o.placeholder = {
                    element: function () {
                        var nodeName = that.currentItem[0].nodeName.toLowerCase(),
                            element = $("<" + nodeName + ">", that.document[0]).addClass(className || that.currentItem[0].className + " ui-sortable-placeholder").removeClass("ui-sortable-helper");
                        return "tr" === nodeName ? that.currentItem.children().each(function () {
                                $("<td>&#160;</td>", that.document[0]).attr("colspan", $(this).attr("colspan") || 1).appendTo(element)
                            }) : "img" === nodeName && element.attr("src", that.currentItem.attr("src")),
                            className || element.css("visibility", "hidden"),
                            element
                    },
                    update: function (container, p) {
                        (!className || o.forcePlaceholderSize) && (p.height() || p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop") || 0, 10) - parseInt(that.currentItem.css("paddingBottom") || 0, 10)), p.width() || p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft") || 0, 10) - parseInt(that.currentItem.css("paddingRight") || 0, 10)))
                    }
                }),
                that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem)),
                that.currentItem.after(that.placeholder),
                o.placeholder.update(that, that.placeholder)
        },
        _contactContainers: function (event) {
            var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, base, cur, nearBottom, floating, innermostContainer = null,
                innermostIndex = null;
            for (i = this.containers.length - 1; i >= 0; i--)
                if (!$.contains(this.currentItem[0], this.containers[i].element[0]))
                    if (this._intersectsWith(this.containers[i].containerCache)) {
                        if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) continue;
                        innermostContainer = this.containers[i],
                            innermostIndex = i
                    } else this.containers[i].containerCache.over && (this.containers[i]._trigger("out", event, this._uiHash(this)), this.containers[i].containerCache.over = 0);
            if (innermostContainer)
                if (1 === this.containers.length) this.containers[innermostIndex].containerCache.over || (this.containers[innermostIndex]._trigger("over", event, this._uiHash(this)), this.containers[innermostIndex].containerCache.over = 1);
                else {
                    for (dist = 1e4, itemWithLeastDistance = null, floating = innermostContainer.floating || isFloating(this.currentItem), posProperty = floating ? "left" : "top", sizeProperty = floating ? "width" : "height", base = this.positionAbs[posProperty] + this.offset.click[posProperty], j = this.items.length - 1; j >= 0; j--) $.contains(this.containers[innermostIndex].element[0], this.items[j].item[0]) && this.items[j].item[0] !== this.currentItem[0] && (!floating || isOverAxis(this.positionAbs.top + this.offset.click.top, this.items[j].top, this.items[j].height)) && (cur = this.items[j].item.offset()[posProperty], nearBottom = !1, Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base) && (nearBottom = !0, cur += this.items[j][sizeProperty]), Math.abs(cur - base) < dist && (dist = Math.abs(cur - base), itemWithLeastDistance = this.items[j], this.direction = nearBottom ? "up" : "down"));
                    if (!itemWithLeastDistance && !this.options.dropOnEmpty) return;
                    if (this.currentContainer === this.containers[innermostIndex]) return;
                    itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, !0) : this._rearrange(event, null, this.containers[innermostIndex].element, !0),
                        this._trigger("change", event, this._uiHash()),
                        this.containers[innermostIndex]._trigger("change", event, this._uiHash(this)),
                        this.currentContainer = this.containers[innermostIndex],
                        this.options.placeholder.update(this.currentContainer, this.placeholder),
                        this.containers[innermostIndex]._trigger("over", event, this._uiHash(this)),
                        this.containers[innermostIndex].containerCache.over = 1
                }
        },
        _createHelper: function (event) {
            var o = this.options,
                helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : "clone" === o.helper ? this.currentItem.clone() : this.currentItem;
            return helper.parents("body").length || $("parent" !== o.appendTo ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]),
                helper[0] === this.currentItem[0] && (this._storedCSS = {
                    width: this.currentItem[0].style.width,
                    height: this.currentItem[0].style.height,
                    position: this.currentItem.css("position"),
                    top: this.currentItem.css("top"),
                    left: this.currentItem.css("left")
                }),
                (!helper[0].style.width || o.forceHelperSize) && helper.width(this.currentItem.width()),
                (!helper[0].style.height || o.forceHelperSize) && helper.height(this.currentItem.height()),
                helper
        },
        _adjustOffsetFromHelper: function (obj) {
            "string" == typeof obj && (obj = obj.split(" ")),
                $.isArray(obj) && (obj = {
                    left: +obj[0],
                    top: +obj[1] || 0
                }),
                "left" in obj && (this.offset.click.left = obj.left + this.margins.left),
                "right" in obj && (this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left),
                "top" in obj && (this.offset.click.top = obj.top + this.margins.top),
                "bottom" in obj && (this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top)
        },
        _getParentOffset: function () {
            this.offsetParent = this.helper.offsetParent();
            var po = this.offsetParent.offset();
            return "absolute" === this.cssPosition && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]) && (po.left += this.scrollParent.scrollLeft(), po.top += this.scrollParent.scrollTop()),
                (this.offsetParent[0] === document.body || this.offsetParent[0].tagName && "html" === this.offsetParent[0].tagName.toLowerCase() && $.ui.ie) && (po = {
                    top: 0,
                    left: 0
                }), {
                    top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                    left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
                }
        },
        _getRelativeOffset: function () {
            if ("relative" === this.cssPosition) {
                var p = this.currentItem.position();
                return {
                    top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                    left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                }
            }
            return {
                top: 0,
                left: 0
            }
        },
        _cacheMargins: function () {
            this.margins = {
                left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
                top: parseInt(this.currentItem.css("marginTop"), 10) || 0
            }
        },
        _cacheHelperProportions: function () {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            }
        },
        _setContainment: function () {
            var ce, co, over, o = this.options;
            "parent" === o.containment && (o.containment = this.helper[0].parentNode),
                ("document" === o.containment || "window" === o.containment) && (this.containment = [0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, $("document" === o.containment ? document : window).width() - this.helperProportions.width - this.margins.left, ($("document" === o.containment ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top]),
                /^(document|window|parent)$/.test(o.containment) || (ce = $(o.containment)[0], co = $(o.containment).offset(), over = "hidden" !== $(ce).css("overflow"), this.containment = [co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0) - this.margins.left, co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top, co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top])
        },
        _convertPositionTo: function (d, pos) {
            pos || (pos = this.position);
            var mod = "absolute" === d ? 1 : -1,
                scroll = "absolute" !== this.cssPosition || this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent,
                scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
            return {
                top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()) * mod,
                left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod
            }
        },
        _generatePosition: function (event) {
            var top, left, o = this.options,
                pageX = event.pageX,
                pageY = event.pageY,
                scroll = "absolute" !== this.cssPosition || this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent,
                scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
            return "relative" !== this.cssPosition || this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0] || (this.offset.relative = this._getRelativeOffset()),
                this.originalPosition && (this.containment && (event.pageX - this.offset.click.left < this.containment[0] && (pageX = this.containment[0] + this.offset.click.left), event.pageY - this.offset.click.top < this.containment[1] && (pageY = this.containment[1] + this.offset.click.top), event.pageX - this.offset.click.left > this.containment[2] && (pageX = this.containment[2] + this.offset.click.left), event.pageY - this.offset.click.top > this.containment[3] && (pageY = this.containment[3] + this.offset.click.top)), o.grid && (top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1], pageY = this.containment ? top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3] ? top : top - this.offset.click.top >= this.containment[1] ? top - o.grid[1] : top + o.grid[1] : top, left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0], pageX = this.containment ? left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2] ? left : left - this.offset.click.left >= this.containment[0] ? left - o.grid[0] : left + o.grid[0] : left)), {
                    top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()),
                    left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft())
                }
        },
        _rearrange: function (event, i, a, hardRefresh) {
            a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], "down" === this.direction ? i.item[0] : i.item[0].nextSibling),
                this.counter = this.counter ? ++this.counter : 1;
            var counter = this.counter;
            this._delay(function () {
                counter === this.counter && this.refreshPositions(!hardRefresh)
            })
        },
        _clear: function (event, noPropagation) {
            this.reverting = !1;
            var i, delayedTriggers = [];
            if (!this._noFinalSort && this.currentItem.parent().length && this.placeholder.before(this.currentItem), this._noFinalSort = null, this.helper[0] === this.currentItem[0]) {
                for (i in this._storedCSS)("auto" === this._storedCSS[i] || "static" === this._storedCSS[i]) && (this._storedCSS[i] = "");
                this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")
            } else this.currentItem.show();
            for (this.fromOutside && !noPropagation && delayedTriggers.push(function (event) {
                    this._trigger("receive", event, this._uiHash(this.fromOutside))
                }), !this.fromOutside && this.domPosition.prev === this.currentItem.prev().not(".ui-sortable-helper")[0] && this.domPosition.parent === this.currentItem.parent()[0] || noPropagation || delayedTriggers.push(function (event) {
                    this._trigger("update", event, this._uiHash())
                }), this !== this.currentContainer && (noPropagation || (delayedTriggers.push(function (event) {
                    this._trigger("remove", event, this._uiHash())
                }), delayedTriggers.push(function (c) {
                    return function (event) {
                        c._trigger("receive", event, this._uiHash(this))
                    }
                }.call(this, this.currentContainer)), delayedTriggers.push(function (c) {
                    return function (event) {
                        c._trigger("update", event, this._uiHash(this))
                    }
                }.call(this, this.currentContainer)))), i = this.containers.length - 1; i >= 0; i--) noPropagation || delayedTriggers.push(function (c) {
                    return function (event) {
                        c._trigger("deactivate", event, this._uiHash(this))
                    }
                }.call(this, this.containers[i])),
                this.containers[i].containerCache.over && (delayedTriggers.push(function (c) {
                    return function (event) {
                        c._trigger("out", event, this._uiHash(this))
                    }
                }.call(this, this.containers[i])), this.containers[i].containerCache.over = 0);
            if (this.storedCursor && (this.document.find("body").css("cursor", this.storedCursor), this.storedStylesheet.remove()), this._storedOpacity && this.helper.css("opacity", this._storedOpacity), this._storedZIndex && this.helper.css("zIndex", "auto" === this._storedZIndex ? "" : this._storedZIndex), this.dragging = !1, this.cancelHelperRemoval) {
                if (!noPropagation) {
                    for (this._trigger("beforeStop", event, this._uiHash()), i = 0; i < delayedTriggers.length; i++) delayedTriggers[i].call(this, event);
                    this._trigger("stop", event, this._uiHash())
                }
                return this.fromOutside = !1, !1
            }
            if (noPropagation || this._trigger("beforeStop", event, this._uiHash()), this.placeholder[0].parentNode.removeChild(this.placeholder[0]), this.helper[0] !== this.currentItem[0] && this.helper.remove(), this.helper = null, !noPropagation) {
                for (i = 0; i < delayedTriggers.length; i++) delayedTriggers[i].call(this, event);
                this._trigger("stop", event, this._uiHash())
            }
            return this.fromOutside = !1, !0
        },
        _trigger: function () {
            $.Widget.prototype._trigger.apply(this, arguments) === !1 && this.cancel()
        },
        _uiHash: function (_inst) {
            var inst = _inst || this;
            return {
                helper: inst.helper,
                placeholder: inst.placeholder || $([]),
                position: inst.position,
                originalPosition: inst.originalPosition,
                offset: inst.positionAbs,
                item: inst.currentItem,
                sender: _inst ? _inst.element : null
            }
        }
    })
}(jQuery),
function () {
    var window = this;
    if (!window.localStorage) {
        if (window.globalStorage) {
            try {
                window.localStorage = window.globalStorage
            } catch (e) {}
            return
        }
        var div = document.createElement("div"),
            attrKey = "localStorage";
        if (div.style.display = "none", document.getElementsByTagName("head")[0].appendChild(div), div.addBehavior) {
            div.addBehavior("#default#userdata");
            var localStorage = window.localStorage = {
                    length: 0,
                    setItem: function (key, value) {
                        div.load(attrKey),
                            key = cleanKey(key),
                            div.getAttribute(key) || this.length++,
                            div.setAttribute(key, value),
                            div.save(attrKey)
                    },
                    getItem: function (key) {
                        return div.load(attrKey),
                            key = cleanKey(key),
                            div.getAttribute(key)
                    },
                    removeItem: function (key) {
                        div.load(attrKey),
                            key = cleanKey(key),
                            div.removeAttribute(key),
                            div.save(attrKey),
                            this.length--,
                            this.length < 0 && (this.length = 0)
                    },
                    clear: function () {
                        div.load(attrKey);
                        for (var i = 0; attr = div.XMLDocument.documentElement.attributes[i++];) div.removeAttribute(attr.name);
                        div.save(attrKey),
                            this.length = 0
                    },
                    key: function (key) {
                        return div.load(attrKey),
                            div.XMLDocument.documentElement.attributes[key]
                    }
                },
                cleanKey = function (key) {
                    return key.replace(/[^-._0-9A-Za-z·À-ÖØ-öø-ͽ\u37f-῿‌-‍‿⁀⁰-↏]/g, "-")
                };
            div.load(attrKey),
                localStorage.length = div.XMLDocument.documentElement.attributes.length
        }
    }
}(),
function (window, document, undefined) {
    "use strict";

    function minErr(module) {
        return function () {
            var message, i, code = arguments[0],
                prefix = "[" + (module ? module + ":" : "") + code + "] ",
                template = arguments[1],
                templateArgs = arguments,
                stringify = function (obj) {
                    return "function" == typeof obj ? obj.toString().replace(/ \{[\s\S]*$/, "") : "undefined" == typeof obj ? "undefined" : "string" != typeof obj ? JSON.stringify(obj) : obj
                };
            for (message = prefix + template.replace(/\{\d+\}/g,
                    function (match) {
                        var arg, index = +match.slice(1, -1);
                        return index + 2 < templateArgs.length ? (arg = templateArgs[index + 2], "function" == typeof arg ? arg.toString().replace(/ ?\{[\s\S]*$/, "") : "undefined" == typeof arg ? "undefined" : "string" != typeof arg ? toJson(arg) : arg) : match
                    }), message = message + "\nhttp://errors.angularjs.org/1.2.4/" + (module ? module + "/" : "") + code, i = 2; i < arguments.length; i++) message = message + (2 == i ? "?" : "&") + "p" + (i - 2) + "=" + encodeURIComponent(stringify(arguments[i]));
            return new Error(message)
        }
    }

    function isArrayLike(obj) {
        if (null == obj || isWindow(obj)) return !1;
        var length = obj.length;
        return 1 === obj.nodeType && length ? !0 : isString(obj) || isArray(obj) || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj
    }

    function forEach(obj, iterator, context) {
        var key;
        if (obj)
            if (isFunction(obj))
                for (key in obj) "prototype" != key && "length" != key && "name" != key && obj.hasOwnProperty(key) && iterator.call(context, obj[key], key);
            else if (obj.forEach && obj.forEach !== forEach) obj.forEach(iterator, context);
        else if (isArrayLike(obj))
            for (key = 0; key < obj.length; key++) iterator.call(context, obj[key], key);
        else
            for (key in obj) obj.hasOwnProperty(key) && iterator.call(context, obj[key], key);
        return obj
    }

    function sortedKeys(obj) {
        var keys = [];
        for (var key in obj) obj.hasOwnProperty(key) && keys.push(key);
        return keys.sort()
    }

    function forEachSorted(obj, iterator, context) {
        for (var keys = sortedKeys(obj), i = 0; i < keys.length; i++) iterator.call(context, obj[keys[i]], keys[i]);
        return keys
    }

    function reverseParams(iteratorFn) {
        return function (value, key) {
            iteratorFn(key, value)
        }
    }

    function nextUid() {
        for (var digit, index = uid.length; index;) {
            if (index--, digit = uid[index].charCodeAt(0), 57 == digit) return uid[index] = "A",
                uid.join("");
            if (90 != digit) return uid[index] = String.fromCharCode(digit + 1),
                uid.join("");
            uid[index] = "0"
        }
        return uid.unshift("0"),
            uid.join("")
    }

    function setHashKey(obj, h) {
        h ? obj.$$hashKey = h : delete obj.$$hashKey
    }

    function extend(dst) {
        var h = dst.$$hashKey;
        return forEach(arguments,
                function (obj) {
                    obj !== dst && forEach(obj,
                        function (value, key) {
                            dst[key] = value
                        })
                }),
            setHashKey(dst, h),
            dst
    }

    function int(str) {
        return parseInt(str, 10)
    }

    function inherit(parent, extra) {
        return extend(new(extend(function () {}, {
            prototype: parent
        })), extra)
    }

    function noop() {}

    function identity($) {
        return $
    }

    function valueFn(value) {
        return function () {
            return value
        }
    }

    function isUndefined(value) {
        return "undefined" == typeof value
    }

    function isDefined(value) {
        return "undefined" != typeof value
    }

    function isObject(value) {
        return null != value && "object" == typeof value
    }

    function isString(value) {
        return "string" == typeof value
    }

    function isNumber(value) {
        return "number" == typeof value
    }

    function isDate(value) {
        return "[object Date]" == toString.apply(value)
    }

    function isArray(value) {
        return "[object Array]" == toString.apply(value)
    }

    function isFunction(value) {
        return "function" == typeof value
    }

    function isRegExp(value) {
        return "[object RegExp]" == toString.apply(value)
    }

    function isWindow(obj) {
        return obj && obj.document && obj.location && obj.alert && obj.setInterval
    }

    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch
    }

    function isFile(obj) {
        return "[object File]" === toString.apply(obj)
    }

    function isElement(node) {
        return !(!node || !(node.nodeName || node.on && node.find))
    }

    function map(obj, iterator, context) {
        var results = [];
        return forEach(obj,
                function (value, index, list) {
                    results.push(iterator.call(context, value, index, list))
                }),
            results
    }

    function includes(array, obj) {
        return -1 != indexOf(array, obj)
    }

    function indexOf(array, obj) {
        if (array.indexOf) return array.indexOf(obj);
        for (var i = 0; i < array.length; i++)
            if (obj === array[i]) return i;
        return -1
    }

    function arrayRemove(array, value) {
        var index = indexOf(array, value);
        return index >= 0 && array.splice(index, 1),
            value
    }

    function copy(source, destination) {
        if (isWindow(source) || isScope(source)) throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
        if (destination) {
            if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
            if (isArray(source)) {
                destination.length = 0;
                for (var i = 0; i < source.length; i++) destination.push(copy(source[i]))
            } else {
                var h = destination.$$hashKey;
                forEach(destination,
                    function (value, key) {
                        delete destination[key]
                    });
                for (var key in source) destination[key] = copy(source[key]);
                setHashKey(destination, h)
            }
        } else destination = source,
            source && (isArray(source) ? destination = copy(source, []) : isDate(source) ? destination = new Date(source.getTime()) : isRegExp(source) ? destination = new RegExp(source.source) : isObject(source) && (destination = copy(source, {})));
        return destination
    }

    function shallowCopy(src, dst) {
        dst = dst || {};
        for (var key in src) src.hasOwnProperty(key) && "$$" !== key.substr(0, 2) && (dst[key] = src[key]);
        return dst
    }

    function equals(o1, o2) {
        if (o1 === o2) return !0;
        if (null === o1 || null === o2) return !1;
        if (o1 !== o1 && o2 !== o2) return !0;
        var length, key, keySet, t1 = typeof o1,
            t2 = typeof o2;
        if (t1 == t2 && "object" == t1) {
            if (!isArray(o1)) {
                if (isDate(o1)) return isDate(o2) && o1.getTime() == o2.getTime();
                if (isRegExp(o1) && isRegExp(o2)) return o1.toString() == o2.toString();
                if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2)) return !1;
                keySet = {};
                for (key in o1)
                    if ("$" !== key.charAt(0) && !isFunction(o1[key])) {
                        if (!equals(o1[key], o2[key])) return !1;
                        keySet[key] = !0
                    }
                for (key in o2)
                    if (!keySet.hasOwnProperty(key) && "$" !== key.charAt(0) && o2[key] !== undefined && !isFunction(o2[key])) return !1;
                return !0
            }
            if (!isArray(o2)) return !1;
            if ((length = o1.length) == o2.length) {
                for (key = 0; length > key; key++)
                    if (!equals(o1[key], o2[key])) return !1;
                return !0
            }
        }
        return !1
    }

    function csp() {
        return document.securityPolicy && document.securityPolicy.isActive || document.querySelector && !(!document.querySelector("[ng-csp]") && !document.querySelector("[data-ng-csp]"))
    }

    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index))
    }

    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0)
    }

    function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        return !isFunction(fn) || fn instanceof RegExp ? fn : curryArgs.length ?
            function () {
                return arguments.length ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0))) : fn.apply(self, curryArgs)
            } : function () {
                return arguments.length ? fn.apply(self, arguments) : fn.call(self)
            }
    }

    function toJsonReplacer(key, value) {
        var val = value;
        return "string" == typeof key && "$" === key.charAt(0) ? val = undefined : isWindow(value) ? val = "$WINDOW" : value && document === value ? val = "$DOCUMENT" : isScope(value) && (val = "$SCOPE"),
            val
    }

    function toJson(obj, pretty) {
        return "undefined" == typeof obj ? undefined : JSON.stringify(obj, toJsonReplacer, pretty ? "  " : null)
    }

    function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json
    }

    function toBoolean(value) {
        if (value && 0 !== value.length) {
            var v = lowercase("" + value);
            value = !("f" == v || "0" == v || "false" == v || "no" == v || "n" == v || "[]" == v)
        } else value = !1;
        return value
    }

    function startingTag(element) {
        element = jqLite(element).clone();
        try {
            element.html("")
        } catch (e) {}
        var TEXT_NODE = 3,
            elemHtml = jqLite("<div>").append(element).html();
        try {
            return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/,
                function (match, nodeName) {
                    return "<" + lowercase(nodeName)
                })
        } catch (e) {
            return lowercase(elemHtml)
        }
    }

    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value)
        } catch (e) {}
    }

    function parseKeyValue(keyValue) {
        var key_value, key, obj = {};
        return forEach((keyValue || "").split("&"),
                function (keyValue) {
                    if (keyValue && (key_value = keyValue.split("="), key = tryDecodeURIComponent(key_value[0]), isDefined(key))) {
                        var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : !0;
                        obj[key] ? isArray(obj[key]) ? obj[key].push(val) : obj[key] = [obj[key], val] : obj[key] = val
                    }
                }),
            obj
    }

    function toKeyValue(obj) {
        var parts = [];
        return forEach(obj,
                function (value, key) {
                    isArray(value) ? forEach(value,
                        function (arrayValue) {
                            parts.push(encodeUriQuery(key, !0) + (arrayValue === !0 ? "" : "=" + encodeUriQuery(arrayValue, !0)))
                        }) : parts.push(encodeUriQuery(key, !0) + (value === !0 ? "" : "=" + encodeUriQuery(value, !0)))
                }),
            parts.length ? parts.join("&") : ""
    }

    function encodeUriSegment(val) {
        return encodeUriQuery(val, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+")
    }

    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, pctEncodeSpaces ? "%20" : "+")
    }

    function angularInit(element, bootstrap) {
        function append(element) {
            element && elements.push(element)
        }
        var appElement, module, elements = [element],
            names = ["ng:app", "ng-app", "x-ng-app", "data-ng-app"],
            NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/;
        forEach(names,
                function (name) {
                    names[name] = !0,
                        append(document.getElementById(name)),
                        name = name.replace(":", "\\:"),
                        element.querySelectorAll && (forEach(element.querySelectorAll("." + name), append), forEach(element.querySelectorAll("." + name + "\\:"), append), forEach(element.querySelectorAll("[" + name + "]"), append))
                }),
            forEach(elements,
                function (element) {
                    if (!appElement) {
                        var className = " " + element.className + " ",
                            match = NG_APP_CLASS_REGEXP.exec(className);
                        match ? (appElement = element, module = (match[2] || "").replace(/\s+/g, ",")) : forEach(element.attributes,
                            function (attr) {
                                !appElement && names[attr.name] && (appElement = element, module = attr.value)
                            })
                    }
                }),
            appElement && bootstrap(appElement, module ? [module] : [])
    }

    function bootstrap(element, modules) {
        var doBootstrap = function () {
                if (element = jqLite(element), element.injector()) {
                    var tag = element[0] === document ? "document" : startingTag(element);
                    throw ngMinErr("btstrpd", "App Already Bootstrapped with this Element '{0}'", tag)
                }
                modules = modules || [],
                    modules.unshift(["$provide",
                        function ($provide) {
                            $provide.value("$rootElement", element)
                        }
                    ]),
                    modules.unshift("ng");
                var injector = createInjector(modules);
                return injector.invoke(["$rootScope", "$rootElement", "$compile", "$injector", "$animate",
                        function (scope, element, compile, injector) {
                            scope.$apply(function () {
                                element.data("$injector", injector),
                                    compile(element)(scope)
                            })
                        }
                    ]),
                    injector
            },
            NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        return window && !NG_DEFER_BOOTSTRAP.test(window.name) ? doBootstrap() : (window.name = window.name.replace(NG_DEFER_BOOTSTRAP, ""), void(angular.resumeBootstrap = function (extraModules) {
            forEach(extraModules,
                    function (module) {
                        modules.push(module)
                    }),
                doBootstrap()
        }))
    }

    function snake_case(name, separator) {
        return separator = separator || "_",
            name.replace(SNAKE_CASE_REGEXP,
                function (letter, pos) {
                    return (pos ? separator : "") + letter.toLowerCase()
                })
    }

    function bindJQuery() {
        jQuery = window.jQuery,
            jQuery ? (jqLite = jQuery, extend(jQuery.fn, {
                scope: JQLitePrototype.scope,
                isolateScope: JQLitePrototype.isolateScope,
                controller: JQLitePrototype.controller,
                injector: JQLitePrototype.injector,
                inheritedData: JQLitePrototype.inheritedData
            }), jqLitePatchJQueryRemove("remove", !0, !0, !1), jqLitePatchJQueryRemove("empty", !1, !1, !1), jqLitePatchJQueryRemove("html", !1, !1, !0)) : jqLite = JQLite,
            angular.element = jqLite
    }

    function assertArg(arg, name, reason) {
        if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        return arg
    }

    function assertArgFn(arg, name, acceptArrayAnnotation) {
        return acceptArrayAnnotation && isArray(arg) && (arg = arg[arg.length - 1]),
            assertArg(isFunction(arg), name, "not a function, got " + (arg && "object" == typeof arg ? arg.constructor.name || "Object" : typeof arg)),
            arg
    }

    function assertNotHasOwnProperty(name, context) {
        if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context)
    }

    function getter(obj, path, bindFnToScope) {
        if (!path) return obj;
        for (var key, keys = path.split("."), lastInstance = obj, len = keys.length, i = 0; len > i; i++) key = keys[i],
            obj && (obj = (lastInstance = obj)[key]);
        return !bindFnToScope && isFunction(obj) ? bind(lastInstance, obj) : obj
    }

    function getBlockElements(nodes) {
        var startNode = nodes[0],
            endNode = nodes[nodes.length - 1];
        if (startNode === endNode) return jqLite(startNode);
        var element = startNode,
            elements = [element];
        do {
            if (element = element.nextSibling, !element) break;
            elements.push(element)
        } while (element !== endNode);
        return jqLite(elements)
    }

    function setupModuleLoader(window) {
        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory())
        }
        var $injectorMinErr = minErr("$injector"),
            ngMinErr = minErr("ng"),
            angular = ensure(window, "angular", Object);
        return angular.$$minErr = angular.$$minErr || minErr,
            ensure(angular, "module",
                function () {
                    var modules = {};
                    return function (name, requires, configFn) {
                        var assertNotHasOwnProperty = function (name, context) {
                            if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context)
                        };
                        return assertNotHasOwnProperty(name, "module"),
                            requires && modules.hasOwnProperty(name) && (modules[name] = null),
                            ensure(modules, name,
                                function () {
                                    function invokeLater(provider, method, insertMethod) {
                                        return function () {
                                            return invokeQueue[insertMethod || "push"]([provider, method, arguments]),
                                                moduleInstance
                                        }
                                    }
                                    if (!requires) throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.", name);
                                    var invokeQueue = [],
                                        runBlocks = [],
                                        config = invokeLater("$injector", "invoke"),
                                        moduleInstance = {
                                            _invokeQueue: invokeQueue,
                                            _runBlocks: runBlocks,
                                            requires: requires,
                                            name: name,
                                            provider: invokeLater("$provide", "provider"),
                                            factory: invokeLater("$provide", "factory"),
                                            service: invokeLater("$provide", "service"),
                                            value: invokeLater("$provide", "value"),
                                            constant: invokeLater("$provide", "constant", "unshift"),
                                            animation: invokeLater("$animateProvider", "register"),
                                            filter: invokeLater("$filterProvider", "register"),
                                            controller: invokeLater("$controllerProvider", "register"),
                                            directive: invokeLater("$compileProvider", "directive"),
                                            config: config,
                                            run: function (block) {
                                                return runBlocks.push(block),
                                                    this
                                            }
                                        };
                                    return configFn && config(configFn),
                                        moduleInstance
                                })
                    }
                })
    }

    function publishExternalAPI(angular) {
        extend(angular, {
                bootstrap: bootstrap,
                copy: copy,
                extend: extend,
                equals: equals,
                element: jqLite,
                forEach: forEach,
                injector: createInjector,
                noop: noop,
                bind: bind,
                toJson: toJson,
                fromJson: fromJson,
                identity: identity,
                isUndefined: isUndefined,
                isDefined: isDefined,
                isString: isString,
                isFunction: isFunction,
                isObject: isObject,
                isNumber: isNumber,
                isElement: isElement,
                isArray: isArray,
                version: version,
                isDate: isDate,
                lowercase: lowercase,
                uppercase: uppercase,
                callbacks: {
                    counter: 0
                },
                $$minErr: minErr,
                $$csp: csp
            }),
            angularModule = setupModuleLoader(window);
        try {
            angularModule("ngLocale")
        } catch (e) {
            angularModule("ngLocale", []).provider("$locale", $LocaleProvider)
        }
        angularModule("ng", ["ngLocale"], ["$provide",
            function ($provide) {
                $provide.provider({
                        $$sanitizeUri: $$SanitizeUriProvider
                    }),
                    $provide.provider("$compile", $CompileProvider).directive({
                        a: htmlAnchorDirective,
                        input: inputDirective,
                        textarea: inputDirective,
                        form: formDirective,
                        script: scriptDirective,
                        select: selectDirective,
                        style: styleDirective,
                        option: optionDirective,
                        ngBind: ngBindDirective,
                        ngBindHtml: ngBindHtmlDirective,
                        ngBindTemplate: ngBindTemplateDirective,
                        ngClass: ngClassDirective,
                        ngClassEven: ngClassEvenDirective,
                        ngClassOdd: ngClassOddDirective,
                        ngCloak: ngCloakDirective,
                        ngController: ngControllerDirective,
                        ngForm: ngFormDirective,
                        ngHide: ngHideDirective,
                        ngIf: ngIfDirective,
                        ngInclude: ngIncludeDirective,
                        ngInit: ngInitDirective,
                        ngNonBindable: ngNonBindableDirective,
                        ngPluralize: ngPluralizeDirective,
                        ngRepeat: ngRepeatDirective,
                        ngShow: ngShowDirective,
                        ngStyle: ngStyleDirective,
                        ngSwitch: ngSwitchDirective,
                        ngSwitchWhen: ngSwitchWhenDirective,
                        ngSwitchDefault: ngSwitchDefaultDirective,
                        ngOptions: ngOptionsDirective,
                        ngTransclude: ngTranscludeDirective,
                        ngModel: ngModelDirective,
                        ngList: ngListDirective,
                        ngChange: ngChangeDirective,
                        required: requiredDirective,
                        ngRequired: requiredDirective,
                        ngValue: ngValueDirective
                    }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives),
                    $provide.provider({
                        $anchorScroll: $AnchorScrollProvider,
                        $animate: $AnimateProvider,
                        $browser: $BrowserProvider,
                        $cacheFactory: $CacheFactoryProvider,
                        $controller: $ControllerProvider,
                        $document: $DocumentProvider,
                        $exceptionHandler: $ExceptionHandlerProvider,
                        $filter: $FilterProvider,
                        $interpolate: $InterpolateProvider,
                        $interval: $IntervalProvider,
                        $http: $HttpProvider,
                        $httpBackend: $HttpBackendProvider,
                        $location: $LocationProvider,
                        $log: $LogProvider,
                        $parse: $ParseProvider,
                        $rootScope: $RootScopeProvider,
                        $q: $QProvider,
                        $sce: $SceProvider,
                        $sceDelegate: $SceDelegateProvider,
                        $sniffer: $SnifferProvider,
                        $templateCache: $TemplateCacheProvider,
                        $timeout: $TimeoutProvider,
                        $window: $WindowProvider
                    })
            }
        ])
    }

    function jqNextId() {
        return ++jqId
    }

    function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP,
            function (_, separator, letter, offset) {
                return offset ? letter.toUpperCase() : letter
            }).replace(MOZ_HACK_REGEXP, "Moz$1")
    }

    function jqLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments) {
        function removePatch(param) {
            var set, setIndex, setLength, element, childIndex, childLength, children, list = filterElems && param ? [this.filter(param)] : [this],
                fireEvent = dispatchThis;
            if (!getterIfNoArguments || null != param)
                for (; list.length;)
                    for (set = list.shift(), setIndex = 0, setLength = set.length; setLength > setIndex; setIndex++)
                        for (element = jqLite(set[setIndex]), fireEvent ? element.triggerHandler("$destroy") : fireEvent = !fireEvent, childIndex = 0, childLength = (children = element.children()).length; childLength > childIndex; childIndex++) list.push(jQuery(children[childIndex]));
            return originalJqFn.apply(this, arguments)
        }
        var originalJqFn = jQuery.fn[name];
        originalJqFn = originalJqFn.$original || originalJqFn,
            removePatch.$original = originalJqFn,
            jQuery.fn[name] = removePatch
    }

    function JQLite(element) {
        if (element instanceof JQLite) return element;
        if (!(this instanceof JQLite)) {
            if (isString(element) && "<" != element.charAt(0)) throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
            return new JQLite(element)
        }
        if (isString(element)) {
            var div = document.createElement("div");
            div.innerHTML = "<div>&#160;</div>" + element,
                div.removeChild(div.firstChild),
                jqLiteAddNodes(this, div.childNodes);
            var fragment = jqLite(document.createDocumentFragment());
            fragment.append(this)
        } else jqLiteAddNodes(this, element)
    }

    function jqLiteClone(element) {
        return element.cloneNode(!0)
    }

    function jqLiteDealoc(element) {
        jqLiteRemoveData(element);
        for (var i = 0,
                children = element.childNodes || []; i < children.length; i++) jqLiteDealoc(children[i])
    }

    function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
        var events = jqLiteExpandoStore(element, "events"),
            handle = jqLiteExpandoStore(element, "handle");
        handle && (isUndefined(type) ? forEach(events,
            function (eventHandler, type) {
                removeEventListenerFn(element, type, eventHandler),
                    delete events[type]
            }) : forEach(type.split(" "),
            function (type) {
                isUndefined(fn) ? (removeEventListenerFn(element, type, events[type]), delete events[type]) : arrayRemove(events[type] || [], fn)
            }))
    }

    function jqLiteRemoveData(element, name) {
        var expandoId = element[jqName],
            expandoStore = jqCache[expandoId];
        if (expandoStore) {
            if (name) return void delete jqCache[expandoId].data[name];
            expandoStore.handle && (expandoStore.events.$destroy && expandoStore.handle({},
                    "$destroy"), jqLiteOff(element)),
                delete jqCache[expandoId],
                element[jqName] = undefined
        }
    }

    function jqLiteExpandoStore(element, key, value) {
        var expandoId = element[jqName],
            expandoStore = jqCache[expandoId || -1];
        return isDefined(value) ? (expandoStore || (element[jqName] = expandoId = jqNextId(), expandoStore = jqCache[expandoId] = {}), void(expandoStore[key] = value)) : expandoStore && expandoStore[key]
    }

    function jqLiteData(element, key, value) {
        var data = jqLiteExpandoStore(element, "data"),
            isSetter = isDefined(value),
            keyDefined = !isSetter && isDefined(key),
            isSimpleGetter = keyDefined && !isObject(key);
        if (data || isSimpleGetter || jqLiteExpandoStore(element, "data", data = {}), isSetter) data[key] = value;
        else {
            if (!keyDefined) return data;
            if (isSimpleGetter) return data && data[key];
            extend(data, key)
        }
    }

    function jqLiteHasClass(element, selector) {
        return element.getAttribute ? (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1 : !1
    }

    function jqLiteRemoveClass(element, cssClasses) {
        cssClasses && element.setAttribute && forEach(cssClasses.split(" "),
            function (cssClass) {
                element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")))
            })
    }

    function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            forEach(cssClasses.split(" "),
                    function (cssClass) {
                        cssClass = trim(cssClass), -1 === existingClasses.indexOf(" " + cssClass + " ") && (existingClasses += cssClass + " ")
                    }),
                element.setAttribute("class", trim(existingClasses))
        }
    }

    function jqLiteAddNodes(root, elements) {
        if (elements) {
            elements = elements.nodeName || !isDefined(elements.length) || isWindow(elements) ? [elements] : elements;
            for (var i = 0; i < elements.length; i++) root.push(elements[i])
        }
    }

    function jqLiteController(element, name) {
        return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller")
    }

    function jqLiteInheritedData(element, name, value) {
        element = jqLite(element),
            9 == element[0].nodeType && (element = element.find("html"));
        for (var names = isArray(name) ? name : [name]; element.length;) {
            for (var i = 0,
                    ii = names.length; ii > i; i++)
                if ((value = element.data(names[i])) !== undefined) return value;
            element = element.parent()
        }
    }

    function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[element.nodeName] && booleanAttr
    }

    function createEventHandler(element, events) {
        var eventHandler = function (event, type) {
            if (event.preventDefault || (event.preventDefault = function () {
                    event.returnValue = !1
                }), event.stopPropagation || (event.stopPropagation = function () {
                    event.cancelBubble = !0
                }), event.target || (event.target = event.srcElement || document), isUndefined(event.defaultPrevented)) {
                var prevent = event.preventDefault;
                event.preventDefault = function () {
                        event.defaultPrevented = !0,
                            prevent.call(event)
                    },
                    event.defaultPrevented = !1
            }
            event.isDefaultPrevented = function () {
                    return event.defaultPrevented || event.returnValue === !1
                },
                forEach(events[type || event.type],
                    function (fn) {
                        fn.call(element, event)
                    }),
                8 >= msie ? (event.preventDefault = null, event.stopPropagation = null, event.isDefaultPrevented = null) : (delete event.preventDefault, delete event.stopPropagation, delete event.isDefaultPrevented)
        };
        return eventHandler.elem = element,
            eventHandler
    }

    function hashKey(obj) {
        var key, objType = typeof obj;
        return "object" == objType && null !== obj ? "function" == typeof (key = obj.$$hashKey) ? key = obj.$$hashKey() : key === undefined && (key = obj.$$hashKey = nextUid()) : key = obj,
            objType + ":" + key
    }

    function HashMap(array) {
        forEach(array, this.put, this)
    }

    function annotate(fn) {
        var $inject, fnText, argDecl, last;
        return "function" == typeof fn ? ($inject = fn.$inject) || ($inject = [], fn.length && (fnText = fn.toString().replace(STRIP_COMMENTS, ""), argDecl = fnText.match(FN_ARGS), forEach(argDecl[1].split(FN_ARG_SPLIT),
                function (arg) {
                    arg.replace(FN_ARG,
                        function (all, underscore, name) {
                            $inject.push(name)
                        })
                })), fn.$inject = $inject) : isArray(fn) ? (last = fn.length - 1, assertArgFn(fn[last], "fn"), $inject = fn.slice(0, last)) : assertArgFn(fn, "fn", !0),
            $inject
    }

    function createInjector(modulesToLoad) {
        function supportObject(delegate) {
            return function (key, value) {
                return isObject(key) ? void forEach(key, reverseParams(delegate)) : delegate(key, value)
            }
        }

        function provider(name, provider_) {
            if (assertNotHasOwnProperty(name, "service"), (isFunction(provider_) || isArray(provider_)) && (provider_ = providerInjector.instantiate(provider_)), !provider_.$get) throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
            return providerCache[name + providerSuffix] = provider_
        }

        function factory(name, factoryFn) {
            return provider(name, {
                $get: factoryFn
            })
        }

        function service(name, constructor) {
            return factory(name, ["$injector",
                function ($injector) {
                    return $injector.instantiate(constructor)
                }
            ])
        }

        function value(name, val) {
            return factory(name, valueFn(val))
        }

        function constant(name, value) {
            assertNotHasOwnProperty(name, "constant"),
                providerCache[name] = value,
                instanceCache[name] = value
        }

        function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix),
                orig$get = origProvider.$get;
            origProvider.$get = function () {
                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                return instanceInjector.invoke(decorFn, null, {
                    $delegate: origInstance
                })
            }
        }

        function loadModules(modulesToLoad) {
            var moduleFn, invokeQueue, i, ii, runBlocks = [];
            return forEach(modulesToLoad,
                    function (module) {
                        if (!loadedModules.get(module)) {
                            loadedModules.put(module, !0);
                            try {
                                if (isString(module))
                                    for (moduleFn = angularModule(module), runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks), invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; ii > i; i++) {
                                        var invokeArgs = invokeQueue[i],
                                            provider = providerInjector.get(invokeArgs[0]);
                                        provider[invokeArgs[1]].apply(provider, invokeArgs[2])
                                    } else isFunction(module) ? runBlocks.push(providerInjector.invoke(module)) : isArray(module) ? runBlocks.push(providerInjector.invoke(module)) : assertArgFn(module, "module")
                            } catch (e) {
                                throw isArray(module) && (module = module[module.length - 1]),
                                    e.message && e.stack && -1 == e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack),
                                    $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e)
                            }
                        }
                    }),
                runBlocks
        }

        function createInternalInjector(cache, factory) {
            function getService(serviceName) {
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING) throw $injectorMinErr("cdep", "Circular dependency found: {0}", path.join(" <- "));
                    return cache[serviceName]
                }
                try {
                    return path.unshift(serviceName),
                        cache[serviceName] = INSTANTIATING,
                        cache[serviceName] = factory(serviceName)
                } finally {
                    path.shift()
                }
            }

            function invoke(fn, self, locals) {
                var length, i, key, args = [],
                    $inject = annotate(fn);
                for (i = 0, length = $inject.length; length > i; i++) {
                    if (key = $inject[i], "string" != typeof key) throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                    args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key))
                }
                switch (fn.$inject || (fn = fn[length]), self ? -1 : args.length) {
                    case 0:
                        return fn();
                    case 1:
                        return fn(args[0]);
                    case 2:
                        return fn(args[0], args[1]);
                    case 3:
                        return fn(args[0], args[1], args[2]);
                    case 4:
                        return fn(args[0], args[1], args[2], args[3]);
                    case 5:
                        return fn(args[0], args[1], args[2], args[3], args[4]);
                    case 6:
                        return fn(args[0], args[1], args[2], args[3], args[4], args[5]);
                    case 7:
                        return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                    case 8:
                        return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
                    case 9:
                        return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);
                    case 10:
                        return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
                    default:
                        return fn.apply(self, args)
                }
            }

            function instantiate(Type, locals) {
                var instance, returnedValue, Constructor = function () {};
                return Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype,
                    instance = new Constructor,
                    returnedValue = invoke(Type, instance, locals),
                    isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance
            }
            return {
                invoke: invoke,
                instantiate: instantiate,
                get: getService,
                annotate: annotate,
                has: function (name) {
                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name)
                }
            }
        }
        var INSTANTIATING = {},
            providerSuffix = "Provider",
            path = [],
            loadedModules = new HashMap,
            providerCache = {
                $provide: {
                    provider: supportObject(provider),
                    factory: supportObject(factory),
                    service: supportObject(service),
                    value: supportObject(value),
                    constant: supportObject(constant),
                    decorator: decorator
                }
            },
            providerInjector = providerCache.$injector = createInternalInjector(providerCache,
                function () {
                    throw $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "))
                }),
            instanceCache = {},
            instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache,
                function (servicename) {
                    var provider = providerInjector.get(servicename + providerSuffix);
                    return instanceInjector.invoke(provider.$get, provider)
                });
        return forEach(loadModules(modulesToLoad),
                function (fn) {
                    instanceInjector.invoke(fn || noop)
                }),
            instanceInjector
    }

    function $AnchorScrollProvider() {
        var autoScrollingEnabled = !0;
        this.disableAutoScrolling = function () {
                autoScrollingEnabled = !1
            },
            this.$get = ["$window", "$location", "$rootScope",
                function ($window, $location, $rootScope) {
                    function getFirstAnchor(list) {
                        var result = null;
                        return forEach(list,
                                function (element) {
                                    result || "a" !== lowercase(element.nodeName) || (result = element)
                                }),
                            result
                    }

                    function scroll() {
                        var elm, hash = $location.hash();
                        hash ? (elm = document.getElementById(hash)) ? elm.scrollIntoView() : (elm = getFirstAnchor(document.getElementsByName(hash))) ? elm.scrollIntoView() : "top" === hash && $window.scrollTo(0, 0) : $window.scrollTo(0, 0)
                    }
                    var document = $window.document;
                    return autoScrollingEnabled && $rootScope.$watch(function () {
                                return $location.hash()
                            },
                            function () {
                                $rootScope.$evalAsync(scroll)
                            }),
                        scroll
                }
            ]
    }

    function Browser(window, document, $log, $sniffer) {
        function completeOutstandingRequest(fn) {
            try {
                fn.apply(null, sliceArgs(arguments, 1))
            } finally {
                if (outstandingRequestCount--, 0 === outstandingRequestCount)
                    for (; outstandingRequestCallbacks.length;) try {
                        outstandingRequestCallbacks.pop()()
                    } catch (e) {
                        $log.error(e)
                    }
            }
        }

        function startPoller(interval, setTimeout) {
            !
            function check() {
                forEach(pollFns,
                        function (pollFn) {
                            pollFn()
                        }),
                    pollTimeout = setTimeout(check, interval)
            }()
        }

        function fireUrlChange() {
            newLocation = null,
                lastBrowserUrl != self.url() && (lastBrowserUrl = self.url(), forEach(urlChangeListeners,
                    function (listener) {
                        listener(self.url())
                    }))
        }
        var self = this,
            rawDocument = document[0],
            location = window.location,
            history = window.history,
            setTimeout = window.setTimeout,
            clearTimeout = window.clearTimeout,
            pendingDeferIds = {};
        self.isMock = !1;
        var outstandingRequestCount = 0,
            outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest,
            self.$$incOutstandingRequestCount = function () {
                outstandingRequestCount++
            },
            self.notifyWhenNoOutstandingRequests = function (callback) {
                forEach(pollFns,
                        function (pollFn) {
                            pollFn()
                        }),
                    0 === outstandingRequestCount ? callback() : outstandingRequestCallbacks.push(callback)
            };
        var pollTimeout, pollFns = [];
        self.addPollFn = function (fn) {
            return isUndefined(pollTimeout) && startPoller(100, setTimeout),
                pollFns.push(fn),
                fn
        };
        var lastBrowserUrl = location.href,
            baseElement = document.find("base"),
            newLocation = null;
        self.url = function (url, replace) {
            if (location !== window.location && (location = window.location), url) {
                if (lastBrowserUrl == url) return;
                return lastBrowserUrl = url,
                    $sniffer.history ? replace ? history.replaceState(null, "", url) : (history.pushState(null, "", url), baseElement.attr("href", baseElement.attr("href"))) : (newLocation = url, replace ? location.replace(url) : location.href = url),
                    self
            }
            return newLocation || location.href.replace(/%27/g, "'")
        };
        var urlChangeListeners = [],
            urlChangeInit = !1;
        self.onUrlChange = function (callback) {
                return urlChangeInit || ($sniffer.history && jqLite(window).on("popstate", fireUrlChange), $sniffer.hashchange ? jqLite(window).on("hashchange", fireUrlChange) : self.addPollFn(fireUrlChange), urlChangeInit = !0),
                    urlChangeListeners.push(callback),
                    callback
            },
            self.baseHref = function () {
                var href = baseElement.attr("href");
                return href ? href.replace(/^https?\:\/\/[^\/]*/, "") : ""
            };
        var lastCookies = {},
            lastCookieString = "",
            cookiePath = self.baseHref();
        self.cookies = function (name, value) {
                var cookieLength, cookieArray, cookie, i, index;
                if (!name) {
                    if (rawDocument.cookie !== lastCookieString)
                        for (lastCookieString = rawDocument.cookie, cookieArray = lastCookieString.split("; "), lastCookies = {},
                            i = 0; i < cookieArray.length; i++) cookie = cookieArray[i],
                            index = cookie.indexOf("="),
                            index > 0 && (name = unescape(cookie.substring(0, index)), lastCookies[name] === undefined && (lastCookies[name] = unescape(cookie.substring(index + 1))));
                    return lastCookies
                }
                value === undefined ? rawDocument.cookie = escape(name) + "=;path=" + cookiePath + ";expires=Thu, 01 Jan 1970 00:00:00 GMT" : isString(value) && (cookieLength = (rawDocument.cookie = escape(name) + "=" + escape(value) + ";path=" + cookiePath).length + 1, cookieLength > 4096 && $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!"))
            },
            self.defer = function (fn, delay) {
                var timeoutId;
                return outstandingRequestCount++,
                    timeoutId = setTimeout(function () {
                            delete pendingDeferIds[timeoutId],
                                completeOutstandingRequest(fn)
                        },
                        delay || 0),
                    pendingDeferIds[timeoutId] = !0,
                    timeoutId
            },
            self.defer.cancel = function (deferId) {
                return pendingDeferIds[deferId] ? (delete pendingDeferIds[deferId], clearTimeout(deferId), completeOutstandingRequest(noop), !0) : !1
            }
    }

    function $BrowserProvider() {
        this.$get = ["$window", "$log", "$sniffer", "$document",
            function ($window, $log, $sniffer, $document) {
                return new Browser($window, $document, $log, $sniffer)
            }
        ]
    }

    function $CacheFactoryProvider() {
        this.$get = function () {
            function cacheFactory(cacheId, options) {
                function refresh(entry) {
                    entry != freshEnd && (staleEnd ? staleEnd == entry && (staleEnd = entry.n) : staleEnd = entry, link(entry.n, entry.p), link(entry, freshEnd), freshEnd = entry, freshEnd.n = null)
                }

                function link(nextEntry, prevEntry) {
                    nextEntry != prevEntry && (nextEntry && (nextEntry.p = prevEntry), prevEntry && (prevEntry.n = nextEntry))
                }
                if (cacheId in caches) throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                var size = 0,
                    stats = extend({},
                        options, {
                            id: cacheId
                        }),
                    data = {},
                    capacity = options && options.capacity || Number.MAX_VALUE,
                    lruHash = {},
                    freshEnd = null,
                    staleEnd = null;
                return caches[cacheId] = {
                    put: function (key, value) {
                        var lruEntry = lruHash[key] || (lruHash[key] = {
                            key: key
                        });
                        return refresh(lruEntry),
                            isUndefined(value) ? void 0 : (key in data || size++, data[key] = value, size > capacity && this.remove(staleEnd.key), value)
                    },
                    get: function (key) {
                        var lruEntry = lruHash[key];
                        if (lruEntry) return refresh(lruEntry),
                            data[key]
                    },
                    remove: function (key) {
                        var lruEntry = lruHash[key];
                        lruEntry && (lruEntry == freshEnd && (freshEnd = lruEntry.p), lruEntry == staleEnd && (staleEnd = lruEntry.n), link(lruEntry.n, lruEntry.p), delete lruHash[key], delete data[key], size--)
                    },
                    removeAll: function () {
                        data = {},
                            size = 0,
                            lruHash = {},
                            freshEnd = staleEnd = null
                    },
                    destroy: function () {
                        data = null,
                            stats = null,
                            lruHash = null,
                            delete caches[cacheId]
                    },
                    info: function () {
                        return extend({},
                            stats, {
                                size: size
                            })
                    }
                }
            }
            var caches = {};
            return cacheFactory.info = function () {
                    var info = {};
                    return forEach(caches,
                            function (cache, cacheId) {
                                info[cacheId] = cache.info()
                            }),
                        info
                },
                cacheFactory.get = function (cacheId) {
                    return caches[cacheId]
                },
                cacheFactory
        }
    }

    function $TemplateCacheProvider() {
        this.$get = ["$cacheFactory",
            function ($cacheFactory) {
                return $cacheFactory("templates")
            }
        ]
    }

    function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {},
            Suffix = "Directive",
            COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w\-_]+)\s+(.*)$/,
            CLASS_DIRECTIVE_REGEXP = /(([\d\w\-_]+)(?:\:([^;]+))?;?)/,
            EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        this.directive = function registerDirective(name, directiveFactory) {
                return assertNotHasOwnProperty(name, "directive"),
                    isString(name) ? (assertArg(directiveFactory, "directiveFactory"), hasDirectives.hasOwnProperty(name) || (hasDirectives[name] = [], $provide.factory(name + Suffix, ["$injector", "$exceptionHandler",
                        function ($injector, $exceptionHandler) {
                            var directives = [];
                            return forEach(hasDirectives[name],
                                    function (directiveFactory, index) {
                                        try {
                                            var directive = $injector.invoke(directiveFactory);
                                            isFunction(directive) ? directive = {
                                                    compile: valueFn(directive)
                                                } : !directive.compile && directive.link && (directive.compile = valueFn(directive.link)),
                                                directive.priority = directive.priority || 0,
                                                directive.index = index,
                                                directive.name = directive.name || name,
                                                directive.require = directive.require || directive.controller && directive.name,
                                                directive.restrict = directive.restrict || "A",
                                                directives.push(directive)
                                        } catch (e) {
                                            $exceptionHandler(e)
                                        }
                                    }),
                                directives
                        }
                    ])), hasDirectives[name].push(directiveFactory)) : forEach(name, reverseParams(registerDirective)),
                    this
            },
            this.aHrefSanitizationWhitelist = function (regexp) {
                return isDefined(regexp) ? ($$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp), this) : $$sanitizeUriProvider.aHrefSanitizationWhitelist()
            },
            this.imgSrcSanitizationWhitelist = function (regexp) {
                return isDefined(regexp) ? ($$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp), this) : $$sanitizeUriProvider.imgSrcSanitizationWhitelist()
            },
            this.$get = ["$injector", "$interpolate", "$exceptionHandler", "$http", "$templateCache", "$parse", "$controller", "$rootScope", "$document", "$sce", "$animate", "$$sanitizeUri",
                function ($injector, $interpolate, $exceptionHandler, $http, $templateCache, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
                    function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                        $compileNodes instanceof jqLite || ($compileNodes = jqLite($compileNodes)),
                            forEach($compileNodes,
                                function (node, index) {
                                    3 == node.nodeType && node.nodeValue.match(/\S+/) && ($compileNodes[index] = node = jqLite(node).wrap("<span></span>").parent()[0])
                                });
                        var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                        return function (scope, cloneConnectFn, transcludeControllers) {
                            assertArg(scope, "scope");
                            var $linkNode = cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes;
                            forEach(transcludeControllers,
                                function (instance, name) {
                                    $linkNode.data("$" + name + "Controller", instance)
                                });
                            for (var i = 0,
                                    ii = $linkNode.length; ii > i; i++) {
                                var node = $linkNode[i];
                                (1 == node.nodeType || 9 == node.nodeType) && $linkNode.eq(i).data("$scope", scope)
                            }
                            return safeAddClass($linkNode, "ng-scope"),
                                cloneConnectFn && cloneConnectFn($linkNode, scope),
                                compositeLinkFn && compositeLinkFn(scope, $linkNode, $linkNode),
                                $linkNode
                        }
                    }

                    function safeAddClass($element, className) {
                        try {
                            $element.addClass(className)
                        } catch (e) {}
                    }

                    function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                        function compositeLinkFn(scope, nodeList, $rootElement, boundTranscludeFn) {
                            var nodeLinkFn, childLinkFn, node, $node, childScope, childTranscludeFn, i, ii, n, stableNodeList = [];
                            for (i = 0, ii = nodeList.length; ii > i; i++) stableNodeList.push(nodeList[i]);
                            for (i = 0, n = 0, ii = linkFns.length; ii > i; n++) node = stableNodeList[n],
                                nodeLinkFn = linkFns[i++],
                                childLinkFn = linkFns[i++],
                                $node = jqLite(node),
                                nodeLinkFn ? (nodeLinkFn.scope ? (childScope = scope.$new(), $node.data("$scope", childScope), safeAddClass($node, "ng-scope")) : childScope = scope, childTranscludeFn = nodeLinkFn.transclude, childTranscludeFn || !boundTranscludeFn && transcludeFn ? nodeLinkFn(childLinkFn, childScope, node, $rootElement, createBoundTranscludeFn(scope, childTranscludeFn || transcludeFn)) : nodeLinkFn(childLinkFn, childScope, node, $rootElement, boundTranscludeFn)) : childLinkFn && childLinkFn(scope, node.childNodes, undefined, boundTranscludeFn)
                        }
                        for (var nodeLinkFn, childLinkFn, directives, attrs, linkFnFound, linkFns = [], i = 0; i < nodeList.length; i++) attrs = new Attributes,
                            directives = collectDirectives(nodeList[i], [], attrs, 0 === i ? maxPriority : undefined, ignoreDirective),
                            nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null,
                            childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !nodeList[i].childNodes || !nodeList[i].childNodes.length ? null : compileNodes(nodeList[i].childNodes, nodeLinkFn ? nodeLinkFn.transclude : transcludeFn),
                            linkFns.push(nodeLinkFn),
                            linkFns.push(childLinkFn),
                            linkFnFound = linkFnFound || nodeLinkFn || childLinkFn,
                            previousCompileContext = null;
                        return linkFnFound ? compositeLinkFn : null
                    }

                    function createBoundTranscludeFn(scope, transcludeFn) {
                        return function (transcludedScope, cloneFn, controllers) {
                            var scopeCreated = !1;
                            transcludedScope || (transcludedScope = scope.$new(), transcludedScope.$$transcluded = !0, scopeCreated = !0);
                            var clone = transcludeFn(transcludedScope, cloneFn, controllers);
                            return scopeCreated && clone.on("$destroy", bind(transcludedScope, transcludedScope.$destroy)),
                                clone
                        }
                    }

                    function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                        var match, className, nodeType = node.nodeType,
                            attrsMap = attrs.$attr;
                        switch (nodeType) {
                            case 1:
                                addDirective(directives, directiveNormalize(nodeName_(node).toLowerCase()), "E", maxPriority, ignoreDirective);
                                for (var attr, name, nName, ngAttrName, value, nAttrs = node.attributes,
                                        j = 0,
                                        jj = nAttrs && nAttrs.length; jj > j; j++) {
                                    var attrStartName = !1,
                                        attrEndName = !1;
                                    if (attr = nAttrs[j], !msie || msie >= 8 || attr.specified) {
                                        name = attr.name,
                                            ngAttrName = directiveNormalize(name),
                                            NG_ATTR_BINDING.test(ngAttrName) && (name = snake_case(ngAttrName.substr(6), "-"));
                                        var directiveNName = ngAttrName.replace(/(Start|End)$/, "");
                                        ngAttrName === directiveNName + "Start" && (attrStartName = name, attrEndName = name.substr(0, name.length - 5) + "end", name = name.substr(0, name.length - 6)),
                                            nName = directiveNormalize(name.toLowerCase()),
                                            attrsMap[nName] = name,
                                            attrs[nName] = value = trim(msie && "href" == name ? decodeURIComponent(node.getAttribute(name, 2)) : attr.value),
                                            getBooleanAttrName(node, nName) && (attrs[nName] = !0),
                                            addAttrInterpolateDirective(node, directives, value, nName),
                                            addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName)
                                    }
                                }
                                if (className = node.className, isString(className) && "" !== className)
                                    for (; match = CLASS_DIRECTIVE_REGEXP.exec(className);) nName = directiveNormalize(match[2]),
                                        addDirective(directives, nName, "C", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[3])),
                                        className = className.substr(match.index + match[0].length);
                                break;
                            case 3:
                                addTextInterpolateDirective(directives, node.nodeValue);
                                break;
                            case 8:
                                try {
                                    match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue),
                                        match && (nName = directiveNormalize(match[1]), addDirective(directives, nName, "M", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[2])))
                                } catch (e) {}
                        }
                        return directives.sort(byPriority),
                            directives
                    }

                    function groupScan(node, attrStart, attrEnd) {
                        var nodes = [],
                            depth = 0;
                        if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                            do {
                                if (!node) throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                                1 == node.nodeType && (node.hasAttribute(attrStart) && depth++, node.hasAttribute(attrEnd) && depth--), nodes.push(node), node = node.nextSibling
                            } while (depth > 0)
                        } else nodes.push(node);
                        return jqLite(nodes)
                    }

                    function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                        return function (scope, element, attrs, controllers, transcludeFn) {
                            return element = groupScan(element[0], attrStart, attrEnd),
                                linkFn(scope, element, attrs, controllers, transcludeFn)
                        }
                    }

                    function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                        function addLinkFns(pre, post, attrStart, attrEnd) {
                            pre && (attrStart && (pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd)), pre.require = directive.require, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (pre = cloneAndAnnotateFn(pre, {
                                    isolateScope: !0
                                })), preLinkFns.push(pre)),
                                post && (attrStart && (post = groupElementsLinkFnWrapper(post, attrStart, attrEnd)), post.require = directive.require, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (post = cloneAndAnnotateFn(post, {
                                    isolateScope: !0
                                })), postLinkFns.push(post))
                        }

                        function getControllers(require, $element, elementControllers) {
                            var value, retrievalMethod = "data",
                                optional = !1;
                            if (isString(require)) {
                                for (;
                                    "^" == (value = require.charAt(0)) || "?" == value;) require = require.substr(1),
                                    "^" == value && (retrievalMethod = "inheritedData"),
                                    optional = optional || "?" == value;
                                if (value = null, elementControllers && "data" === retrievalMethod && (value = elementControllers[require]), value = value || $element[retrievalMethod]("$" + require + "Controller"), !value && !optional) throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", require, directiveName);
                                return value
                            }
                            return isArray(require) && (value = [], forEach(require,
                                    function (require) {
                                        value.push(getControllers(require, $element, elementControllers))
                                    })),
                                value
                        }

                        function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                            function controllersBoundTransclude(scope, cloneAttachFn) {
                                var transcludeControllers;
                                return arguments.length < 2 && (cloneAttachFn = scope, scope = undefined),
                                    hasElementTranscludeDirective && (transcludeControllers = elementControllers),
                                    boundTranscludeFn(scope, cloneAttachFn, transcludeControllers)
                            }
                            var attrs, $element, i, ii, linkFn, controller, isolateScope, transcludeFn, elementControllers = {};
                            if (attrs = compileNode === linkNode ? templateAttrs : shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr)), $element = attrs.$$element, newIsolateScopeDirective) {
                                var LOCAL_REGEXP = /^\s*([@=&])(\??)\s*(\w*)\s*$/,
                                    $linkNode = jqLite(linkNode);
                                isolateScope = scope.$new(!0),
                                    templateDirective && templateDirective === newIsolateScopeDirective.$$originalDirective ? $linkNode.data("$isolateScope", isolateScope) : $linkNode.data("$isolateScopeNoTemplate", isolateScope),
                                    safeAddClass($linkNode, "ng-isolate-scope"),
                                    forEach(newIsolateScopeDirective.scope,
                                        function (definition, scopeName) {
                                            var lastValue, parentGet, parentSet, match = definition.match(LOCAL_REGEXP) || [],
                                                attrName = match[3] || scopeName,
                                                optional = "?" == match[2],
                                                mode = match[1];
                                            switch (isolateScope.$$isolateBindings[scopeName] = mode + attrName, mode) {
                                                case "@":
                                                    attrs.$observe(attrName,
                                                            function (value) {
                                                                isolateScope[scopeName] = value
                                                            }),
                                                        attrs.$$observers[attrName].$$scope = scope,
                                                        attrs[attrName] && (isolateScope[scopeName] = $interpolate(attrs[attrName])(scope));
                                                    break;
                                                case "=":
                                                    if (optional && !attrs[attrName]) return;
                                                    parentGet = $parse(attrs[attrName]),
                                                        parentSet = parentGet.assign ||
                                                        function () {
                                                            throw lastValue = isolateScope[scopeName] = parentGet(scope),
                                                                $compileMinErr("nonassign", "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], newIsolateScopeDirective.name)
                                                        },
                                                        lastValue = isolateScope[scopeName] = parentGet(scope),
                                                        isolateScope.$watch(function () {
                                                            var parentValue = parentGet(scope);
                                                            return parentValue !== isolateScope[scopeName] && (parentValue !== lastValue ? isolateScope[scopeName] = parentValue : parentSet(scope, parentValue = isolateScope[scopeName])),
                                                                lastValue = parentValue
                                                        });
                                                    break;
                                                case "&":
                                                    parentGet = $parse(attrs[attrName]),
                                                        isolateScope[scopeName] = function (locals) {
                                                            return parentGet(scope, locals)
                                                        };
                                                    break;
                                                default:
                                                    throw $compileMinErr("iscp", "Invalid isolate scope definition for directive '{0}'. Definition: {... {1}: '{2}' ...}", newIsolateScopeDirective.name, scopeName, definition)
                                            }
                                        })
                            }
                            for (transcludeFn = boundTranscludeFn && controllersBoundTransclude, controllerDirectives && forEach(controllerDirectives,
                                    function (directive) {
                                        var controllerInstance, locals = {
                                            $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                                            $element: $element,
                                            $attrs: attrs,
                                            $transclude: transcludeFn
                                        };
                                        controller = directive.controller,
                                            "@" == controller && (controller = attrs[directive.name]),
                                            controllerInstance = $controller(controller, locals),
                                            elementControllers[directive.name] = controllerInstance,
                                            hasElementTranscludeDirective || $element.data("$" + directive.name + "Controller", controllerInstance),
                                            directive.controllerAs && (locals.$scope[directive.controllerAs] = controllerInstance)
                                    }), i = 0, ii = preLinkFns.length; ii > i; i++) try {
                                linkFn = preLinkFns[i],
                                    linkFn(linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.require, $element, elementControllers), transcludeFn)
                            } catch (e) {
                                $exceptionHandler(e, startingTag($element))
                            }
                            var scopeToChild = scope;
                            for (newIsolateScopeDirective && (newIsolateScopeDirective.template || null === newIsolateScopeDirective.templateUrl) && (scopeToChild = isolateScope), childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn), i = postLinkFns.length - 1; i >= 0; i--) try {
                                linkFn = postLinkFns[i],
                                    linkFn(linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.require, $element, elementControllers), transcludeFn)
                            } catch (e) {
                                $exceptionHandler(e, startingTag($element))
                            }
                        }
                        previousCompileContext = previousCompileContext || {};
                        for (var newScopeDirective, directive, directiveName, $template, linkFn, directiveValue, terminalPriority = -Number.MAX_VALUE,
                                controllerDirectives = previousCompileContext.controllerDirectives,
                                newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
                                templateDirective = previousCompileContext.templateDirective,
                                nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
                                hasTranscludeDirective = !1,
                                hasElementTranscludeDirective = !1,
                                $compileNode = templateAttrs.$$element = jqLite(compileNode), replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, i = 0, ii = directives.length; ii > i; i++) {
                            directive = directives[i];
                            var attrStart = directive.$$start,
                                attrEnd = directive.$$end;
                            if (attrStart && ($compileNode = groupScan(compileNode, attrStart, attrEnd)), $template = undefined, terminalPriority > directive.priority) break;
                            if ((directiveValue = directive.scope) && (newScopeDirective = newScopeDirective || directive, directive.templateUrl || (assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode), isObject(directiveValue) && (newIsolateScopeDirective = directive))), directiveName = directive.name, !directive.templateUrl && directive.controller && (directiveValue = directive.controller, controllerDirectives = controllerDirectives || {},
                                    assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode), controllerDirectives[directiveName] = directive), (directiveValue = directive.transclude) && (hasTranscludeDirective = !0, directive.$$tlb || (assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode), nonTlbTranscludeDirective = directive), "element" == directiveValue ? (hasElementTranscludeDirective = !0, terminalPriority = directive.priority, $template = groupScan(compileNode, attrStart, attrEnd), $compileNode = templateAttrs.$$element = jqLite(document.createComment(" " + directiveName + ": " + templateAttrs[directiveName] + " ")), compileNode = $compileNode[0], replaceWith(jqCollection, jqLite(sliceArgs($template)), compileNode), childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                                    nonTlbTranscludeDirective: nonTlbTranscludeDirective
                                })) : ($template = jqLite(jqLiteClone(compileNode)).contents(), $compileNode.html(""), childTranscludeFn = compile($template, transcludeFn))), directive.template)
                                if (assertNoDuplicate("template", templateDirective, directive, $compileNode), templateDirective = directive, directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template, directiveValue = denormalizeTemplate(directiveValue), directive.replace) {
                                    if (replaceDirective = directive, $template = jqLite("<div>" + trim(directiveValue) + "</div>").contents(), compileNode = $template[0], 1 != $template.length || 1 !== compileNode.nodeType) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                                    replaceWith(jqCollection, $compileNode, compileNode);
                                    var newTemplateAttrs = {
                                            $attr: {}
                                        },
                                        templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs),
                                        unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                                    newIsolateScopeDirective && markDirectivesAsIsolate(templateDirectives),
                                        directives = directives.concat(templateDirectives).concat(unprocessedDirectives),
                                        mergeTemplateAttributes(templateAttrs, newTemplateAttrs),
                                        ii = directives.length
                                } else $compileNode.html(directiveValue);
                            if (directive.templateUrl) assertNoDuplicate("template", templateDirective, directive, $compileNode),
                                templateDirective = directive,
                                directive.replace && (replaceDirective = directive),
                                nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, childTranscludeFn, preLinkFns, postLinkFns, {
                                    controllerDirectives: controllerDirectives,
                                    newIsolateScopeDirective: newIsolateScopeDirective,
                                    templateDirective: templateDirective,
                                    nonTlbTranscludeDirective: nonTlbTranscludeDirective
                                }),
                                ii = directives.length;
                            else if (directive.compile) try {
                                linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn),
                                    isFunction(linkFn) ? addLinkFns(null, linkFn, attrStart, attrEnd) : linkFn && addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd)
                            } catch (e) {
                                $exceptionHandler(e, startingTag($compileNode))
                            }
                            directive.terminal && (nodeLinkFn.terminal = !0, terminalPriority = Math.max(terminalPriority, directive.priority))
                        }
                        return nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === !0,
                            nodeLinkFn.transclude = hasTranscludeDirective && childTranscludeFn,
                            nodeLinkFn
                    }

                    function markDirectivesAsIsolate(directives) {
                        for (var j = 0,
                                jj = directives.length; jj > j; j++) directives[j] = inherit(directives[j], {
                            $$isolateScope: !0
                        })
                    }

                    function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                        if (name === ignoreDirective) return null;
                        var match = null;
                        if (hasDirectives.hasOwnProperty(name))
                            for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; ii > i; i++) try {
                                directive = directives[i],
                                    (maxPriority === undefined || maxPriority > directive.priority) && -1 != directive.restrict.indexOf(location) && (startAttrName && (directive = inherit(directive, {
                                        $$start: startAttrName,
                                        $$end: endAttrName
                                    })), tDirectives.push(directive), match = directive)
                            } catch (e) {
                                $exceptionHandler(e)
                            }
                        return match
                    }

                    function mergeTemplateAttributes(dst, src) {
                        var srcAttr = src.$attr,
                            dstAttr = dst.$attr,
                            $element = dst.$$element;
                        forEach(dst,
                                function (value, key) {
                                    "$" != key.charAt(0) && (src[key] && (value += ("style" === key ? ";" : " ") + src[key]), dst.$set(key, value, !0, srcAttr[key]))
                                }),
                            forEach(src,
                                function (value, key) {
                                    "class" == key ? (safeAddClass($element, value), dst["class"] = (dst["class"] ? dst["class"] + " " : "") + value) : "style" == key ? ($element.attr("style", $element.attr("style") + ";" + value), dst.style = (dst.style ? dst.style + ";" : "") + value) : "$" == key.charAt(0) || dst.hasOwnProperty(key) || (dst[key] = value, dstAttr[key] = srcAttr[key])
                                })
                    }

                    function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                        var afterTemplateNodeLinkFn, afterTemplateChildLinkFn, linkQueue = [],
                            beforeTemplateCompileNode = $compileNode[0],
                            origAsyncDirective = directives.shift(),
                            derivedSyncDirective = extend({},
                                origAsyncDirective, {
                                    templateUrl: null,
                                    transclude: null,
                                    replace: null,
                                    $$originalDirective: origAsyncDirective
                                }),
                            templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl;
                        return $compileNode.html(""),
                            $http.get($sce.getTrustedResourceUrl(templateUrl), {
                                cache: $templateCache
                            }).success(function (content) {
                                var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                                if (content = denormalizeTemplate(content), origAsyncDirective.replace) {
                                    if ($template = jqLite("<div>" + trim(content) + "</div>").contents(), compileNode = $template[0], 1 != $template.length || 1 !== compileNode.nodeType) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                                    tempTemplateAttrs = {
                                            $attr: {}
                                        },
                                        replaceWith($rootElement, $compileNode, compileNode);
                                    var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                                    isObject(origAsyncDirective.scope) && markDirectivesAsIsolate(templateDirectives),
                                        directives = templateDirectives.concat(directives),
                                        mergeTemplateAttributes(tAttrs, tempTemplateAttrs)
                                } else compileNode = beforeTemplateCompileNode,
                                    $compileNode.html(content);
                                for (directives.unshift(derivedSyncDirective), afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext), forEach($rootElement,
                                        function (node, i) {
                                            node == compileNode && ($rootElement[i] = $compileNode[0])
                                        }), afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn); linkQueue.length;) {
                                    var scope = linkQueue.shift(),
                                        beforeTemplateLinkNode = linkQueue.shift(),
                                        linkRootElement = linkQueue.shift(),
                                        boundTranscludeFn = linkQueue.shift(),
                                        linkNode = $compileNode[0];
                                    beforeTemplateLinkNode !== beforeTemplateCompileNode && (linkNode = jqLiteClone(compileNode), replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode)),
                                        childBoundTranscludeFn = afterTemplateNodeLinkFn.transclude ? createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude) : boundTranscludeFn,
                                        afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn)
                                }
                                linkQueue = null
                            }).error(function (response, code, headers, config) {
                                throw $compileMinErr("tpload", "Failed to load template: {0}", config.url)
                            }),
                            function (ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                                linkQueue ? (linkQueue.push(scope), linkQueue.push(node), linkQueue.push(rootElement), linkQueue.push(boundTranscludeFn)) : afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, boundTranscludeFn)
                            }
                    }

                    function byPriority(a, b) {
                        var diff = b.priority - a.priority;
                        return 0 !== diff ? diff : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index
                    }

                    function assertNoDuplicate(what, previousDirective, directive, element) {
                        if (previousDirective) throw $compileMinErr("multidir", "Multiple directives [{0}, {1}] asking for {2} on: {3}", previousDirective.name, directive.name, what, startingTag(element))
                    }

                    function addTextInterpolateDirective(directives, text) {
                        var interpolateFn = $interpolate(text, !0);
                        interpolateFn && directives.push({
                            priority: 0,
                            compile: valueFn(function (scope, node) {
                                var parent = node.parent(),
                                    bindings = parent.data("$binding") || [];
                                bindings.push(interpolateFn),
                                    safeAddClass(parent.data("$binding", bindings), "ng-binding"),
                                    scope.$watch(interpolateFn,
                                        function (value) {
                                            node[0].nodeValue = value
                                        })
                            })
                        })
                    }

                    function getTrustedContext(node, attrNormalizedName) {
                        if ("srcdoc" == attrNormalizedName) return $sce.HTML;
                        var tag = nodeName_(node);
                        return "xlinkHref" == attrNormalizedName || "FORM" == tag && "action" == attrNormalizedName || "IMG" != tag && ("src" == attrNormalizedName || "ngSrc" == attrNormalizedName) ? $sce.RESOURCE_URL : void 0
                    }

                    function addAttrInterpolateDirective(node, directives, value, name) {
                        var interpolateFn = $interpolate(value, !0);
                        if (interpolateFn) {
                            if ("multiple" === name && "SELECT" === nodeName_(node)) throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                            directives.push({
                                priority: 100,
                                compile: function () {
                                    return {
                                        pre: function (scope, element, attr) {
                                            var $$observers = attr.$$observers || (attr.$$observers = {});
                                            if (EVENT_HANDLER_ATTR_REGEXP.test(name)) throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the ng- versions (such as ng-click instead of onclick) instead.");
                                            interpolateFn = $interpolate(attr[name], !0, getTrustedContext(node, name)),
                                                interpolateFn && (attr[name] = interpolateFn(scope), ($$observers[name] || ($$observers[name] = [])).$$inter = !0, (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn,
                                                    function (newValue, oldValue) {
                                                        "class" === name && newValue != oldValue ? attr.$updateClass(newValue, oldValue) : attr.$set(name, newValue)
                                                    }))
                                        }
                                    }
                                }
                            })
                        }
                    }

                    function replaceWith($rootElement, elementsToRemove, newNode) {
                        var i, ii, firstElementToRemove = elementsToRemove[0],
                            removeCount = elementsToRemove.length,
                            parent = firstElementToRemove.parentNode;
                        if ($rootElement)
                            for (i = 0, ii = $rootElement.length; ii > i; i++)
                                if ($rootElement[i] == firstElementToRemove) {
                                    $rootElement[i++] = newNode;
                                    for (var j = i,
                                            j2 = j + removeCount - 1,
                                            jj = $rootElement.length; jj > j; j++, j2++) jj > j2 ? $rootElement[j] = $rootElement[j2] : delete $rootElement[j];
                                    $rootElement.length -= removeCount - 1;
                                    break
                                }
                        parent && parent.replaceChild(newNode, firstElementToRemove);
                        var fragment = document.createDocumentFragment();
                        fragment.appendChild(firstElementToRemove),
                            newNode[jqLite.expando] = firstElementToRemove[jqLite.expando];
                        for (var k = 1,
                                kk = elementsToRemove.length; kk > k; k++) {
                            var element = elementsToRemove[k];
                            jqLite(element).remove(),
                                fragment.appendChild(element),
                                delete elementsToRemove[k]
                        }
                        elementsToRemove[0] = newNode,
                            elementsToRemove.length = 1
                    }

                    function cloneAndAnnotateFn(fn, annotation) {
                        return extend(function () {
                                return fn.apply(null, arguments)
                            },
                            fn, annotation)
                    }
                    var Attributes = function (element, attr) {
                        this.$$element = element,
                            this.$attr = attr || {}
                    };
                    Attributes.prototype = {
                        $normalize: directiveNormalize,
                        $addClass: function (classVal) {
                            classVal && classVal.length > 0 && $animate.addClass(this.$$element, classVal)
                        },
                        $removeClass: function (classVal) {
                            classVal && classVal.length > 0 && $animate.removeClass(this.$$element, classVal)
                        },
                        $updateClass: function (newClasses, oldClasses) {
                            this.$removeClass(tokenDifference(oldClasses, newClasses)),
                                this.$addClass(tokenDifference(newClasses, oldClasses))
                        },
                        $set: function (key, value, writeAttr, attrName) {
                            var nodeName, booleanKey = getBooleanAttrName(this.$$element[0], key);
                            booleanKey && (this.$$element.prop(key, value), attrName = booleanKey),
                                this[key] = value,
                                attrName ? this.$attr[key] = attrName : (attrName = this.$attr[key], attrName || (this.$attr[key] = attrName = snake_case(key, "-"))),
                                nodeName = nodeName_(this.$$element),
                                ("A" === nodeName && "href" === key || "IMG" === nodeName && "src" === key) && (this[key] = value = $$sanitizeUri(value, "src" === key)),
                                writeAttr !== !1 && (null === value || value === undefined ? this.$$element.removeAttr(attrName) : this.$$element.attr(attrName, value));
                            var $$observers = this.$$observers;
                            $$observers && forEach($$observers[key],
                                function (fn) {
                                    try {
                                        fn(value)
                                    } catch (e) {
                                        $exceptionHandler(e)
                                    }
                                })
                        },
                        $observe: function (key, fn) {
                            var attrs = this,
                                $$observers = attrs.$$observers || (attrs.$$observers = {}),
                                listeners = $$observers[key] || ($$observers[key] = []);
                            return listeners.push(fn),
                                $rootScope.$evalAsync(function () {
                                    listeners.$$inter || fn(attrs[key])
                                }),
                                fn
                        }
                    };
                    var startSymbol = $interpolate.startSymbol(),
                        endSymbol = $interpolate.endSymbol(),
                        denormalizeTemplate = "{{" == startSymbol || "}}" == endSymbol ? identity : function (template) {
                            return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol)
                        },
                        NG_ATTR_BINDING = /^ngAttr[A-Z]/;
                    return compile
                }
            ]
    }

    function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ""))
    }

    function tokenDifference(str1, str2) {
        var values = "",
            tokens1 = str1.split(/\s+/),
            tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
            for (var token = tokens1[i], j = 0; j < tokens2.length; j++)
                if (token == tokens2[j]) continue outer;
            values += (values.length > 0 ? " " : "") + token
        }
        return values
    }

    function $ControllerProvider() {
        var controllers = {},
            CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
        this.register = function (name, constructor) {
                assertNotHasOwnProperty(name, "controller"),
                    isObject(name) ? extend(controllers, name) : controllers[name] = constructor
            },
            this.$get = ["$injector", "$window",
                function ($injector, $window) {
                    return function (expression, locals) {
                        var instance, match, constructor, identifier;
                        if (isString(expression) && (match = expression.match(CNTRL_REG), constructor = match[1], identifier = match[3], expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, !0) || getter($window, constructor, !0), assertArgFn(expression, constructor, !0)), instance = $injector.instantiate(expression, locals), identifier) {
                            if (!locals || "object" != typeof locals.$scope) throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", constructor || expression.name, identifier);
                            locals.$scope[identifier] = instance
                        }
                        return instance
                    }
                }
            ]
    }

    function $DocumentProvider() {
        this.$get = ["$window",
            function (window) {
                return jqLite(window.document)
            }
        ]
    }

    function $ExceptionHandlerProvider() {
        this.$get = ["$log",
            function ($log) {
                return function () {
                    $log.error.apply($log, arguments)
                }
            }
        ]
    }

    function parseHeaders(headers) {
        var key, val, i, parsed = {};
        return headers ? (forEach(headers.split("\n"),
            function (line) {
                i = line.indexOf(":"),
                    key = lowercase(trim(line.substr(0, i))),
                    val = trim(line.substr(i + 1)),
                    key && (parsed[key] ? parsed[key] += ", " + val : parsed[key] = val)
            }), parsed) : parsed
    }

    function headersGetter(headers) {
        var headersObj = isObject(headers) ? headers : undefined;
        return function (name) {
            return headersObj || (headersObj = parseHeaders(headers)),
                name ? headersObj[lowercase(name)] || null : headersObj
        }
    }

    function transformData(data, headers, fns) {
        return isFunction(fns) ? fns(data, headers) : (forEach(fns,
            function (fn) {
                data = fn(data, headers)
            }), data)
    }

    function isSuccess(status) {
        return status >= 200 && 300 > status
    }

    function $HttpProvider() {
        var JSON_START = /^\s*(\[|\{[^\{])/,
            JSON_END = /[\}\]]\s*$/,
            PROTECTION_PREFIX = /^\)\]\}',?\n/,
            CONTENT_TYPE_APPLICATION_JSON = {
                "Content-Type": "application/json;charset=utf-8"
            },
            defaults = this.defaults = {
                transformResponse: [function (data) {
                    return isString(data) && (data = data.replace(PROTECTION_PREFIX, ""), JSON_START.test(data) && JSON_END.test(data) && (data = fromJson(data))),
                        data
                }],
                transformRequest: [function (d) {
                    return isObject(d) && !isFile(d) ? toJson(d) : d
                }],
                headers: {
                    common: {
                        Accept: "application/json, text/plain, */*"
                    },
                    post: CONTENT_TYPE_APPLICATION_JSON,
                    put: CONTENT_TYPE_APPLICATION_JSON,
                    patch: CONTENT_TYPE_APPLICATION_JSON
                },
                xsrfCookieName: "XSRF-TOKEN",
                xsrfHeaderName: "X-XSRF-TOKEN"
            },
            interceptorFactories = this.interceptors = [],
            responseInterceptorFactories = this.responseInterceptors = [];
        this.$get = ["$httpBackend", "$browser", "$cacheFactory", "$rootScope", "$q", "$injector",
            function ($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
                function $http(requestConfig) {
                    function transformResponse(response) {
                        var resp = extend({},
                            response, {
                                data: transformData(response.data, response.headers, config.transformResponse)
                            });
                        return isSuccess(response.status) ? resp : $q.reject(resp)
                    }

                    function mergeHeaders(config) {
                        function execHeaders(headers) {
                            var headerContent;
                            forEach(headers,
                                function (headerFn, header) {
                                    isFunction(headerFn) && (headerContent = headerFn(), null != headerContent ? headers[header] = headerContent : delete headers[header])
                                })
                        }
                        var defHeaderName, lowercaseDefHeaderName, reqHeaderName, defHeaders = defaults.headers,
                            reqHeaders = extend({},
                                config.headers);
                        defHeaders = extend({},
                                defHeaders.common, defHeaders[lowercase(config.method)]),
                            execHeaders(defHeaders),
                            execHeaders(reqHeaders);
                        defaultHeadersIteration: for (defHeaderName in defHeaders) {
                            lowercaseDefHeaderName = lowercase(defHeaderName);
                            for (reqHeaderName in reqHeaders)
                                if (lowercase(reqHeaderName) === lowercaseDefHeaderName) continue defaultHeadersIteration;
                            reqHeaders[defHeaderName] = defHeaders[defHeaderName]
                        }
                        return reqHeaders
                    }
                    var config = {
                            transformRequest: defaults.transformRequest,
                            transformResponse: defaults.transformResponse
                        },
                        headers = mergeHeaders(requestConfig);
                    extend(config, requestConfig),
                        config.headers = headers,
                        config.method = uppercase(config.method);
                    var xsrfValue = urlIsSameOrigin(config.url) ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                    xsrfValue && (headers[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue);
                    var serverRequest = function (config) {
                            headers = config.headers;
                            var reqData = transformData(config.data, headersGetter(headers), config.transformRequest);
                            return isUndefined(config.data) && forEach(headers,
                                    function (value, header) {
                                        "content-type" === lowercase(header) && delete headers[header]
                                    }),
                                isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials) && (config.withCredentials = defaults.withCredentials),
                                sendReq(config, reqData, headers).then(transformResponse, transformResponse)
                        },
                        chain = [serverRequest, undefined],
                        promise = $q.when(config);
                    for (forEach(reversedInterceptors,
                            function (interceptor) {
                                (interceptor.request || interceptor.requestError) && chain.unshift(interceptor.request, interceptor.requestError),
                                    (interceptor.response || interceptor.responseError) && chain.push(interceptor.response, interceptor.responseError)
                            }); chain.length;) {
                        var thenFn = chain.shift(),
                            rejectFn = chain.shift();
                        promise = promise.then(thenFn, rejectFn)
                    }
                    return promise.success = function (fn) {
                            return promise.then(function (response) {
                                    fn(response.data, response.status, response.headers, config)
                                }),
                                promise
                        },
                        promise.error = function (fn) {
                            return promise.then(null,
                                    function (response) {
                                        fn(response.data, response.status, response.headers, config)
                                    }),
                                promise
                        },
                        promise
                }

                function createShortMethods() {
                    forEach(arguments,
                        function (name) {
                            $http[name] = function (url, config) {
                                return $http(extend(config || {}, {
                                    method: name,
                                    url: url
                                }))
                            }
                        })
                }

                function createShortMethodsWithData() {
                    forEach(arguments,
                        function (name) {
                            $http[name] = function (url, data, config) {
                                return $http(extend(config || {}, {
                                    method: name,
                                    url: url,
                                    data: data
                                }))
                            }
                        })
                }

                function sendReq(config, reqData, reqHeaders) {
                    function done(status, response, headersString) {
                        cache && (isSuccess(status) ? cache.put(url, [status, response, parseHeaders(headersString)]) : cache.remove(url)),
                            resolvePromise(response, status, headersString),
                            $rootScope.$$phase || $rootScope.$apply()
                    }

                    function resolvePromise(response, status, headers) {
                        status = Math.max(status, 0),
                            (isSuccess(status) ? deferred.resolve : deferred.reject)({
                                data: response,
                                status: status,
                                headers: headersGetter(headers),
                                config: config
                            })
                    }

                    function removePendingReq() {
                        var idx = indexOf($http.pendingRequests, config); - 1 !== idx && $http.pendingRequests.splice(idx, 1)
                    }
                    var cache, cachedResp, deferred = $q.defer(),
                        promise = deferred.promise,
                        url = buildUrl(config.url, config.params);
                    if ($http.pendingRequests.push(config), promise.then(removePendingReq, removePendingReq), (config.cache || defaults.cache) && config.cache !== !1 && "GET" == config.method && (cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache), cache)
                        if (cachedResp = cache.get(url), isDefined(cachedResp)) {
                            if (cachedResp.then) return cachedResp.then(removePendingReq, removePendingReq),
                                cachedResp;
                            isArray(cachedResp) ? resolvePromise(cachedResp[1], cachedResp[0], copy(cachedResp[2])) : resolvePromise(cachedResp, 200, {})
                        } else cache.put(url, promise);
                    return isUndefined(cachedResp) && $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType),
                        promise
                }

                function buildUrl(url, params) {
                    if (!params) return url;
                    var parts = [];
                    return forEachSorted(params,
                            function (value, key) {
                                null === value || isUndefined(value) || (isArray(value) || (value = [value]), forEach(value,
                                    function (v) {
                                        isObject(v) && (v = toJson(v)),
                                            parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(v))
                                    }))
                            }),
                        url + (-1 == url.indexOf("?") ? "?" : "&") + parts.join("&")
                }
                var defaultCache = $cacheFactory("$http"),
                    reversedInterceptors = [];
                return forEach(interceptorFactories,
                        function (interceptorFactory) {
                            reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory))
                        }),
                    forEach(responseInterceptorFactories,
                        function (interceptorFactory, index) {
                            var responseFn = isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory);
                            reversedInterceptors.splice(index, 0, {
                                response: function (response) {
                                    return responseFn($q.when(response))
                                },
                                responseError: function (response) {
                                    return responseFn($q.reject(response))
                                }
                            })
                        }),
                    $http.pendingRequests = [],
                    createShortMethods("get", "delete", "head", "jsonp"),
                    createShortMethodsWithData("post", "put"),
                    $http.defaults = defaults,
                    $http
            }
        ]
    }

    function $HttpBackendProvider() {
        this.$get = ["$browser", "$window", "$document",
            function ($browser, $window, $document) {
                return createHttpBackend($browser, XHR, $browser.defer, $window.angular.callbacks, $document[0])
            }
        ]
    }

    function createHttpBackend($browser, XHR, $browserDefer, callbacks, rawDocument) {
		function jsonpReq(url, done) {
			var script = rawDocument.createElement("script"),
				doneWrapper = function () {
					script.onreadystatechange = script.onload = script.onerror = null,
						rawDocument.body.removeChild(script),
						done && done()
				};
			return script.type = "text/javascript",
				script.src = url,
				msie && 8 >= msie ? script.onreadystatechange = function () {
					/ loaded | complete /.test(script.readyState) && doneWrapper()
				} : script.onload = script.onerror = function () {
					doneWrapper()
				},
				rawDocument.body.appendChild(script),
				doneWrapper
		}
      
        var ABORTED = -1;
        return function (method, url, post, callback, headers, timeout, withCredentials, responseType) {
            function timeoutRequest() {
                status = ABORTED,
                    jsonpDone && jsonpDone(),
                    xhr && xhr.abort()
            }

            function completeRequest(callback, status, response, headersString) {
                var protocol = urlResolve(url).protocol;
                timeoutId && $browserDefer.cancel(timeoutId),
                    jsonpDone = xhr = null,
                    status = "file" == protocol && 0 === status ? response ? 200 : 404 : status,
                    status = 1223 == status ? 204 : status,
                    callback(status, response, headersString),
                    $browser.$$completeOutstandingRequest(noop)
            }
            var status;
            if ($browser.$$incOutstandingRequestCount(), url = url || $browser.url(), "jsonp" == lowercase(method)) {
                var callbackId = "_" + (callbacks.counter++).toString(36);
                callbacks[callbackId] = function (data) {
                    callbacks[callbackId].data = data
                };
                var jsonpDone = jsonpReq(url.replace("JSON_CALLBACK", "angular.callbacks." + callbackId),
                    function () {
                        callbacks[callbackId].data ? completeRequest(callback, 200, callbacks[callbackId].data) : completeRequest(callback, status || -2),
                            delete callbacks[callbackId]
                    })
            } else {
                var xhr = new XHR;
                xhr.open(method, url, !0),
                    forEach(headers,
                        function (value, key) {
                            isDefined(value) && xhr.setRequestHeader(key, value)
                        }),
                    xhr.onreadystatechange = function () {
                        if (4 == xhr.readyState) {
                            var responseHeaders = null,
                                response = null;
                            status !== ABORTED && (responseHeaders = xhr.getAllResponseHeaders(), response = xhr.responseType ? xhr.response : xhr.responseText),
                                completeRequest(callback, status || xhr.status, response, responseHeaders)
                        }
                    },
                    withCredentials && (xhr.withCredentials = !0),
                    responseType && (xhr.responseType = responseType),
                    xhr.send(post || null)
            }
            if (timeout > 0) var timeoutId = $browserDefer(timeoutRequest, timeout);
            else timeout && timeout.then && timeout.then(timeoutRequest)
        }
    }

    function $InterpolateProvider() {
        var startSymbol = "{{",
            endSymbol = "}}";
        this.startSymbol = function (value) {
                return value ? (startSymbol = value, this) : startSymbol
            },
            this.endSymbol = function (value) {
                return value ? (endSymbol = value, this) : endSymbol
            },
            this.$get = ["$parse", "$exceptionHandler", "$sce",
                function ($parse, $exceptionHandler, $sce) {
                    function $interpolate(text, mustHaveExpression, trustedContext) {
                        for (var startIndex, endIndex, fn, exp, index = 0,
                                parts = [], length = text.length, hasInterpolation = !1, concat = []; length > index;) - 1 != (startIndex = text.indexOf(startSymbol, index)) && -1 != (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) ? (index != startIndex && parts.push(text.substring(index, startIndex)), parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex))), fn.exp = exp, index = endIndex + endSymbolLength, hasInterpolation = !0) : (index != length && parts.push(text.substring(index)), index = length);
                        if ((length = parts.length) || (parts.push(""), length = 1), trustedContext && parts.length > 1) throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce", text);
                        return !mustHaveExpression || hasInterpolation ? (concat.length = length, fn = function (context) {
                                try {
                                    for (var part, i = 0,
                                            ii = length; ii > i; i++) "function" == typeof (part = parts[i]) && (part = part(context), part = trustedContext ? $sce.getTrusted(trustedContext, part) : $sce.valueOf(part), null === part || isUndefined(part) ? part = "" : "string" != typeof part && (part = toJson(part))),
                                        concat[i] = part;
                                    return concat.join("")
                                } catch (err) {
                                    var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
                                    $exceptionHandler(newErr)
                                }
                            },
                            fn.exp = text, fn.parts = parts, fn) : void 0
                    }
                    var startSymbolLength = startSymbol.length,
                        endSymbolLength = endSymbol.length;
                    return $interpolate.startSymbol = function () {
                            return startSymbol
                        },
                        $interpolate.endSymbol = function () {
                            return endSymbol
                        },
                        $interpolate
                }
            ]
    }

    function $IntervalProvider() {
        this.$get = ["$rootScope", "$window", "$q",
            function ($rootScope, $window, $q) {
                function interval(fn, delay, count, invokeApply) {
                    var setInterval = $window.setInterval,
                        clearInterval = $window.clearInterval,
                        deferred = $q.defer(),
                        promise = deferred.promise,
                        iteration = 0,
                        skipApply = isDefined(invokeApply) && !invokeApply;
                    return count = isDefined(count) ? count : 0,
                        promise.then(null, null, fn),
                        promise.$$intervalId = setInterval(function () {
                                deferred.notify(iteration++),
                                    count > 0 && iteration >= count && (deferred.resolve(iteration), clearInterval(promise.$$intervalId), delete intervals[promise.$$intervalId]),
                                    skipApply || $rootScope.$apply()
                            },
                            delay),
                        intervals[promise.$$intervalId] = deferred,
                        promise
                }
                var intervals = {};
                return interval.cancel = function (promise) {
                        return promise && promise.$$intervalId in intervals ? (intervals[promise.$$intervalId].reject("canceled"), clearInterval(promise.$$intervalId), delete intervals[promise.$$intervalId], !0) : !1
                    },
                    interval
            }
        ]
    }

    function $LocaleProvider() {
        this.$get = function () {
            return {
                id: "en-us",
                NUMBER_FORMATS: {
                    DECIMAL_SEP: ".",
                    GROUP_SEP: ",",
                    PATTERNS: [{
                            minInt: 1,
                            minFrac: 0,
                            maxFrac: 3,
                            posPre: "",
                            posSuf: "",
                            negPre: "-",
                            negSuf: "",
                            gSize: 3,
                            lgSize: 3
                        },
                        {
                            minInt: 1,
                            minFrac: 2,
                            maxFrac: 2,
                            posPre: "¤",
                            posSuf: "",
                            negPre: "(¤",
                            negSuf: ")",
                            gSize: 3,
                            lgSize: 3
                        }
                    ],
                    CURRENCY_SYM: "$"
                },
                DATETIME_FORMATS: {
                    MONTH: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
                    SHORTMONTH: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
                    DAY: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
                    SHORTDAY: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(","),
                    AMPMS: ["AM", "PM"],
                    medium: "MMM d, y h:mm:ss a",
                    "short": "M/d/yy h:mm a",
                    fullDate: "EEEE, MMMM d, y",
                    longDate: "MMMM d, y",
                    mediumDate: "MMM d, y",
                    shortDate: "M/d/yy",
                    mediumTime: "h:mm:ss a",
                    shortTime: "h:mm a"
                },
                pluralCat: function (num) {
                    return 1 === num ? "one" : "other"
                }
            }
        }
    }

    function encodePath(path) {
        for (var segments = path.split("/"), i = segments.length; i--;) segments[i] = encodeUriSegment(segments[i]);
        return segments.join("/")
    }

    function parseAbsoluteUrl(absoluteUrl, locationObj, appBase) {
        var parsedUrl = urlResolve(absoluteUrl, appBase);
        locationObj.$$protocol = parsedUrl.protocol,
            locationObj.$$host = parsedUrl.hostname,
            locationObj.$$port = int(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null
    }

    function parseAppUrl(relativeUrl, locationObj, appBase) {
        var prefixed = "/" !== relativeUrl.charAt(0);
        prefixed && (relativeUrl = "/" + relativeUrl);
        var match = urlResolve(relativeUrl, appBase);
        locationObj.$$path = decodeURIComponent(prefixed && "/" === match.pathname.charAt(0) ? match.pathname.substring(1) : match.pathname),
            locationObj.$$search = parseKeyValue(match.search),
            locationObj.$$hash = decodeURIComponent(match.hash),
            locationObj.$$path && "/" != locationObj.$$path.charAt(0) && (locationObj.$$path = "/" + locationObj.$$path)
    }

    function beginsWith(begin, whole) {
        return 0 === whole.indexOf(begin) ? whole.substr(begin.length) : void 0
    }

    function stripHash(url) {
        var index = url.indexOf("#");
        return -1 == index ? url : url.substr(0, index)
    }

    function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf("/") + 1)
    }

    function serverBase(url) {
        return url.substring(0, url.indexOf("/", url.indexOf("//") + 2))
    }

    function LocationHtml5Url(appBase, basePrefix) {
        this.$$html5 = !0,
            basePrefix = basePrefix || "";
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this, appBase),
            this.$$parse = function (url) {
                var pathUrl = beginsWith(appBaseNoFile, url);
                if (!isString(pathUrl)) throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
                parseAppUrl(pathUrl, this, appBase),
                    this.$$path || (this.$$path = "/"),
                    this.$$compose()
            },
            this.$$compose = function () {
                var search = toKeyValue(this.$$search),
                    hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
                this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash,
                    this.$$absUrl = appBaseNoFile + this.$$url.substr(1)
            },
            this.$$rewrite = function (url) {
                var appUrl, prevAppUrl;
                return (appUrl = beginsWith(appBase, url)) !== undefined ? (prevAppUrl = appUrl, (appUrl = beginsWith(basePrefix, appUrl)) !== undefined ? appBaseNoFile + (beginsWith("/", appUrl) || appUrl) : appBase + prevAppUrl) : (appUrl = beginsWith(appBaseNoFile, url)) !== undefined ? appBaseNoFile + appUrl : appBaseNoFile == url + "/" ? appBaseNoFile : void 0
            }
    }

    function LocationHashbangUrl(appBase, hashPrefix) {
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this, appBase),
            this.$$parse = function (url) {
                function removeWindowsDriveName(path, url, base) {
                    var firstPathSegmentMatch, windowsFilePathExp = /^\/?.*?:(\/.*)/;
                    return 0 === url.indexOf(base) && (url = url.replace(base, "")),
                        windowsFilePathExp.exec(url) ? path : (firstPathSegmentMatch = windowsFilePathExp.exec(path), firstPathSegmentMatch ? firstPathSegmentMatch[1] : path)
                }
                var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url),
                    withoutHashUrl = "#" == withoutBaseUrl.charAt(0) ? beginsWith(hashPrefix, withoutBaseUrl) : this.$$html5 ? withoutBaseUrl : "";
                if (!isString(withoutHashUrl)) throw $locationMinErr("ihshprfx", 'Invalid url "{0}", missing hash prefix "{1}".', url, hashPrefix);
                parseAppUrl(withoutHashUrl, this, appBase),
                    this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase),
                    this.$$compose()
            },
            this.$$compose = function () {
                var search = toKeyValue(this.$$search),
                    hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
                this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash,
                    this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "")
            },
            this.$$rewrite = function (url) {
                return stripHash(appBase) == stripHash(url) ? url : void 0
            }
    }

    function LocationHashbangInHtml5Url(appBase, hashPrefix) {
        this.$$html5 = !0,
            LocationHashbangUrl.apply(this, arguments);
        var appBaseNoFile = stripFile(appBase);
        this.$$rewrite = function (url) {
            var appUrl;
            return appBase == stripHash(url) ? url : (appUrl = beginsWith(appBaseNoFile, url)) ? appBase + hashPrefix + appUrl : appBaseNoFile === url + "/" ? appBaseNoFile : void 0
        }
    }

    function locationGetter(property) {
        return function () {
            return this[property]
        }
    }

    function locationGetterSetter(property, preprocess) {
        return function (value) {
            return isUndefined(value) ? this[property] : (this[property] = preprocess(value), this.$$compose(), this)
        }
    }

    function $LocationProvider() {
        var hashPrefix = "",
            html5Mode = !1;
        this.hashPrefix = function (prefix) {
                return isDefined(prefix) ? (hashPrefix = prefix, this) : hashPrefix
            },
            this.html5Mode = function (mode) {
                return isDefined(mode) ? (html5Mode = mode, this) : html5Mode
            },
            this.$get = ["$rootScope", "$browser", "$sniffer", "$rootElement",
                function ($rootScope, $browser, $sniffer, $rootElement) {
                    function afterLocationChange(oldUrl) {
                        $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl)
                    }
                    var $location, LocationMode, appBase, baseHref = $browser.baseHref(),
                        initialUrl = $browser.url();
                    html5Mode ? (appBase = serverBase(initialUrl) + (baseHref || "/"), LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url) : (appBase = stripHash(initialUrl), LocationMode = LocationHashbangUrl),
                        $location = new LocationMode(appBase, "#" + hashPrefix),
                        $location.$$parse($location.$$rewrite(initialUrl)),
                        $rootElement.on("click",
                            function (event) {
                                if (!event.ctrlKey && !event.metaKey && 2 != event.which) {
                                    for (var elm = jqLite(event.target);
                                        "a" !== lowercase(elm[0].nodeName);)
                                        if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                                    var absHref = elm.prop("href"),
                                        rewrittenUrl = $location.$$rewrite(absHref);
                                    absHref && !elm.attr("target") && rewrittenUrl && !event.isDefaultPrevented() && (event.preventDefault(), rewrittenUrl != $browser.url() && ($location.$$parse(rewrittenUrl), $rootScope.$apply(), window.angular["ff-684208-preventDefault"] = !0))
                                }
                            }),
                        $location.absUrl() != initialUrl && $browser.url($location.absUrl(), !0),
                        $browser.onUrlChange(function (newUrl) {
                            if ($location.absUrl() != newUrl) {
                                if ($rootScope.$broadcast("$locationChangeStart", newUrl, $location.absUrl()).defaultPrevented) return void $browser.url($location.absUrl());
                                $rootScope.$evalAsync(function () {
                                        var oldUrl = $location.absUrl();
                                        $location.$$parse(newUrl),
                                            afterLocationChange(oldUrl)
                                    }),
                                    $rootScope.$$phase || $rootScope.$digest()
                            }
                        });
                    var changeCounter = 0;
                    return $rootScope.$watch(function () {
                            var oldUrl = $browser.url(),
                                currentReplace = $location.$$replace;
                            return changeCounter && oldUrl == $location.absUrl() || (changeCounter++, $rootScope.$evalAsync(function () {
                                    $rootScope.$broadcast("$locationChangeStart", $location.absUrl(), oldUrl).defaultPrevented ? $location.$$parse(oldUrl) : ($browser.url($location.absUrl(), currentReplace), afterLocationChange(oldUrl))
                                })),
                                $location.$$replace = !1,
                                changeCounter
                        }),
                        $location
                }
            ]
    }

    function $LogProvider() {
        var debug = !0,
            self = this;
        this.debugEnabled = function (flag) {
                return isDefined(flag) ? (debug = flag, this) : debug
            },
            this.$get = ["$window",
                function ($window) {
                    function formatError(arg) {
                        return arg instanceof Error && (arg.stack ? arg = arg.message && -1 === arg.stack.indexOf(arg.message) ? "Error: " + arg.message + "\n" + arg.stack : arg.stack : arg.sourceURL && (arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line)),
                            arg
                    }

                    function consoleLog(type) {
                        var console = $window.console || {},
                            logFn = console[type] || console.log || noop;
                        return logFn.apply ?
                            function () {
                                var args = [];
                                return forEach(arguments,
                                        function (arg) {
                                            args.push(formatError(arg))
                                        }),
                                    logFn.apply(console, args)
                            } : function (arg1, arg2) {
                                logFn(arg1, null == arg2 ? "" : arg2)
                            }
                    }
                    return {
                        log: consoleLog("log"),
                        info: consoleLog("info"),
                        warn: consoleLog("warn"),
                        error: consoleLog("error"),
                        debug: function () {
                            var fn = consoleLog("debug");
                            return function () {
                                debug && fn.apply(self, arguments)
                            }
                        }()
                    }
                }
            ]
    }

    function ensureSafeMemberName(name, fullExpression) {
        if ("constructor" === name) throw $parseMinErr("isecfld", 'Referencing "constructor" field in Angular expressions is disallowed! Expression: {0}', fullExpression);
        return name
    }

    function ensureSafeObject(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj.document && obj.location && obj.alert && obj.setInterval) throw $parseMinErr("isecwindow", "Referencing the Window in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj.children && (obj.nodeName || obj.on && obj.find)) throw $parseMinErr("isecdom", "Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}", fullExpression)
        }
        return obj
    }

    function setter(obj, path, setValue, fullExp, options) {
        options = options || {};
        for (var key, element = path.split("."), i = 0; element.length > 1; i++) {
            key = ensureSafeMemberName(element.shift(), fullExp);
            var propertyObj = obj[key];
            propertyObj || (propertyObj = {},
                    obj[key] = propertyObj),
                obj = propertyObj,
                obj.then && options.unwrapPromises && (promiseWarning(fullExp), "$$v" in obj || !
                    function (promise) {
                        promise.then(function (val) {
                            promise.$$v = val
                        })
                    }(obj), obj.$$v === undefined && (obj.$$v = {}), obj = obj.$$v)
        }
        return key = ensureSafeMemberName(element.shift(), fullExp),
            obj[key] = setValue,
            setValue
    }

    function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp, options) {
        return ensureSafeMemberName(key0, fullExp),
            ensureSafeMemberName(key1, fullExp),
            ensureSafeMemberName(key2, fullExp),
            ensureSafeMemberName(key3, fullExp),
            ensureSafeMemberName(key4, fullExp),
            options.unwrapPromises ?
            function (scope, locals) {
                var promise, pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope;
                return null === pathVal || pathVal === undefined ? pathVal : (pathVal = pathVal[key0], pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, promise.$$v = undefined, promise.then(function (val) {
                    promise.$$v = val
                })), pathVal = pathVal.$$v), key1 && null !== pathVal && pathVal !== undefined ? (pathVal = pathVal[key1], pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, promise.$$v = undefined, promise.then(function (val) {
                    promise.$$v = val
                })), pathVal = pathVal.$$v), key2 && null !== pathVal && pathVal !== undefined ? (pathVal = pathVal[key2], pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, promise.$$v = undefined, promise.then(function (val) {
                    promise.$$v = val
                })), pathVal = pathVal.$$v), key3 && null !== pathVal && pathVal !== undefined ? (pathVal = pathVal[key3], pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, promise.$$v = undefined, promise.then(function (val) {
                    promise.$$v = val
                })), pathVal = pathVal.$$v), key4 && null !== pathVal && pathVal !== undefined ? (pathVal = pathVal[key4], pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, promise.$$v = undefined, promise.then(function (val) {
                    promise.$$v = val
                })), pathVal = pathVal.$$v), pathVal) : pathVal) : pathVal) : pathVal) : pathVal)
            } : function (scope, locals) {
                var pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope;
                return null === pathVal || pathVal === undefined ? pathVal : (pathVal = pathVal[key0], key1 && null !== pathVal && pathVal !== undefined ? (pathVal = pathVal[key1], key2 && null !== pathVal && pathVal !== undefined ? (pathVal = pathVal[key2], key3 && null !== pathVal && pathVal !== undefined ? (pathVal = pathVal[key3], key4 && null !== pathVal && pathVal !== undefined ? pathVal = pathVal[key4] : pathVal) : pathVal) : pathVal) : pathVal)
            }
    }

    function getterFn(path, options, fullExp) {
        if (getterFnCache.hasOwnProperty(path)) return getterFnCache[path];
        var fn, pathKeys = path.split("."),
            pathKeysLength = pathKeys.length;
        if (options.csp) fn = 6 > pathKeysLength ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp, options) : function (scope, locals) {
            var val, i = 0;
            do val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], fullExp, options)(scope, locals),
                locals = undefined,
                scope = val;
            while (pathKeysLength > i);
            return val
        };
        else {
            var code = "var l, fn, p;\n";
            forEach(pathKeys,
                    function (key, index) {
                        ensureSafeMemberName(key, fullExp),
                            code += "if(s === null || s === undefined) return s;\nl=s;\ns=" + (index ? "s" : '((k&&k.hasOwnProperty("' + key + '"))?k:s)') + '["' + key + '"];\n' + (options.unwrapPromises ? 'if (s && s.then) {\n pw("' + fullExp.replace(/(["\r\n])/g, "\\$1") + '");\n if (!("$$v" in s)) {\n p=s;\n p.$$v = undefined;\n p.then(function(v) {p.$$v=v;});\n}\n s=s.$$v\n}\n' : "")
                    }),
                code += "return s;";
            var evaledFnGetter = new Function("s", "k", "pw", code);
            evaledFnGetter.toString = function () {
                    return code
                },
                fn = function (scope, locals) {
                    return evaledFnGetter(scope, locals, promiseWarning)
                }
        }
        return "hasOwnProperty" !== path && (getterFnCache[path] = fn),
            fn
    }

    function $ParseProvider() {
        var cache = {},
            $parseOptions = {
                csp: !1,
                unwrapPromises: !1,
                logPromiseWarnings: !0
            };
        this.unwrapPromises = function (value) {
                return isDefined(value) ? ($parseOptions.unwrapPromises = !!value, this) : $parseOptions.unwrapPromises
            },
            this.logPromiseWarnings = function (value) {
                return isDefined(value) ? ($parseOptions.logPromiseWarnings = value, this) : $parseOptions.logPromiseWarnings
            },
            this.$get = ["$filter", "$sniffer", "$log",
                function ($filter, $sniffer, $log) {
                    return $parseOptions.csp = $sniffer.csp,
                        promiseWarning = function (fullExp) {
                            $parseOptions.logPromiseWarnings && !promiseWarningCache.hasOwnProperty(fullExp) && (promiseWarningCache[fullExp] = !0, $log.warn("[$parse] Promise found in the expression `" + fullExp + "`. Automatic unwrapping of promises in Angular expressions is deprecated."))
                        },
                        function (exp) {
                            var parsedExpression;
                            switch (typeof exp) {
                                case "string":
                                    if (cache.hasOwnProperty(exp)) return cache[exp];
                                    var lexer = new Lexer($parseOptions),
                                        parser = new Parser(lexer, $filter, $parseOptions);
                                    return parsedExpression = parser.parse(exp, !1),
                                        "hasOwnProperty" !== exp && (cache[exp] = parsedExpression),
                                        parsedExpression;
                                case "function":
                                    return exp;
                                default:
                                    return noop
                            }
                        }
                }
            ]
    }

    function $QProvider() {
        this.$get = ["$rootScope", "$exceptionHandler",
            function ($rootScope, $exceptionHandler) {
                return qFactory(function (callback) {
                        $rootScope.$evalAsync(callback)
                    },
                    $exceptionHandler)
            }
        ]
    }

    function qFactory(nextTick, exceptionHandler) {
        function defaultCallback(value) {
            return value
        }

        function defaultErrback(reason) {
            return reject(reason)
        }

        function all(promises) {
            var deferred = defer(),
                counter = 0,
                results = isArray(promises) ? [] : {};
            return forEach(promises,
                    function (promise, key) {
                        counter++,
                        ref(promise).then(function (value) {
                                results.hasOwnProperty(key) || (results[key] = value, --counter || deferred.resolve(results))
                            },
                            function (reason) {
                                results.hasOwnProperty(key) || deferred.reject(reason)
                            })
                    }),
                0 === counter && deferred.resolve(results),
                deferred.promise
        }
        var defer = function () {
                var value, deferred, pending = [];
                return deferred = {
                    resolve: function (val) {
                        if (pending) {
                            var callbacks = pending;
                            pending = undefined,
                                value = ref(val),
                                callbacks.length && nextTick(function () {
                                    for (var callback, i = 0,
                                            ii = callbacks.length; ii > i; i++) callback = callbacks[i],
                                        value.then(callback[0], callback[1], callback[2])
                                })
                        }
                    },
                    reject: function (reason) {
                        deferred.resolve(reject(reason))
                    },
                    notify: function (progress) {
                        if (pending) {
                            var callbacks = pending;
                            pending.length && nextTick(function () {
                                for (var callback, i = 0,
                                        ii = callbacks.length; ii > i; i++) callback = callbacks[i],
                                    callback[2](progress)
                            })
                        }
                    },
                    promise: {
                        then: function (callback, errback, progressback) {
                            var result = defer(),
                                wrappedCallback = function (value) {
                                    try {
                                        result.resolve((isFunction(callback) ? callback : defaultCallback)(value))
                                    } catch (e) {
                                        result.reject(e),
                                            exceptionHandler(e)
                                    }
                                },
                                wrappedErrback = function (reason) {
                                    try {
                                        result.resolve((isFunction(errback) ? errback : defaultErrback)(reason))
                                    } catch (e) {
                                        result.reject(e),
                                            exceptionHandler(e)
                                    }
                                },
                                wrappedProgressback = function (progress) {
                                    try {
                                        result.notify((isFunction(progressback) ? progressback : defaultCallback)(progress))
                                    } catch (e) {
                                        exceptionHandler(e)
                                    }
                                };
                            return pending ? pending.push([wrappedCallback, wrappedErrback, wrappedProgressback]) : value.then(wrappedCallback, wrappedErrback, wrappedProgressback),
                                result.promise
                        },
                        "catch": function (callback) {
                            return this.then(null, callback)
                        },
                        "finally": function (callback) {
                            function makePromise(value, resolved) {
                                var result = defer();
                                return resolved ? result.resolve(value) : result.reject(value),
                                    result.promise
                            }

                            function handleCallback(value, isResolved) {
                                var callbackOutput = null;
                                try {
                                    callbackOutput = (callback || defaultCallback)()
                                } catch (e) {
                                    return makePromise(e, !1)
                                }
                                return callbackOutput && isFunction(callbackOutput.then) ? callbackOutput.then(function () {
                                        return makePromise(value, isResolved)
                                    },
                                    function (error) {
                                        return makePromise(error, !1)
                                    }) : makePromise(value, isResolved)
                            }
                            return this.then(function (value) {
                                    return handleCallback(value, !0)
                                },
                                function (error) {
                                    return handleCallback(error, !1)
                                })
                        }
                    }
                }
            },
            ref = function (value) {
                return value && isFunction(value.then) ? value : {
                    then: function (callback) {
                        var result = defer();
                        return nextTick(function () {
                                result.resolve(callback(value))
                            }),
                            result.promise
                    }
                }
            },
            reject = function (reason) {
                return {
                    then: function (callback, errback) {
                        var result = defer();
                        return nextTick(function () {
                                try {
                                    result.resolve((isFunction(errback) ? errback : defaultErrback)(reason))
                                } catch (e) {
                                    result.reject(e),
                                        exceptionHandler(e)
                                }
                            }),
                            result.promise
                    }
                }
            },
            when = function (value, callback, errback, progressback) {
                var done, result = defer(),
                    wrappedCallback = function (value) {
                        try {
                            return (isFunction(callback) ? callback : defaultCallback)(value)
                        } catch (e) {
                            return exceptionHandler(e),
                                reject(e)
                        }
                    },
                    wrappedErrback = function (reason) {
                        try {
                            return (isFunction(errback) ? errback : defaultErrback)(reason)
                        } catch (e) {
                            return exceptionHandler(e),
                                reject(e)
                        }
                    },
                    wrappedProgressback = function (progress) {
                        try {
                            return (isFunction(progressback) ? progressback : defaultCallback)(progress)
                        } catch (e) {
                            exceptionHandler(e)
                        }
                    };
                return nextTick(function () {
                        ref(value).then(function (value) {
                                done || (done = !0, result.resolve(ref(value).then(wrappedCallback, wrappedErrback, wrappedProgressback)))
                            },
                            function (reason) {
                                done || (done = !0, result.resolve(wrappedErrback(reason)))
                            },
                            function (progress) {
                                done || result.notify(wrappedProgressback(progress))
                            })
                    }),
                    result.promise
            };
        return {
            defer: defer,
            reject: reject,
            when: when,
            all: all
        }
    }

    function $RootScopeProvider() {
        var TTL = 10,
            $rootScopeMinErr = minErr("$rootScope"),
            lastDirtyWatch = null;
        this.digestTtl = function (value) {
                return arguments.length && (TTL = value),
                    TTL
            },
            this.$get = ["$injector", "$exceptionHandler", "$parse", "$browser",
                function ($injector, $exceptionHandler, $parse, $browser) {
                    function Scope() {
                        this.$id = nextUid(),
                            this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null,
                            this["this"] = this.$root = this,
                            this.$$destroyed = !1,
                            this.$$asyncQueue = [],
                            this.$$postDigestQueue = [],
                            this.$$listeners = {},
                            this.$$isolateBindings = {}
                    }

                    function beginPhase(phase) {
                        if ($rootScope.$$phase) throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                        $rootScope.$$phase = phase
                    }

                    function clearPhase() {
                        $rootScope.$$phase = null
                    }

                    function compileToFn(exp, name) {
                        var fn = $parse(exp);
                        return assertArgFn(fn, name),
                            fn
                    }

                    function initWatchVal() {}
                    Scope.prototype = {
                        constructor: Scope,
                        $new: function (isolate) {
                            var ChildScope, child;
                            return isolate ? (child = new Scope, child.$root = this.$root, child.$$asyncQueue = this.$$asyncQueue, child.$$postDigestQueue = this.$$postDigestQueue) : (ChildScope = function () {},
                                    ChildScope.prototype = this, child = new ChildScope, child.$id = nextUid()),
                                child["this"] = child,
                                child.$$listeners = {},
                                child.$parent = this,
                                child.$$watchers = child.$$nextSibling = child.$$childHead = child.$$childTail = null,
                                child.$$prevSibling = this.$$childTail,
                                this.$$childHead ? (this.$$childTail.$$nextSibling = child, this.$$childTail = child) : this.$$childHead = this.$$childTail = child,
                                child
                        },
                        $watch: function (watchExp, listener, objectEquality) {
                            var scope = this,
                                get = compileToFn(watchExp, "watch"),
                                array = scope.$$watchers,
                                watcher = {
                                    fn: listener,
                                    last: initWatchVal,
                                    get: get,
                                    exp: watchExp,
                                    eq: !!objectEquality
                                };
                            if (lastDirtyWatch = null, !isFunction(listener)) {
                                var listenFn = compileToFn(listener || noop, "listener");
                                watcher.fn = function (newVal, oldVal, scope) {
                                    listenFn(scope)
                                }
                            }
                            if ("string" == typeof watchExp && get.constant) {
                                var originalFn = watcher.fn;
                                watcher.fn = function (newVal, oldVal, scope) {
                                    originalFn.call(this, newVal, oldVal, scope),
                                        arrayRemove(array, watcher)
                                }
                            }
                            return array || (array = scope.$$watchers = []),
                                array.unshift(watcher),
                                function () {
                                    arrayRemove(array, watcher)
                                }
                        },
                        $watchCollection: function (obj, listener) {
                            function $watchCollectionWatch() {
                                newValue = objGetter(self);
                                var newLength, key;
                                if (isObject(newValue))
                                    if (isArrayLike(newValue)) {
                                        oldValue !== internalArray && (oldValue = internalArray, oldLength = oldValue.length = 0, changeDetected++),
                                            newLength = newValue.length,
                                            oldLength !== newLength && (changeDetected++, oldValue.length = oldLength = newLength);
                                        for (var i = 0; newLength > i; i++) oldValue[i] !== newValue[i] && (changeDetected++, oldValue[i] = newValue[i])
                                    } else {
                                        oldValue !== internalObject && (oldValue = internalObject = {},
                                                oldLength = 0, changeDetected++),
                                            newLength = 0;
                                        for (key in newValue) newValue.hasOwnProperty(key) && (newLength++, oldValue.hasOwnProperty(key) ? oldValue[key] !== newValue[key] && (changeDetected++, oldValue[key] = newValue[key]) : (oldLength++, oldValue[key] = newValue[key], changeDetected++));
                                        if (oldLength > newLength) {
                                            changeDetected++;
                                            for (key in oldValue) oldValue.hasOwnProperty(key) && !newValue.hasOwnProperty(key) && (oldLength--, delete oldValue[key])
                                        }
                                    }
                                else oldValue !== newValue && (oldValue = newValue, changeDetected++);
                                return changeDetected
                            }

                            function $watchCollectionAction() {
                                listener(newValue, oldValue, self)
                            }
                            var oldValue, newValue, self = this,
                                changeDetected = 0,
                                objGetter = $parse(obj),
                                internalArray = [],
                                internalObject = {},
                                oldLength = 0;
                            return this.$watch($watchCollectionWatch, $watchCollectionAction)
                        },
                        $digest: function () {
                            var watch, value, last, watchers, length, dirty, next, current, logIdx, logMsg, asyncTask, asyncQueue = this.$$asyncQueue,
                                postDigestQueue = this.$$postDigestQueue,
                                ttl = TTL,
                                target = this,
                                watchLog = [];
                            beginPhase("$digest"),
                                lastDirtyWatch = null;
                            do {
                                for (dirty = !1, current = target; asyncQueue.length;) {
                                    try {
                                        asyncTask = asyncQueue.shift(),
                                            asyncTask.scope.$eval(asyncTask.expression)
                                    } catch (e) {
                                        clearPhase(),
                                            $exceptionHandler(e)
                                    }
                                    lastDirtyWatch = null
                                }
                                traverseScopesLoop: do {
                                    if (watchers = current.$$watchers)
                                        for (length = watchers.length; length--;) try {
                                            if (watch = watchers[length])
                                                if ((value = watch.get(current)) === (last = watch.last) || (watch.eq ? equals(value, last) : "number" == typeof value && "number" == typeof last && isNaN(value) && isNaN(last))) {
                                                    if (watch === lastDirtyWatch) {
                                                        dirty = !1;
                                                        break traverseScopesLoop
                                                    }
                                                } else dirty = !0,
                                                    lastDirtyWatch = watch,
                                                    watch.last = watch.eq ? copy(value) : value,
                                                    watch.fn(value, last === initWatchVal ? value : last, current),
                                                    5 > ttl && (logIdx = 4 - ttl, watchLog[logIdx] || (watchLog[logIdx] = []), logMsg = isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp, logMsg += "; newVal: " + toJson(value) + "; oldVal: " + toJson(last), watchLog[logIdx].push(logMsg))
                                        } catch (e) {
                                            clearPhase(),
                                                $exceptionHandler(e)
                                        }
                                    if (!(next = current.$$childHead || current !== target && current.$$nextSibling))
                                        for (; current !== target && !(next = current.$$nextSibling);) current = current.$parent
                                } while (current = next);
                                if (dirty && !ttl--) throw clearPhase(), $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}", TTL, toJson(watchLog))
                            } while (dirty || asyncQueue.length);
                            for (clearPhase(); postDigestQueue.length;) try {
                                postDigestQueue.shift()()
                            } catch (e) {
                                $exceptionHandler(e)
                            }
                        },
                        $destroy: function () {
                            if (!this.$$destroyed) {
                                var parent = this.$parent;
                                this.$broadcast("$destroy"),
                                    this.$$destroyed = !0,
                                    this !== $rootScope && (parent.$$childHead == this && (parent.$$childHead = this.$$nextSibling), parent.$$childTail == this && (parent.$$childTail = this.$$prevSibling), this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling), this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling), this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null)
                            }
                        },
                        $eval: function (expr, locals) {
                            return $parse(expr)(this, locals)
                        },
                        $evalAsync: function (expr) {
                            $rootScope.$$phase || $rootScope.$$asyncQueue.length || $browser.defer(function () {
                                    $rootScope.$$asyncQueue.length && $rootScope.$digest()
                                }),
                                this.$$asyncQueue.push({
                                    scope: this,
                                    expression: expr
                                })
                        },
                        $$postDigest: function (fn) {
                            this.$$postDigestQueue.push(fn)
                        },
                        $apply: function (expr) {
                            try {
                                return beginPhase("$apply"),
                                    this.$eval(expr)
                            } catch (e) {
                                $exceptionHandler(e)
                            } finally {
                                clearPhase();
                                try {
                                    $rootScope.$digest()
                                } catch (e) {
                                    throw $exceptionHandler(e),
                                        e
                                }
                            }
                        },
                        $on: function (name, listener) {
                            var namedListeners = this.$$listeners[name];
                            return namedListeners || (this.$$listeners[name] = namedListeners = []),
                                namedListeners.push(listener),
                                function () {
                                    namedListeners[indexOf(namedListeners, listener)] = null
                                }
                        },
                        $emit: function (name) {
                            var namedListeners, i, length, empty = [],
                                scope = this,
                                stopPropagation = !1,
                                event = {
                                    name: name,
                                    targetScope: scope,
                                    stopPropagation: function () {
                                        stopPropagation = !0
                                    },
                                    preventDefault: function () {
                                        event.defaultPrevented = !0
                                    },
                                    defaultPrevented: !1
                                },
                                listenerArgs = concat([event], arguments, 1);
                            do {
                                for (namedListeners = scope.$$listeners[name] || empty, event.currentScope = scope, i = 0, length = namedListeners.length; length > i; i++)
                                    if (namedListeners[i]) try {
                                        namedListeners[i].apply(null, listenerArgs)
                                    } catch (e) {
                                        $exceptionHandler(e)
                                    } else namedListeners.splice(i, 1), i--, length--;
                                if (stopPropagation) return event;
                                scope = scope.$parent
                            } while (scope);
                            return event
                        },
                        $broadcast: function (name) {
                            var listeners, i, length, target = this,
                                current = target,
                                next = target,
                                event = {
                                    name: name,
                                    targetScope: target,
                                    preventDefault: function () {
                                        event.defaultPrevented = !0
                                    },
                                    defaultPrevented: !1
                                },
                                listenerArgs = concat([event], arguments, 1);
                            do {
                                for (current = next, event.currentScope = current, listeners = current.$$listeners[name] || [], i = 0, length = listeners.length; length > i; i++)
                                    if (listeners[i]) try {
                                        listeners[i].apply(null, listenerArgs)
                                    } catch (e) {
                                        $exceptionHandler(e)
                                    } else listeners.splice(i, 1), i--, length--;
                                if (!(next = current.$$childHead || current !== target && current.$$nextSibling))
                                    for (; current !== target && !(next = current.$$nextSibling);) current = current.$parent
                            } while (current = next);
                            return event
                        }
                    };
                    var $rootScope = new Scope;
                    return $rootScope
                }
            ]
    }

    function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
            imgSrcSanitizationWhitelist = /^\s*(https?|ftp|file):|data:image\//;
        this.aHrefSanitizationWhitelist = function (regexp) {
                return isDefined(regexp) ? (aHrefSanitizationWhitelist = regexp, this) : aHrefSanitizationWhitelist
            },
            this.imgSrcSanitizationWhitelist = function (regexp) {
                return isDefined(regexp) ? (imgSrcSanitizationWhitelist = regexp, this) : imgSrcSanitizationWhitelist
            },
            this.$get = function () {
                return function (uri, isImage) {
                    var normalizedVal, regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                    return msie && !(msie >= 8) || (normalizedVal = urlResolve(uri).href, "" === normalizedVal || normalizedVal.match(regex)) ? uri : "unsafe:" + normalizedVal
                }
            }
    }

    function escapeForRegexp(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(//g, "\\x08")
    }

    function adjustMatcher(matcher) {
        if ("self" === matcher) return matcher;
        if (isString(matcher)) {
            if (matcher.indexOf("***") > -1) throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
            return matcher = escapeForRegexp(matcher).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*"),
                new RegExp("^" + matcher + "$")
        }
        if (isRegExp(matcher)) return new RegExp("^" + matcher.source + "$");
        throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects')
    }

    function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        return isDefined(matchers) && forEach(matchers,
                function (matcher) {
                    adjustedMatchers.push(adjustMatcher(matcher))
                }),
            adjustedMatchers
    }

    function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = ["self"],
            resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function (value) {
                return arguments.length && (resourceUrlWhitelist = adjustMatchers(value)),
                    resourceUrlWhitelist
            },
            this.resourceUrlBlacklist = function (value) {
                return arguments.length && (resourceUrlBlacklist = adjustMatchers(value)),
                    resourceUrlBlacklist
            },
            this.$get = ["$injector",
                function ($injector) {
                    function matchUrl(matcher, parsedUrl) {
                        return "self" === matcher ? urlIsSameOrigin(parsedUrl) : !!matcher.exec(parsedUrl.href)
                    }

                    function isResourceUrlAllowedByPolicy(url) {
                        var i, n, parsedUrl = urlResolve(url.toString()),
                            allowed = !1;
                        for (i = 0, n = resourceUrlWhitelist.length; n > i; i++)
                            if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                                allowed = !0;
                                break
                            }
                        if (allowed)
                            for (i = 0, n = resourceUrlBlacklist.length; n > i; i++)
                                if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                                    allowed = !1;
                                    break
                                }
                        return allowed
                    }

                    function generateHolderType(Base) {
                        var holderType = function (trustedValue) {
                            this.$$unwrapTrustedValue = function () {
                                return trustedValue
                            }
                        };
                        return Base && (holderType.prototype = new Base),
                            holderType.prototype.valueOf = function () {
                                return this.$$unwrapTrustedValue()
                            },
                            holderType.prototype.toString = function () {
                                return this.$$unwrapTrustedValue().toString()
                            },
                            holderType
                    }

                    function trustAs(type, trustedValue) {
                        var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                        if (!Constructor) throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                        if (null === trustedValue || trustedValue === undefined || "" === trustedValue) return trustedValue;
                        if ("string" != typeof trustedValue) throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                        return new Constructor(trustedValue)
                    }

                    function valueOf(maybeTrusted) {
                        return maybeTrusted instanceof trustedValueHolderBase ? maybeTrusted.$$unwrapTrustedValue() : maybeTrusted
                    }

                    function getTrusted(type, maybeTrusted) {
                        if (null === maybeTrusted || maybeTrusted === undefined || "" === maybeTrusted) return maybeTrusted;
                        var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                        if (constructor && maybeTrusted instanceof constructor) return maybeTrusted.$$unwrapTrustedValue();
                        if (type === SCE_CONTEXTS.RESOURCE_URL) {
                            if (isResourceUrlAllowedByPolicy(maybeTrusted)) return maybeTrusted;
                            throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString())
                        }
                        if (type === SCE_CONTEXTS.HTML) return htmlSanitizer(maybeTrusted);
                        throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.")
                    }
                    var htmlSanitizer = function () {
                        throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.")
                    };
                    $injector.has("$sanitize") && (htmlSanitizer = $injector.get("$sanitize"));
                    var trustedValueHolderBase = generateHolderType(),
                        byType = {};
                    return byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase),
                        byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase),
                        byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase),
                        byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase),
                        byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]), {
                            trustAs: trustAs,
                            getTrusted: getTrusted,
                            valueOf: valueOf
                        }
                }
            ]
    }

    function $SceProvider() {
        var enabled = !0;
        this.enabled = function (value) {
                return arguments.length && (enabled = !!value),
                    enabled
            },
            this.$get = ["$parse", "$sniffer", "$sceDelegate",
                function ($parse, $sniffer, $sceDelegate) {
                    if (enabled && $sniffer.msie && $sniffer.msieDocumentMode < 8) throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 9 in quirks mode.  You can fix this by adding the text <!doctype html> to the top of your HTML document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
                    var sce = copy(SCE_CONTEXTS);
                    sce.isEnabled = function () {
                            return enabled
                        },
                        sce.trustAs = $sceDelegate.trustAs,
                        sce.getTrusted = $sceDelegate.getTrusted,
                        sce.valueOf = $sceDelegate.valueOf,
                        enabled || (sce.trustAs = sce.getTrusted = function (type, value) {
                                return value
                            },
                            sce.valueOf = identity),
                        sce.parseAs = function (type, expr) {
                            var parsed = $parse(expr);
                            return parsed.literal && parsed.constant ? parsed : function (self, locals) {
                                return sce.getTrusted(type, parsed(self, locals))
                            }
                        };
                    var parse = sce.parseAs,
                        getTrusted = sce.getTrusted,
                        trustAs = sce.trustAs;
                    return forEach(SCE_CONTEXTS,
                            function (enumValue, name) {
                                var lName = lowercase(name);
                                sce[camelCase("parse_as_" + lName)] = function (expr) {
                                        return parse(enumValue, expr)
                                    },
                                    sce[camelCase("get_trusted_" + lName)] = function (value) {
                                        return getTrusted(enumValue, value)
                                    },
                                    sce[camelCase("trust_as_" + lName)] = function (value) {
                                        return trustAs(enumValue, value)
                                    }
                            }),
                        sce
                }
            ]
    }

    function $SnifferProvider() {
        this.$get = ["$window", "$document",
            function ($window, $document) {
                var vendorPrefix, match, eventSupport = {},
                    android = int((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
                    boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
                    document = $document[0] || {},
                    documentMode = document.documentMode,
                    vendorRegex = /^(Moz|webkit|O|ms)(?=[A-Z])/,
                    bodyStyle = document.body && document.body.style,
                    transitions = !1,
                    animations = !1;
                if (bodyStyle) {
                    for (var prop in bodyStyle)
                        if (match = vendorRegex.exec(prop)) {
                            vendorPrefix = match[0],
                                vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                            break
                        }
                    vendorPrefix || (vendorPrefix = "WebkitOpacity" in bodyStyle && "webkit"),
                        transitions = !!("transition" in bodyStyle || vendorPrefix + "Transition" in bodyStyle),
                        animations = !!("animation" in bodyStyle || vendorPrefix + "Animation" in bodyStyle), !android || transitions && animations || (transitions = isString(document.body.style.webkitTransition), animations = isString(document.body.style.webkitAnimation))
                }
                return {
                    history: !(!$window.history || !$window.history.pushState || 4 > android || boxee),
                    hashchange: "onhashchange" in $window && (!documentMode || documentMode > 7),
                    hasEvent: function (event) {
                        if ("input" == event && 9 == msie) return !1;
                        if (isUndefined(eventSupport[event])) {
                            var divElm = document.createElement("div");
                            eventSupport[event] = "on" + event in divElm
                        }
                        return eventSupport[event]
                    },
                    csp: csp(),
                    vendorPrefix: vendorPrefix,
                    transitions: transitions,
                    animations: animations,
                    msie: msie,
                    msieDocumentMode: documentMode
                }
            }
        ]
    }

    function $TimeoutProvider() {
        this.$get = ["$rootScope", "$browser", "$q", "$exceptionHandler",
            function ($rootScope, $browser, $q, $exceptionHandler) {
                function timeout(fn, delay, invokeApply) {
                    var timeoutId, deferred = $q.defer(),
                        promise = deferred.promise,
                        skipApply = isDefined(invokeApply) && !invokeApply;
                    return timeoutId = $browser.defer(function () {
                                try {
                                    deferred.resolve(fn())
                                } catch (e) {
                                    deferred.reject(e),
                                        $exceptionHandler(e)
                                } finally {
                                    delete deferreds[promise.$$timeoutId]
                                }
                                skipApply || $rootScope.$apply()
                            },
                            delay),
                        promise.$$timeoutId = timeoutId,
                        deferreds[timeoutId] = deferred,
                        promise
                }
                var deferreds = {};
                return timeout.cancel = function (promise) {
                        return promise && promise.$$timeoutId in deferreds ? (deferreds[promise.$$timeoutId].reject("canceled"), delete deferreds[promise.$$timeoutId], $browser.defer.cancel(promise.$$timeoutId)) : !1
                    },
                    timeout
            }
        ]
    }

    function urlResolve(url) {
        var href = url;
        return msie && (urlParsingNode.setAttribute("href", href), href = urlParsingNode.href),
            urlParsingNode.setAttribute("href", href), {
                href: urlParsingNode.href,
                protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
                host: urlParsingNode.host,
                search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
                hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
                hostname: urlParsingNode.hostname,
                port: urlParsingNode.port,
                pathname: "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
            }
    }

    function urlIsSameOrigin(requestUrl) {
        var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
        return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host
    }

    function $WindowProvider() {
        this.$get = valueFn(window)
    }

    function $FilterProvider($provide) {
        function register(name, factory) {
            if (isObject(name)) {
                var filters = {};
                return forEach(name,
                        function (filter, key) {
                            filters[key] = register(key, filter)
                        }),
                    filters
            }
            return $provide.factory(name + suffix, factory)
        }
        var suffix = "Filter";
        this.register = register,
            this.$get = ["$injector",
                function ($injector) {
                    return function (name) {
                        return $injector.get(name + suffix)
                    }
                }
            ],
            register("currency", currencyFilter),
            register("date", dateFilter),
            register("filter", filterFilter),
            register("json", jsonFilter),
            register("limitTo", limitToFilter),
            register("lowercase", lowercaseFilter),
            register("number", numberFilter),
            register("orderBy", orderByFilter),
            register("uppercase", uppercaseFilter)
    }

    function filterFilter() {
        return function (array, expression, comparator) {
            if (!isArray(array)) return array;
            var comparatorType = typeof comparator,
                predicates = [];
            predicates.check = function (value) {
                    for (var j = 0; j < predicates.length; j++)
                        if (!predicates[j](value)) return !1;
                    return !0
                },
                "function" !== comparatorType && (comparator = "boolean" === comparatorType && comparator ?
                    function (obj, text) {
                        return angular.equals(obj, text)
                    } : function (obj, text) {
                        return text = ("" + text).toLowerCase(),
                            ("" + obj).toLowerCase().indexOf(text) > -1
                    });
            var search = function (obj, text) {
                if ("string" == typeof text && "!" === text.charAt(0)) return !search(obj, text.substr(1));
                switch (typeof obj) {
                    case "boolean":
                    case "number":
                    case "string":
                        return comparator(obj, text);
                    case "object":
                        switch (typeof text) {
                            case "object":
                                return comparator(obj, text);
                            default:
                                for (var objKey in obj)
                                    if ("$" !== objKey.charAt(0) && search(obj[objKey], text)) return !0
                        }
                        return !1;
                    case "array":
                        for (var i = 0; i < obj.length; i++)
                            if (search(obj[i], text)) return !0;
                        return !1;
                    default:
                        return !1
                }
            };
            switch (typeof expression) {
                case "boolean":
                case "number":
                case "string":
                    expression = {
                        $: expression
                    };
                case "object":
                    for (var key in expression) "$" == key ? !
                        function () {
                            if (expression[key]) {
                                var path = key;
                                predicates.push(function (value) {
                                    return search(value, expression[path])
                                })
                            }
                        }() : !
                        function () {
                            if ("undefined" != typeof expression[key]) {
                                var path = key;
                                predicates.push(function (value) {
                                    return search(getter(value, path), expression[path])
                                })
                            }
                        }();
                    break;
                case "function":
                    predicates.push(expression);
                    break;
                default:
                    return array
            }
            for (var filtered = [], j = 0; j < array.length; j++) {
                var value = array[j];
                predicates.check(value) && filtered.push(value)
            }
            return filtered
        }
    }

    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function (amount, currencySymbol) {
            return isUndefined(currencySymbol) && (currencySymbol = formats.CURRENCY_SYM),
                formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).replace(/¤/g, currencySymbol)
        }
    }

    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function (number, fractionSize) {
            return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize)
        }
    }

    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (isNaN(number) || !isFinite(number)) return "";
        var isNegative = 0 > number;
        number = Math.abs(number);
        var numStr = number + "",
            formatedText = "",
            parts = [],
            hasExponent = !1;
        if (-1 !== numStr.indexOf("e")) {
            var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
            match && "-" == match[2] && match[3] > fractionSize + 1 ? numStr = "0" : (formatedText = numStr, hasExponent = !0)
        }
        if (hasExponent) fractionSize > 0 && number > -1 && 1 > number && (formatedText = number.toFixed(fractionSize));
        else {
            var fractionLen = (numStr.split(DECIMAL_SEP)[1] || "").length;
            isUndefined(fractionSize) && (fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac));
            var pow = Math.pow(10, fractionSize);
            number = Math.round(number * pow) / pow;
            var fraction = ("" + number).split(DECIMAL_SEP),
                whole = fraction[0];
            fraction = fraction[1] || "";
            var i, pos = 0,
                lgroup = pattern.lgSize,
                group = pattern.gSize;
            if (whole.length >= lgroup + group)
                for (pos = whole.length - lgroup, i = 0; pos > i; i++)(pos - i) % group === 0 && 0 !== i && (formatedText += groupSep),
                    formatedText += whole.charAt(i);
            for (i = pos; i < whole.length; i++)(whole.length - i) % lgroup === 0 && 0 !== i && (formatedText += groupSep),
                formatedText += whole.charAt(i);
            for (; fraction.length < fractionSize;) fraction += "0";
            fractionSize && "0" !== fractionSize && (formatedText += decimalSep + fraction.substr(0, fractionSize))
        }
        return parts.push(isNegative ? pattern.negPre : pattern.posPre),
            parts.push(formatedText),
            parts.push(isNegative ? pattern.negSuf : pattern.posSuf),
            parts.join("")
    }

    function padNumber(num, digits, trim) {
        var neg = "";
        for (0 > num && (neg = "-", num = -num), num = "" + num; num.length < digits;) num = "0" + num;
        return trim && (num = num.substr(num.length - digits)),
            neg + num
    }

    function dateGetter(name, size, offset, trim) {
        return offset = offset || 0,
            function (date) {
                var value = date["get" + name]();
                return (offset > 0 || value > -offset) && (value += offset),
                    0 === value && -12 == offset && (value = 12),
                    padNumber(value, size, trim)
            }
    }

    function dateStrGetter(name, shortForm) {
        return function (date, formats) {
            var value = date["get" + name](),
                get = uppercase(shortForm ? "SHORT" + name : name);
            return formats[get][value]
        }
    }

    function timeZoneGetter(date) {
        var zone = -1 * date.getTimezoneOffset(),
            paddedZone = zone >= 0 ? "+" : "";
        return paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2)
    }

    function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1]
    }

    function dateFilter($locale) {
        function jsonStringToDate(string) {
            var match;
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0),
                    tzHour = 0,
                    tzMin = 0,
                    dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                    timeSetter = match[8] ? date.setUTCHours : date.setHours;
                match[9] && (tzHour = int(match[9] + match[10]), tzMin = int(match[9] + match[11])),
                    dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
                var h = int(match[4] || 0) - tzHour,
                    m = int(match[5] || 0) - tzMin,
                    s = int(match[6] || 0),
                    ms = Math.round(1e3 * parseFloat("0." + (match[7] || 0)));
                return timeSetter.call(date, h, m, s, ms),
                    date
            }
            return string
        }
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        return function (date, format) {
            var fn, match, text = "",
                parts = [];
            if (format = format || "mediumDate", format = $locale.DATETIME_FORMATS[format] || format, isString(date) && (date = NUMBER_STRING.test(date) ? int(date) : jsonStringToDate(date)), isNumber(date) && (date = new Date(date)), !isDate(date)) return date;
            for (; format;) match = DATE_FORMATS_SPLIT.exec(format),
                match ? (parts = concat(parts, match, 1), format = parts.pop()) : (parts.push(format), format = null);
            return forEach(parts,
                    function (value) {
                        fn = DATE_FORMATS[value],
                            text += fn ? fn(date, $locale.DATETIME_FORMATS) : value.replace(/(^'|'$)/g, "").replace(/''/g, "'")
                    }),
                text
        }
    }

    function jsonFilter() {
        return function (object) {
            return toJson(object, !0)
        }
    }

    function limitToFilter() {
        return function (input, limit) {
            if (!isArray(input) && !isString(input)) return input;
            if (limit = int(limit), isString(input)) return limit ? limit >= 0 ? input.slice(0, limit) : input.slice(limit, input.length) : "";
            var i, n, out = [];
            for (limit > input.length ? limit = input.length : limit < -input.length && (limit = -input.length), limit > 0 ? (i = 0, n = limit) : (i = input.length + limit, n = input.length); n > i; i++) out.push(input[i]);
            return out
        }
    }

    function orderByFilter($parse) {
        return function (array, sortPredicate, reverseOrder) {
            function comparator(o1, o2) {
                for (var i = 0; i < sortPredicate.length; i++) {
                    var comp = sortPredicate[i](o1, o2);
                    if (0 !== comp) return comp
                }
                return 0
            }

            function reverseComparator(comp, descending) {
                return toBoolean(descending) ?
                    function (a, b) {
                        return comp(b, a)
                    } : comp
            }

            function compare(v1, v2) {
                var t1 = typeof v1,
                    t2 = typeof v2;
                return t1 == t2 ? ("string" == t1 && (v1 = v1.toLowerCase(), v2 = v2.toLowerCase()), v1 === v2 ? 0 : v2 > v1 ? -1 : 1) : t2 > t1 ? -1 : 1
            }
            if (!isArray(array)) return array;
            if (!sortPredicate) return array;
            sortPredicate = isArray(sortPredicate) ? sortPredicate : [sortPredicate],
                sortPredicate = map(sortPredicate,
                    function (predicate) {
                        var descending = !1,
                            get = predicate || identity;
                        return isString(predicate) && (("+" == predicate.charAt(0) || "-" == predicate.charAt(0)) && (descending = "-" == predicate.charAt(0), predicate = predicate.substring(1)), get = $parse(predicate)),
                            reverseComparator(function (a, b) {
                                    return compare(get(a), get(b))
                                },
                                descending)
                    });
            for (var arrayCopy = [], i = 0; i < array.length; i++) arrayCopy.push(array[i]);
            return arrayCopy.sort(reverseComparator(comparator, reverseOrder))
        }
    }

    function ngDirective(directive) {
        return isFunction(directive) && (directive = {
                link: directive
            }),
            directive.restrict = directive.restrict || "AC",
            valueFn(directive)
    }

    function FormController(element, attrs) {
        function toggleValidCss(isValid, validationErrorKey) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "",
                element.removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey)
        }
        var form = this,
            parentForm = element.parent().controller("form") || nullFormCtrl,
            invalidCount = 0,
            errors = form.$error = {},
            controls = [];
        form.$name = attrs.name || attrs.ngForm,
            form.$dirty = !1,
            form.$pristine = !0,
            form.$valid = !0,
            form.$invalid = !1,
            parentForm.$addControl(form),
            element.addClass(PRISTINE_CLASS),
            toggleValidCss(!0),
            form.$addControl = function (control) {
                assertNotHasOwnProperty(control.$name, "input"),
                    controls.push(control),
                    control.$name && (form[control.$name] = control)
            },
            form.$removeControl = function (control) {
                control.$name && form[control.$name] === control && delete form[control.$name],
                    forEach(errors,
                        function (queue, validationToken) {
                            form.$setValidity(validationToken, !0, control)
                        }),
                    arrayRemove(controls, control)
            },
            form.$setValidity = function (validationToken, isValid, control) {
                var queue = errors[validationToken];
                if (isValid) queue && (arrayRemove(queue, control), queue.length || (invalidCount--, invalidCount || (toggleValidCss(isValid), form.$valid = !0, form.$invalid = !1), errors[validationToken] = !1, toggleValidCss(!0, validationToken), parentForm.$setValidity(validationToken, !0, form)));
                else {
                    if (invalidCount || toggleValidCss(isValid), queue) {
                        if (includes(queue, control)) return
                    } else errors[validationToken] = queue = [],
                        invalidCount++,
                        toggleValidCss(!1, validationToken),
                        parentForm.$setValidity(validationToken, !1, form);
                    queue.push(control),
                        form.$valid = !1,
                        form.$invalid = !0
                }
            },
            form.$setDirty = function () {
                element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS),
                    form.$dirty = !0,
                    form.$pristine = !1,
                    parentForm.$setDirty()
            },
            form.$setPristine = function () {
                element.removeClass(DIRTY_CLASS).addClass(PRISTINE_CLASS),
                    form.$dirty = !1,
                    form.$pristine = !0,
                    forEach(controls,
                        function (control) {
                            control.$setPristine()
                        })
            }
    }

    function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var composing = !1;
        element.on("compositionstart",
                function () {
                    composing = !0
                }),
            element.on("compositionend",
                function () {
                    composing = !1
                });
        var listener = function () {
            if (!composing) {
                var value = element.val();
                toBoolean(attr.ngTrim || "T") && (value = trim(value)),
                    ctrl.$viewValue !== value && scope.$apply(function () {
                        ctrl.$setViewValue(value)
                    })
            }
        };
        if ($sniffer.hasEvent("input")) element.on("input", listener);
        else {
            var timeout, deferListener = function () {
                timeout || (timeout = $browser.defer(function () {
                    listener(),
                        timeout = null
                }))
            };
            element.on("keydown",
                    function (event) {
                        var key = event.keyCode;
                        91 === key || key > 15 && 19 > key || key >= 37 && 40 >= key || deferListener()
                    }),
                $sniffer.hasEvent("paste") && element.on("paste cut", deferListener)
        }
        element.on("change", listener),
            ctrl.$render = function () {
                element.val(ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue)
            };
        var patternValidator, match, pattern = attr.ngPattern,
            validate = function (regexp, value) {
                return ctrl.$isEmpty(value) || regexp.test(value) ? (ctrl.$setValidity("pattern", !0), value) : (ctrl.$setValidity("pattern", !1), undefined)
            };
        if (pattern && (match = pattern.match(/^\/(.*)\/([gim]*)$/), match ? (pattern = new RegExp(match[1], match[2]), patternValidator = function (value) {
                    return validate(pattern, value)
                }) : patternValidator = function (value) {
                    var patternObj = scope.$eval(pattern);
                    if (!patternObj || !patternObj.test) throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", pattern, patternObj, startingTag(element));
                    return validate(patternObj, value)
                },
                ctrl.$formatters.push(patternValidator), ctrl.$parsers.push(patternValidator)), attr.ngMinlength) {
            var minlength = int(attr.ngMinlength),
                minLengthValidator = function (value) {
                    return !ctrl.$isEmpty(value) && value.length < minlength ? (ctrl.$setValidity("minlength", !1), undefined) : (ctrl.$setValidity("minlength", !0), value)
                };
            ctrl.$parsers.push(minLengthValidator),
                ctrl.$formatters.push(minLengthValidator)
        }
        if (attr.ngMaxlength) {
            var maxlength = int(attr.ngMaxlength),
                maxLengthValidator = function (value) {
                    return !ctrl.$isEmpty(value) && value.length > maxlength ? (ctrl.$setValidity("maxlength", !1), undefined) : (ctrl.$setValidity("maxlength", !0), value)
                };
            ctrl.$parsers.push(maxLengthValidator),
                ctrl.$formatters.push(maxLengthValidator)
        }
    }

    function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        if (textInputType(scope, element, attr, ctrl, $sniffer, $browser), ctrl.$parsers.push(function (value) {
                var empty = ctrl.$isEmpty(value);
                return empty || NUMBER_REGEXP.test(value) ? (ctrl.$setValidity("number", !0), "" === value ? null : empty ? value : parseFloat(value)) : (ctrl.$setValidity("number", !1), undefined)
            }), ctrl.$formatters.push(function (value) {
                return ctrl.$isEmpty(value) ? "" : "" + value
            }), attr.min) {
            var minValidator = function (value) {
                var min = parseFloat(attr.min);
                return !ctrl.$isEmpty(value) && min > value ? (ctrl.$setValidity("min", !1), undefined) : (ctrl.$setValidity("min", !0), value)
            };
            ctrl.$parsers.push(minValidator),
                ctrl.$formatters.push(minValidator)
        }
        if (attr.max) {
            var maxValidator = function (value) {
                var max = parseFloat(attr.max);
                return !ctrl.$isEmpty(value) && value > max ? (ctrl.$setValidity("max", !1), undefined) : (ctrl.$setValidity("max", !0), value)
            };
            ctrl.$parsers.push(maxValidator),
                ctrl.$formatters.push(maxValidator)
        }
        ctrl.$formatters.push(function (value) {
            return ctrl.$isEmpty(value) || isNumber(value) ? (ctrl.$setValidity("number", !0), value) : (ctrl.$setValidity("number", !1), undefined)
        })
    }

    function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        textInputType(scope, element, attr, ctrl, $sniffer, $browser);
        var urlValidator = function (value) {
            return ctrl.$isEmpty(value) || URL_REGEXP.test(value) ? (ctrl.$setValidity("url", !0), value) : (ctrl.$setValidity("url", !1), undefined)
        };
        ctrl.$formatters.push(urlValidator),
            ctrl.$parsers.push(urlValidator)
    }

    function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        textInputType(scope, element, attr, ctrl, $sniffer, $browser);
        var emailValidator = function (value) {
            return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value) ? (ctrl.$setValidity("email", !0), value) : (ctrl.$setValidity("email", !1), undefined)
        };
        ctrl.$formatters.push(emailValidator),
            ctrl.$parsers.push(emailValidator)
    }

    function radioInputType(scope, element, attr, ctrl) {
        isUndefined(attr.name) && element.attr("name", nextUid()),
            element.on("click",
                function () {
                    element[0].checked && scope.$apply(function () {
                        ctrl.$setViewValue(attr.value)
                    })
                }),
            ctrl.$render = function () {
                var value = attr.value;
                element[0].checked = value == ctrl.$viewValue
            },
            attr.$observe("value", ctrl.$render)
    }

    function checkboxInputType(scope, element, attr, ctrl) {
        var trueValue = attr.ngTrueValue,
            falseValue = attr.ngFalseValue;
        isString(trueValue) || (trueValue = !0),
            isString(falseValue) || (falseValue = !1),
            element.on("click",
                function () {
                    scope.$apply(function () {
                        ctrl.$setViewValue(element[0].checked)
                    })
                }),
            ctrl.$render = function () {
                element[0].checked = ctrl.$viewValue
            },
            ctrl.$isEmpty = function (value) {
                return value !== trueValue
            },
            ctrl.$formatters.push(function (value) {
                return value === trueValue
            }),
            ctrl.$parsers.push(function (value) {
                return value ? trueValue : falseValue
            })
    }

    function classDirective(name, selector) {
        return name = "ngClass" + name,
            function () {
                return {
                    restrict: "AC",
                    link: function (scope, element, attr) {
                        function ngClassWatchAction(newVal) {
                            if (selector === !0 || scope.$index % 2 === selector) {
                                var newClasses = flattenClasses(newVal || "");
                                oldVal ? equals(newVal, oldVal) || attr.$updateClass(newClasses, flattenClasses(oldVal)) : attr.$addClass(newClasses)
                            }
                            oldVal = copy(newVal)
                        }

                        function flattenClasses(classVal) {
                            if (isArray(classVal)) return classVal.join(" ");
                            if (isObject(classVal)) {
                                var classes = [];
                                return forEach(classVal,
                                        function (v, k) {
                                            v && classes.push(k)
                                        }),
                                    classes.join(" ")
                            }
                            return classVal
                        }
                        var oldVal;
                        scope.$watch(attr[name], ngClassWatchAction, !0),
                            attr.$observe("class",
                                function () {
                                    ngClassWatchAction(scope.$eval(attr[name]))
                                }),
                            "ngClass" !== name && scope.$watch("$index",
                                function ($index, old$index) {
                                    var mod = 1 & $index;
                                    if (mod !== old$index & 1) {
                                        var classes = flattenClasses(scope.$eval(attr[name]));
                                        mod === selector ? attr.$addClass(classes) : attr.$removeClass(classes)
                                    }
                                })
                    }
                }
            }
    }
    var lowercase = function (string) {
            return isString(string) ? string.toLowerCase() : string
        },
        uppercase = function (string) {
            return isString(string) ? string.toUpperCase() : string
        },
        manualLowercase = function (s) {
            return isString(s) ? s.replace(/[A-Z]/g,
                function (ch) {
                    return String.fromCharCode(32 | ch.charCodeAt(0))
                }) : s
        },
        manualUppercase = function (s) {
            return isString(s) ? s.replace(/[a-z]/g,
                function (ch) {
                    return String.fromCharCode(-33 & ch.charCodeAt(0))
                }) : s
        };
    "i" !== "I".toLowerCase() && (lowercase = manualLowercase, uppercase = manualUppercase);
    var msie, jqLite, jQuery, angularModule, nodeName_, slice = [].slice,
        push = [].push,
        toString = Object.prototype.toString,
        ngMinErr = minErr("ng"),
        angular = (window.angular, window.angular || (window.angular = {})),
        uid = ["0", "0", "0"];
    msie = int((/msie (\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]),
        isNaN(msie) && (msie = int((/trident\/.*; rv:(\d+)/.exec(lowercase(navigator.userAgent)) || [])[1])),
        noop.$inject = [],
        identity.$inject = [];
    var trim = function () {
        return String.prototype.trim ?
            function (value) {
                return isString(value) ? value.trim() : value
            } : function (value) {
                return isString(value) ? value.replace(/^\s\s*/, "").replace(/\s\s*$/, "") : value
            }
    }();
    nodeName_ = 9 > msie ?
        function (element) {
            return element = element.nodeName ? element : element[0],
                element.scopeName && "HTML" != element.scopeName ? uppercase(element.scopeName + ":" + element.nodeName) : element.nodeName
        } : function (element) {
            return element.nodeName ? element.nodeName : element[0].nodeName
        };
    var SNAKE_CASE_REGEXP = /[A-Z]/g,
        version = {
            full: "1.2.4",
            major: 1,
            minor: 2,
            dot: 4,
            codeName: "wormhole-baster"
        },
        jqCache = JQLite.cache = {},
        jqName = JQLite.expando = "ng-" + (new Date).getTime(),
        jqId = 1,
        addEventListenerFn = window.document.addEventListener ?
        function (element, type, fn) {
            element.addEventListener(type, fn, !1)
        } : function (element, type, fn) {
            element.attachEvent("on" + type, fn)
        },
        removeEventListenerFn = window.document.removeEventListener ?
        function (element, type, fn) {
            element.removeEventListener(type, fn, !1)
        } : function (element, type, fn) {
            element.detachEvent("on" + type, fn)
        },
        SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g,
        MOZ_HACK_REGEXP = /^moz([A-Z])/,
        jqLiteMinErr = minErr("jqLite"),
        JQLitePrototype = JQLite.prototype = {
            ready: function (fn) {
                function trigger() {
                    fired || (fired = !0, fn())
                }
                var fired = !1;
                "complete" === document.readyState ? setTimeout(trigger) : (this.on("DOMContentLoaded", trigger), JQLite(window).on("load", trigger))
            },
            toString: function () {
                var value = [];
                return forEach(this,
                        function (e) {
                            value.push("" + e)
                        }),
                    "[" + value.join(", ") + "]"
            },
            eq: function (index) {
                return jqLite(index >= 0 ? this[index] : this[this.length + index])
            },
            length: 0,
            push: push,
            sort: [].sort,
            splice: [].splice
        },
        BOOLEAN_ATTR = {};
    forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","),
        function (value) {
            BOOLEAN_ATTR[lowercase(value)] = value
        });
    var BOOLEAN_ELEMENTS = {};
    forEach("input,select,option,textarea,button,form,details".split(","),
            function (value) {
                BOOLEAN_ELEMENTS[uppercase(value)] = !0
            }),
        forEach({
                data: jqLiteData,
                inheritedData: jqLiteInheritedData,
                scope: function (element) {
                    return jqLite(element).data("$scope") || jqLiteInheritedData(element.parentNode || element, ["$isolateScope", "$scope"])
                },
                isolateScope: function (element) {
                    return jqLite(element).data("$isolateScope") || jqLite(element).data("$isolateScopeNoTemplate")
                },
                controller: jqLiteController,
                injector: function (element) {
                    return jqLiteInheritedData(element, "$injector")
                },
                removeAttr: function (element, name) {
                    element.removeAttribute(name)
                },
                hasClass: jqLiteHasClass,
                css: function (element, name, value) {
                    if (name = camelCase(name), !isDefined(value)) {
                        var val;
                        return 8 >= msie && (val = element.currentStyle && element.currentStyle[name], "" === val && (val = "auto")),
                            val = val || element.style[name],
                            8 >= msie && (val = "" === val ? undefined : val),
                            val
                    }
                    element.style[name] = value
                },
                attr: function (element, name, value) {
                    var lowercasedName = lowercase(name);
                    if (BOOLEAN_ATTR[lowercasedName]) {
                        if (!isDefined(value)) return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
                        value ? (element[name] = !0, element.setAttribute(name, lowercasedName)) : (element[name] = !1, element.removeAttribute(lowercasedName))
                    } else if (isDefined(value)) element.setAttribute(name, value);
                    else if (element.getAttribute) {
                        var ret = element.getAttribute(name, 2);
                        return null === ret ? undefined : ret
                    }
                },
                prop: function (element, name, value) {
                    return isDefined(value) ? void(element[name] = value) : element[name]
                },
                text: function () {
                    function getText(element, value) {
                        var textProp = NODE_TYPE_TEXT_PROPERTY[element.nodeType];
                        return isUndefined(value) ? textProp ? element[textProp] : "" : void(element[textProp] = value)
                    }
                    var NODE_TYPE_TEXT_PROPERTY = [];
                    return 9 > msie ? (NODE_TYPE_TEXT_PROPERTY[1] = "innerText", NODE_TYPE_TEXT_PROPERTY[3] = "nodeValue") : NODE_TYPE_TEXT_PROPERTY[1] = NODE_TYPE_TEXT_PROPERTY[3] = "textContent",
                        getText.$dv = "",
                        getText
                }(),
                val: function (element, value) {
                    if (isUndefined(value)) {
                        if ("SELECT" === nodeName_(element) && element.multiple) {
                            var result = [];
                            return forEach(element.options,
                                    function (option) {
                                        option.selected && result.push(option.value || option.text)
                                    }),
                                0 === result.length ? null : result
                        }
                        return element.value
                    }
                    element.value = value
                },
                html: function (element, value) {
                    if (isUndefined(value)) return element.innerHTML;
                    for (var i = 0,
                            childNodes = element.childNodes; i < childNodes.length; i++) jqLiteDealoc(childNodes[i]);
                    element.innerHTML = value
                }
            },
            function (fn, name) {
                JQLite.prototype[name] = function (arg1, arg2) {
                    var i, key;
                    if ((2 == fn.length && fn !== jqLiteHasClass && fn !== jqLiteController ? arg1 : arg2) === undefined) {
                        if (isObject(arg1)) {
                            for (i = 0; i < this.length; i++)
                                if (fn === jqLiteData) fn(this[i], arg1);
                                else
                                    for (key in arg1) fn(this[i], key, arg1[key]);
                            return this
                        }
                        for (var value = fn.$dv,
                                jj = value === undefined ? Math.min(this.length, 1) : this.length, j = 0; jj > j; j++) {
                            var nodeValue = fn(this[j], arg1, arg2);
                            value = value ? value + nodeValue : nodeValue
                        }
                        return value
                    }
                    for (i = 0; i < this.length; i++) fn(this[i], arg1, arg2);
                    return this
                }
            }),
        forEach({
                removeData: jqLiteRemoveData,
                dealoc: jqLiteDealoc,
                on: function onFn(element, type, fn, unsupported) {
                    if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
                    var events = jqLiteExpandoStore(element, "events"),
                        handle = jqLiteExpandoStore(element, "handle");
                    events || jqLiteExpandoStore(element, "events", events = {}),
                        handle || jqLiteExpandoStore(element, "handle", handle = createEventHandler(element, events)),
                        forEach(type.split(" "),
                            function (type) {
                                var eventFns = events[type];
                                if (!eventFns) {
                                    if ("mouseenter" == type || "mouseleave" == type) {
                                        var contains = document.body.contains || document.body.compareDocumentPosition ?
                                            function (a, b) {
                                                var adown = 9 === a.nodeType ? a.documentElement : a,
                                                    bup = b && b.parentNode;
                                                return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)))
                                            } : function (a, b) {
                                                if (b)
                                                    for (; b = b.parentNode;)
                                                        if (b === a) return !0;
                                                return !1
                                            };
                                        events[type] = [];
                                        var eventmap = {
                                            mouseleave: "mouseout",
                                            mouseenter: "mouseover"
                                        };
                                        onFn(element, eventmap[type],
                                            function (event) {
                                                var target = this,
                                                    related = event.relatedTarget;
                                                (!related || related !== target && !contains(target, related)) && handle(event, type)
                                            })
                                    } else addEventListenerFn(element, type, handle),
                                        events[type] = [];
                                    eventFns = events[type]
                                }
                                eventFns.push(fn)
                            })
                },
                off: jqLiteOff,
                replaceWith: function (element, replaceNode) {
                    var index, parent = element.parentNode;
                    jqLiteDealoc(element),
                        forEach(new JQLite(replaceNode),
                            function (node) {
                                index ? parent.insertBefore(node, index.nextSibling) : parent.replaceChild(node, element),
                                    index = node
                            })
                },
                children: function (element) {
                    var children = [];
                    return forEach(element.childNodes,
                            function (element) {
                                1 === element.nodeType && children.push(element)
                            }),
                        children
                },
                contents: function (element) {
                    return element.childNodes || []
                },
                append: function (element, node) {
                    forEach(new JQLite(node),
                        function (child) {
                            (1 === element.nodeType || 11 === element.nodeType) && element.appendChild(child)
                        })
                },
                prepend: function (element, node) {
                    if (1 === element.nodeType) {
                        var index = element.firstChild;
                        forEach(new JQLite(node),
                            function (child) {
                                element.insertBefore(child, index)
                            })
                    }
                },
                wrap: function (element, wrapNode) {
                    wrapNode = jqLite(wrapNode)[0];
                    var parent = element.parentNode;
                    parent && parent.replaceChild(wrapNode, element),
                        wrapNode.appendChild(element)
                },
                remove: function (element) {
                    jqLiteDealoc(element);
                    var parent = element.parentNode;
                    parent && parent.removeChild(element)
                },
                after: function (element, newElement) {
                    var index = element,
                        parent = element.parentNode;
                    forEach(new JQLite(newElement),
                        function (node) {
                            parent.insertBefore(node, index.nextSibling),
                                index = node
                        })
                },
                addClass: jqLiteAddClass,
                removeClass: jqLiteRemoveClass,
                toggleClass: function (element, selector, condition) {
                    isUndefined(condition) && (condition = !jqLiteHasClass(element, selector)),
                        (condition ? jqLiteAddClass : jqLiteRemoveClass)(element, selector)
                },
                parent: function (element) {
                    var parent = element.parentNode;
                    return parent && 11 !== parent.nodeType ? parent : null
                },
                next: function (element) {
                    if (element.nextElementSibling) return element.nextElementSibling;
                    for (var elm = element.nextSibling; null != elm && 1 !== elm.nodeType;) elm = elm.nextSibling;
                    return elm
                },
                find: function (element, selector) {
                    return element.getElementsByTagName ? element.getElementsByTagName(selector) : []
                },
                clone: jqLiteClone,
                triggerHandler: function (element, eventName, eventData) {
                    var eventFns = (jqLiteExpandoStore(element, "events") || {})[eventName];
                    eventData = eventData || [];
                    var event = [{
                        preventDefault: noop,
                        stopPropagation: noop
                    }];
                    forEach(eventFns,
                        function (fn) {
                            fn.apply(element, event.concat(eventData))
                        })
                }
            },
            function (fn, name) {
                JQLite.prototype[name] = function (arg1, arg2, arg3) {
                        for (var value, i = 0; i < this.length; i++) isUndefined(value) ? (value = fn(this[i], arg1, arg2, arg3), isDefined(value) && (value = jqLite(value))) : jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
                        return isDefined(value) ? value : this
                    },
                    JQLite.prototype.bind = JQLite.prototype.on,
                    JQLite.prototype.unbind = JQLite.prototype.off
            }),
        HashMap.prototype = {
            put: function (key, value) {
                this[hashKey(key)] = value
            },
            get: function (key) {
                return this[hashKey(key)]
            },
            remove: function (key) {
                var value = this[key = hashKey(key)];
                return delete this[key],
                    value
            }
        };
    var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m,
        FN_ARG_SPLIT = /,/,
        FN_ARG = /^\s*(_?)(\S+?)\1\s*$/,
        STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,
        $injectorMinErr = minErr("$injector"),
        $animateMinErr = minErr("$animate"),
        $AnimateProvider = ["$provide",
            function ($provide) {
                this.$$selectors = {},
                    this.register = function (name, factory) {
                        var key = name + "-animation";
                        if (name && "." != name.charAt(0)) throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
                        this.$$selectors[name.substr(1)] = key,
                            $provide.factory(key, factory)
                    },
                    this.$get = ["$timeout",
                        function ($timeout) {
                            return {
                                enter: function (element, parent, after, done) {
                                    after ? after.after(element) : (parent && parent[0] || (parent = after.parent()), parent.append(element)),
                                        done && $timeout(done, 0, !1)
                                },
                                leave: function (element, done) {
                                    element.remove(),
                                        done && $timeout(done, 0, !1)
                                },
                                move: function (element, parent, after, done) {
                                    this.enter(element, parent, after, done)
                                },
                                addClass: function (element, className, done) {
                                    className = isString(className) ? className : isArray(className) ? className.join(" ") : "",
                                        forEach(element,
                                            function (element) {
                                                jqLiteAddClass(element, className)
                                            }),
                                        done && $timeout(done, 0, !1)
                                },
                                removeClass: function (element, className, done) {
                                    className = isString(className) ? className : isArray(className) ? className.join(" ") : "",
                                        forEach(element,
                                            function (element) {
                                                jqLiteRemoveClass(element, className)
                                            }),
                                        done && $timeout(done, 0, !1)
                                },
                                enabled: noop
                            }
                        }
                    ]
            }
        ],
        $compileMinErr = minErr("$compile");
    $CompileProvider.$inject = ["$provide", "$$sanitizeUriProvider"];
    var PREFIX_REGEXP = /^(x[\:\-_]|data[\:\-_])/i,
        XHR = window.XMLHttpRequest ||
        function () {
            try {
                return new ActiveXObject("Msxml2.XMLHTTP.6.0")
            } catch (e1) {}
            try {
                return new ActiveXObject("Msxml2.XMLHTTP.3.0")
            } catch (e2) {}
            try {
                return new ActiveXObject("Msxml2.XMLHTTP")
            } catch (e3) {}
            throw minErr("$httpBackend")("noxhr", "This browser does not support XMLHttpRequest.")
        },
        $interpolateMinErr = minErr("$interpolate"),
        PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
        DEFAULT_PORTS = {
            http: 80,
            https: 443,
            ftp: 21
        },
        $locationMinErr = minErr("$location");
    LocationHashbangInHtml5Url.prototype = LocationHashbangUrl.prototype = LocationHtml5Url.prototype = {
        $$html5: !1,
        $$replace: !1,
        absUrl: locationGetter("$$absUrl"),
        url: function (url, replace) {
            if (isUndefined(url)) return this.$$url;
            var match = PATH_MATCH.exec(url);
            return match[1] && this.path(decodeURIComponent(match[1])),
                (match[2] || match[1]) && this.search(match[3] || ""),
                this.hash(match[5] || "", replace),
                this
        },
        protocol: locationGetter("$$protocol"),
        host: locationGetter("$$host"),
        port: locationGetter("$$port"),
        path: locationGetterSetter("$$path",
            function (path) {
                return "/" == path.charAt(0) ? path : "/" + path
            }),
        search: function (search, paramValue) {
            switch (arguments.length) {
                case 0:
                    return this.$$search;
                case 1:
                    if (isString(search)) this.$$search = parseKeyValue(search);
                    else {
                        if (!isObject(search)) throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                        this.$$search = search
                    }
                    break;
                default:
                    isUndefined(paramValue) || null === paramValue ? delete this.$$search[search] : this.$$search[search] = paramValue
            }
            return this.$$compose(),
                this
        },
        hash: locationGetterSetter("$$hash", identity),
        replace: function () {
            return this.$$replace = !0,
                this
        }
    };
    var promiseWarning, $parseMinErr = minErr("$parse"),
        promiseWarningCache = {},
        OPERATORS = {
            "null": function () {
                return null
            },
            "true": function () {
                return !0
            },
            "false": function () {
                return !1
            },
            undefined: noop,
            "+": function (self, locals, a, b) {
                return a = a(self, locals),
                    b = b(self, locals),
                    isDefined(a) ? isDefined(b) ? a + b : a : isDefined(b) ? b : undefined
            },
            "-": function (self, locals, a, b) {
                return a = a(self, locals),
                    b = b(self, locals),
                    (isDefined(a) ? a : 0) - (isDefined(b) ? b : 0)
            },
            "*": function (self, locals, a, b) {
                return a(self, locals) * b(self, locals)
            },
            "/": function (self, locals, a, b) {
                return a(self, locals) / b(self, locals)
            },
            "%": function (self, locals, a, b) {
                return a(self, locals) % b(self, locals)
            },
            "^": function (self, locals, a, b) {
                return a(self, locals) ^ b(self, locals)
            },
            "=": noop,
            "===": function (self, locals, a, b) {
                return a(self, locals) === b(self, locals)
            },
            "!==": function (self, locals, a, b) {
                return a(self, locals) !== b(self, locals)
            },
            "==": function (self, locals, a, b) {
                return a(self, locals) == b(self, locals)
            },
            "!=": function (self, locals, a, b) {
                return a(self, locals) != b(self, locals)
            },
            "<": function (self, locals, a, b) {
                return a(self, locals) < b(self, locals)
            },
            ">": function (self, locals, a, b) {
                return a(self, locals) > b(self, locals)
            },
            "<=": function (self, locals, a, b) {
                return a(self, locals) <= b(self, locals)
            },
            ">=": function (self, locals, a, b) {
                return a(self, locals) >= b(self, locals)
            },
            "&&": function (self, locals, a, b) {
                return a(self, locals) && b(self, locals)
            },
            "||": function (self, locals, a, b) {
                return a(self, locals) || b(self, locals)
            },
            "&": function (self, locals, a, b) {
                return a(self, locals) & b(self, locals)
            },
            "|": function (self, locals, a, b) {
                return b(self, locals)(self, locals, a(self, locals))
            },
            "!": function (self, locals, a) {
                return !a(self, locals)
            }
        },
        ESCAPE = {
            n: "\n",
            f: "\f",
            r: "\r",
            t: "	",
            v: "",
            "'": "'",
            '"': '"'
        },
        Lexer = function (options) {
            this.options = options
        };
    Lexer.prototype = {
        constructor: Lexer,
        lex: function (text) {
            this.text = text,
                this.index = 0,
                this.ch = undefined,
                this.lastCh = ":",
                this.tokens = [];
            for (var token, json = []; this.index < this.text.length;) {
                if (this.ch = this.text.charAt(this.index), this.is("\"'")) this.readString(this.ch);
                else if (this.isNumber(this.ch) || this.is(".") && this.isNumber(this.peek())) this.readNumber();
                else if (this.isIdent(this.ch)) this.readIdent(),
                    this.was("{,") && "{" === json[0] && (token = this.tokens[this.tokens.length - 1]) && (token.json = -1 === token.text.indexOf("."));
                else if (this.is("(){}[].,;:?")) this.tokens.push({
                        index: this.index,
                        text: this.ch,
                        json: this.was(":[,") && this.is("{[") || this.is("}]:,")
                    }),
                    this.is("{[") && json.unshift(this.ch),
                    this.is("}]") && json.shift(),
                    this.index++;
                else {
                    if (this.isWhitespace(this.ch)) {
                        this.index++;
                        continue
                    }
                    var ch2 = this.ch + this.peek(),
                        ch3 = ch2 + this.peek(2),
                        fn = OPERATORS[this.ch],
                        fn2 = OPERATORS[ch2],
                        fn3 = OPERATORS[ch3];
                    fn3 ? (this.tokens.push({
                        index: this.index,
                        text: ch3,
                        fn: fn3
                    }), this.index += 3) : fn2 ? (this.tokens.push({
                        index: this.index,
                        text: ch2,
                        fn: fn2
                    }), this.index += 2) : fn ? (this.tokens.push({
                        index: this.index,
                        text: this.ch,
                        fn: fn,
                        json: this.was("[,:") && this.is("+-")
                    }), this.index += 1) : this.throwError("Unexpected next character ", this.index, this.index + 1)
                }
                this.lastCh = this.ch
            }
            return this.tokens
        },
        is: function (chars) {
            return -1 !== chars.indexOf(this.ch)
        },
        was: function (chars) {
            return -1 !== chars.indexOf(this.lastCh)
        },
        peek: function (i) {
            var num = i || 1;
            return this.index + num < this.text.length ? this.text.charAt(this.index + num) : !1
        },
        isNumber: function (ch) {
            return ch >= "0" && "9" >= ch
        },
        isWhitespace: function (ch) {
            return " " === ch || "\r" === ch || "	" === ch || "\n" === ch || "" === ch || " " === ch
        },
        isIdent: function (ch) {
            return ch >= "a" && "z" >= ch || ch >= "A" && "Z" >= ch || "_" === ch || "$" === ch
        },
        isExpOperator: function (ch) {
            return "-" === ch || "+" === ch || this.isNumber(ch)
        },
        throwError: function (error, start, end) {
            end = end || this.index;
            var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
            throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text)
        },
        readNumber: function () {
            for (var number = "",
                    start = this.index; this.index < this.text.length;) {
                var ch = lowercase(this.text.charAt(this.index));
                if ("." == ch || this.isNumber(ch)) number += ch;
                else {
                    var peekCh = this.peek();
                    if ("e" == ch && this.isExpOperator(peekCh)) number += ch;
                    else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && "e" == number.charAt(number.length - 1)) number += ch;
                    else {
                        if (!this.isExpOperator(ch) || peekCh && this.isNumber(peekCh) || "e" != number.charAt(number.length - 1)) break;
                        this.throwError("Invalid exponent")
                    }
                }
                this.index++
            }
            number = 1 * number,
                this.tokens.push({
                    index: start,
                    text: number,
                    json: !0,
                    fn: function () {
                        return number
                    }
                })
        },
        readIdent: function () {
            for (var lastDot, peekIndex, methodName, ch, parser = this,
                    ident = "",
                    start = this.index; this.index < this.text.length && (ch = this.text.charAt(this.index), "." === ch || this.isIdent(ch) || this.isNumber(ch));) "." === ch && (lastDot = this.index),
                ident += ch,
                this.index++;
            if (lastDot)
                for (peekIndex = this.index; peekIndex < this.text.length;) {
                    if (ch = this.text.charAt(peekIndex), "(" === ch) {
                        methodName = ident.substr(lastDot - start + 1),
                            ident = ident.substr(0, lastDot - start),
                            this.index = peekIndex;
                        break
                    }
                    if (!this.isWhitespace(ch)) break;
                    peekIndex++
                }
            var token = {
                index: start,
                text: ident
            };
            if (OPERATORS.hasOwnProperty(ident)) token.fn = OPERATORS[ident],
                token.json = OPERATORS[ident];
            else {
                var getter = getterFn(ident, this.options, this.text);
                token.fn = extend(function (self, locals) {
                    return getter(self, locals)
                }, {
                    assign: function (self, value) {
                        return setter(self, ident, value, parser.text, parser.options)
                    }
                })
            }
            this.tokens.push(token),
                methodName && (this.tokens.push({
                    index: lastDot,
                    text: ".",
                    json: !1
                }), this.tokens.push({
                    index: lastDot + 1,
                    text: methodName,
                    json: !1
                }))
        },
        readString: function (quote) {
            var start = this.index;
            this.index++;
            for (var string = "",
                    rawString = quote,
                    escape = !1; this.index < this.text.length;) {
                var ch = this.text.charAt(this.index);
                if (rawString += ch, escape) {
                    if ("u" === ch) {
                        var hex = this.text.substring(this.index + 1, this.index + 5);
                        hex.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + hex + "]"),
                            this.index += 4,
                            string += String.fromCharCode(parseInt(hex, 16))
                    } else {
                        var rep = ESCAPE[ch];
                        string += rep ? rep : ch
                    }
                    escape = !1
                } else if ("\\" === ch) escape = !0;
                else {
                    if (ch === quote) return this.index++,
                        void this.tokens.push({
                            index: start,
                            text: rawString,
                            string: string,
                            json: !0,
                            fn: function () {
                                return string
                            }
                        });
                    string += ch
                }
                this.index++
            }
            this.throwError("Unterminated quote", start)
        }
    };
    var Parser = function (lexer, $filter, options) {
        this.lexer = lexer,
            this.$filter = $filter,
            this.options = options
    };
    Parser.ZERO = function () {
            return 0
        },
        Parser.prototype = {
            constructor: Parser,
            parse: function (text, json) {
                this.text = text,
                    this.json = json,
                    this.tokens = this.lexer.lex(text),
                    json && (this.assignment = this.logicalOR, this.functionCall = this.fieldAccess = this.objectIndex = this.filterChain = function () {
                        this.throwError("is not valid json", {
                            text: text,
                            index: 0
                        })
                    });
                var value = json ? this.primary() : this.statements();
                return 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]),
                    value.literal = !!value.literal,
                    value.constant = !!value.constant,
                    value
            },
            primary: function () {
                var primary;
                if (this.expect("(")) primary = this.filterChain(),
                    this.consume(")");
                else if (this.expect("[")) primary = this.arrayDeclaration();
                else if (this.expect("{")) primary = this.object();
                else {
                    var token = this.expect();
                    primary = token.fn,
                        primary || this.throwError("not a primary expression", token),
                        token.json && (primary.constant = !0, primary.literal = !0)
                }
                for (var next, context; next = this.expect("(", "[", ".");) "(" === next.text ? (primary = this.functionCall(primary, context), context = null) : "[" === next.text ? (context = primary, primary = this.objectIndex(primary)) : "." === next.text ? (context = primary, primary = this.fieldAccess(primary)) : this.throwError("IMPOSSIBLE");
                return primary
            },
            throwError: function (msg, token) {
                throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index))
            },
            peekToken: function () {
                if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
                return this.tokens[0]
            },
            peek: function (e1, e2, e3, e4) {
                if (this.tokens.length > 0) {
                    var token = this.tokens[0],
                        t = token.text;
                    if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) return token
                }
                return !1
            },
            expect: function (e1, e2, e3, e4) {
                var token = this.peek(e1, e2, e3, e4);
                return token ? (this.json && !token.json && this.throwError("is not valid json", token), this.tokens.shift(), token) : !1
            },
            consume: function (e1) {
                this.expect(e1) || this.throwError("is unexpected, expecting [" + e1 + "]", this.peek())
            },
            unaryFn: function (fn, right) {
                return extend(function (self, locals) {
                    return fn(self, locals, right)
                }, {
                    constant: right.constant
                })
            },
            ternaryFn: function (left, middle, right) {
                return extend(function (self, locals) {
                    return left(self, locals) ? middle(self, locals) : right(self, locals)
                }, {
                    constant: left.constant && middle.constant && right.constant
                })
            },
            binaryFn: function (left, fn, right) {
                return extend(function (self, locals) {
                    return fn(self, locals, left, right)
                }, {
                    constant: left.constant && right.constant
                })
            },
            statements: function () {
                for (var statements = [];;)
                    if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]") && statements.push(this.filterChain()), !this.expect(";")) return 1 === statements.length ? statements[0] : function (self, locals) {
                        for (var value, i = 0; i < statements.length; i++) {
                            var statement = statements[i];
                            statement && (value = statement(self, locals))
                        }
                        return value
                    }
            },
            filterChain: function () {
                for (var token, left = this.expression();;) {
                    if (!(token = this.expect("|"))) return left;
                    left = this.binaryFn(left, token.fn, this.filter())
                }
            },
            filter: function () {
                for (var token = this.expect(), fn = this.$filter(token.text), argsFn = [];;) {
                    if (!(token = this.expect(":"))) {
                        var fnInvoke = function (self, locals, input) {
                            for (var args = [input], i = 0; i < argsFn.length; i++) args.push(argsFn[i](self, locals));
                            return fn.apply(self, args)
                        };
                        return function () {
                            return fnInvoke
                        }
                    }
                    argsFn.push(this.expression())
                }
            },
            expression: function () {
                return this.assignment()
            },
            assignment: function () {
                var right, token, left = this.ternary();
                return (token = this.expect("=")) ? (left.assign || this.throwError("implies assignment but [" + this.text.substring(0, token.index) + "] can not be assigned to", token), right = this.ternary(),
                    function (scope, locals) {
                        return left.assign(scope, right(scope, locals), locals)
                    }) : left
            },
            ternary: function () {
                var middle, token, left = this.logicalOR();
                return (token = this.expect("?")) ? (middle = this.ternary(), (token = this.expect(":")) ? this.ternaryFn(left, middle, this.ternary()) : void this.throwError("expected :", token)) : left
            },
            logicalOR: function () {
                for (var token, left = this.logicalAND();;) {
                    if (!(token = this.expect("||"))) return left;
                    left = this.binaryFn(left, token.fn, this.logicalAND())
                }
            },
            logicalAND: function () {
                var token, left = this.equality();
                return (token = this.expect("&&")) && (left = this.binaryFn(left, token.fn, this.logicalAND())),
                    left
            },
            equality: function () {
                var token, left = this.relational();
                return (token = this.expect("==", "!=", "===", "!==")) && (left = this.binaryFn(left, token.fn, this.equality())),
                    left
            },
            relational: function () {
                var token, left = this.additive();
                return (token = this.expect("<", ">", "<=", ">=")) && (left = this.binaryFn(left, token.fn, this.relational())),
                    left
            },
            additive: function () {
                for (var token, left = this.multiplicative(); token = this.expect("+", "-");) left = this.binaryFn(left, token.fn, this.multiplicative());
                return left
            },
            multiplicative: function () {
                for (var token, left = this.unary(); token = this.expect("*", "/", "%");) left = this.binaryFn(left, token.fn, this.unary());
                return left
            },
            unary: function () {
                var token;
                return this.expect("+") ? this.primary() : (token = this.expect("-")) ? this.binaryFn(Parser.ZERO, token.fn, this.unary()) : (token = this.expect("!")) ? this.unaryFn(token.fn, this.unary()) : this.primary()
            },
            fieldAccess: function (object) {
                var parser = this,
                    field = this.expect().text,
                    getter = getterFn(field, this.options, this.text);
                return extend(function (scope, locals, self) {
                    return getter(self || object(scope, locals), locals)
                }, {
                    assign: function (scope, value, locals) {
                        return setter(object(scope, locals), field, value, parser.text, parser.options)
                    }
                })
            },
            objectIndex: function (obj) {
                var parser = this,
                    indexFn = this.expression();
                return this.consume("]"),
                    extend(function (self, locals) {
                        var v, p, o = obj(self, locals),
                            i = indexFn(self, locals);
                        return o ? (v = ensureSafeObject(o[i], parser.text), v && v.then && parser.options.unwrapPromises && (p = v, "$$v" in v || (p.$$v = undefined, p.then(function (val) {
                            p.$$v = val
                        })), v = v.$$v), v) : undefined
                    }, {
                        assign: function (self, value, locals) {
                            var key = indexFn(self, locals),
                                safe = ensureSafeObject(obj(self, locals), parser.text);
                            return safe[key] = value
                        }
                    })
            },
            functionCall: function (fn, contextGetter) {
                var argsFn = [];
                if (")" !== this.peekToken().text)
                    do argsFn.push(this.expression());
                    while (this.expect(","));
                this.consume(")");
                var parser = this;
                return function (scope, locals) {
                    for (var args = [], context = contextGetter ? contextGetter(scope, locals) : scope, i = 0; i < argsFn.length; i++) args.push(argsFn[i](scope, locals));
                    var fnPtr = fn(scope, locals, context) || noop;
                    ensureSafeObject(context, parser.text),
                        ensureSafeObject(fnPtr, parser.text);
                    var v = fnPtr.apply ? fnPtr.apply(context, args) : fnPtr(args[0], args[1], args[2], args[3], args[4]);
                    return ensureSafeObject(v, parser.text)
                }
            },
            arrayDeclaration: function () {
                var elementFns = [],
                    allConstant = !0;
                if ("]" !== this.peekToken().text)
                    do {
                        var elementFn = this.expression();
                        elementFns.push(elementFn), elementFn.constant || (allConstant = !1)
                    } while (this.expect(","));
                return this.consume("]"),
                    extend(function (self, locals) {
                        for (var array = [], i = 0; i < elementFns.length; i++) array.push(elementFns[i](self, locals));
                        return array
                    }, {
                        literal: !0,
                        constant: allConstant
                    })
            },
            object: function () {
                var keyValues = [],
                    allConstant = !0;
                if ("}" !== this.peekToken().text)
                    do {
                        var token = this.expect(),
                            key = token.string || token.text;
                        this.consume(":");
                        var value = this.expression();
                        keyValues.push({
                            key: key,
                            value: value
                        }), value.constant || (allConstant = !1)
                    } while (this.expect(","));
                return this.consume("}"),
                    extend(function (self, locals) {
                        for (var object = {},
                                i = 0; i < keyValues.length; i++) {
                            var keyValue = keyValues[i];
                            object[keyValue.key] = keyValue.value(self, locals)
                        }
                        return object
                    }, {
                        literal: !0,
                        constant: allConstant
                    })
            }
        };
    var getterFnCache = {},
        $sceMinErr = minErr("$sce"),
        SCE_CONTEXTS = {
            HTML: "html",
            CSS: "css",
            URL: "url",
            RESOURCE_URL: "resourceUrl",
            JS: "js"
        },
        urlParsingNode = document.createElement("a"),
        originUrl = urlResolve(window.location.href, !0);
    $FilterProvider.$inject = ["$provide"],
        currencyFilter.$inject = ["$locale"],
        numberFilter.$inject = ["$locale"];
    var DECIMAL_SEP = ".",
        DATE_FORMATS = {
            yyyy: dateGetter("FullYear", 4),
            yy: dateGetter("FullYear", 2, 0, !0),
            y: dateGetter("FullYear", 1),
            MMMM: dateStrGetter("Month"),
            MMM: dateStrGetter("Month", !0),
            MM: dateGetter("Month", 2, 1),
            M: dateGetter("Month", 1, 1),
            dd: dateGetter("Date", 2),
            d: dateGetter("Date", 1),
            HH: dateGetter("Hours", 2),
            H: dateGetter("Hours", 1),
            hh: dateGetter("Hours", 2, -12),
            h: dateGetter("Hours", 1, -12),
            mm: dateGetter("Minutes", 2),
            m: dateGetter("Minutes", 1),
            ss: dateGetter("Seconds", 2),
            s: dateGetter("Seconds", 1),
            sss: dateGetter("Milliseconds", 3),
            EEEE: dateStrGetter("Day"),
            EEE: dateStrGetter("Day", !0),
            a: ampmGetter,
            Z: timeZoneGetter
        },
        DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/,
        NUMBER_STRING = /^\-?\d+$/;
    dateFilter.$inject = ["$locale"];
    var lowercaseFilter = valueFn(lowercase),
        uppercaseFilter = valueFn(uppercase);
    orderByFilter.$inject = ["$parse"];
    var htmlAnchorDirective = valueFn({
            restrict: "E",
            compile: function (element, attr) {
                return 8 >= msie && (attr.href || attr.name || attr.$set("href", ""), element.append(document.createComment("IE fix"))),
                    function (scope, element) {
                        element.on("click",
                            function (event) {
                                element.attr("href") || event.preventDefault()
                            })
                    }
            }
        }),
        ngAttributeAliasDirectives = {};
    forEach(BOOLEAN_ATTR,
            function (propName, attrName) {
                if ("multiple" != propName) {
                    var normalized = directiveNormalize("ng-" + attrName);
                    ngAttributeAliasDirectives[normalized] = function () {
                        return {
                            priority: 100,
                            compile: function () {
                                return function (scope, element, attr) {
                                    scope.$watch(attr[normalized],
                                        function (value) {
                                            attr.$set(attrName, !!value)
                                        })
                                }
                            }
                        }
                    }
                }
            }),
        forEach(["src", "srcset", "href"],
            function (attrName) {
                var normalized = directiveNormalize("ng-" + attrName);
                ngAttributeAliasDirectives[normalized] = function () {
                    return {
                        priority: 99,
                        link: function (scope, element, attr) {
                            attr.$observe(normalized,
                                function (value) {
                                    value && (attr.$set(attrName, value), msie && element.prop(attrName, attr[attrName]))
                                })
                        }
                    }
                }
            });
    var nullFormCtrl = {
        $addControl: noop,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop
    };
    FormController.$inject = ["$element", "$attrs", "$scope"];
    var formDirectiveFactory = function (isNgForm) {
            return ["$timeout",
                function ($timeout) {
                    var formDirective = {
                        name: "form",
                        restrict: isNgForm ? "EAC" : "E",
                        controller: FormController,
                        compile: function () {
                            return {
                                pre: function (scope, formElement, attr, controller) {
                                    if (!attr.action) {
                                        var preventDefaultListener = function (event) {
                                            event.preventDefault ? event.preventDefault() : event.returnValue = !1
                                        };
                                        addEventListenerFn(formElement[0], "submit", preventDefaultListener),
                                            formElement.on("$destroy",
                                                function () {
                                                    $timeout(function () {
                                                            removeEventListenerFn(formElement[0], "submit", preventDefaultListener)
                                                        },
                                                        0, !1)
                                                })
                                    }
                                    var parentFormCtrl = formElement.parent().controller("form"),
                                        alias = attr.name || attr.ngForm;
                                    alias && setter(scope, alias, controller, alias),
                                        parentFormCtrl && formElement.on("$destroy",
                                            function () {
                                                parentFormCtrl.$removeControl(controller),
                                                    alias && setter(scope, alias, undefined, alias),
                                                    extend(controller, nullFormCtrl)
                                            })
                                }
                            }
                        }
                    };
                    return formDirective
                }
            ]
        },
        formDirective = formDirectiveFactory(),
        ngFormDirective = formDirectiveFactory(!0),
        URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/,
        EMAIL_REGEXP = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}$/,
        NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/,
        inputType = {
            text: textInputType,
            number: numberInputType,
            url: urlInputType,
            email: emailInputType,
            radio: radioInputType,
            checkbox: checkboxInputType,
            hidden: noop,
            button: noop,
            submit: noop,
            reset: noop
        },
        inputDirective = ["$browser", "$sniffer",
            function ($browser, $sniffer) {
                return {
                    restrict: "E",
                    require: "?ngModel",
                    link: function (scope, element, attr, ctrl) {
                        ctrl && (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer, $browser)
                    }
                }
            }
        ],
        VALID_CLASS = "ng-valid",
        INVALID_CLASS = "ng-invalid",
        PRISTINE_CLASS = "ng-pristine",
        DIRTY_CLASS = "ng-dirty",
        NgModelController = ["$scope", "$exceptionHandler", "$attrs", "$element", "$parse",
            function ($scope, $exceptionHandler, $attr, $element, $parse) {
                function toggleValidCss(isValid, validationErrorKey) {
                    validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "",
                        $element.removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey)
                }
                this.$viewValue = Number.NaN,
                    this.$modelValue = Number.NaN,
                    this.$parsers = [],
                    this.$formatters = [],
                    this.$viewChangeListeners = [],
                    this.$pristine = !0,
                    this.$dirty = !1,
                    this.$valid = !0,
                    this.$invalid = !1,
                    this.$name = $attr.name;
                var ngModelGet = $parse($attr.ngModel),
                    ngModelSet = ngModelGet.assign;
                if (!ngModelSet) throw minErr("ngModel")("nonassign", "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
                this.$render = noop,
                    this.$isEmpty = function (value) {
                        return isUndefined(value) || "" === value || null === value || value !== value
                    };
                var parentForm = $element.inheritedData("$formController") || nullFormCtrl,
                    invalidCount = 0,
                    $error = this.$error = {};
                $element.addClass(PRISTINE_CLASS),
                    toggleValidCss(!0),
                    this.$setValidity = function (validationErrorKey, isValid) {
                        $error[validationErrorKey] !== !isValid && (isValid ? ($error[validationErrorKey] && invalidCount--, invalidCount || (toggleValidCss(!0), this.$valid = !0, this.$invalid = !1)) : (toggleValidCss(!1), this.$invalid = !0, this.$valid = !1, invalidCount++), $error[validationErrorKey] = !isValid, toggleValidCss(isValid, validationErrorKey), parentForm.$setValidity(validationErrorKey, isValid, this))
                    },
                    this.$setPristine = function () {
                        this.$dirty = !1,
                            this.$pristine = !0,
                            $element.removeClass(DIRTY_CLASS).addClass(PRISTINE_CLASS)
                    },
                    this.$setViewValue = function (value) {
                        this.$viewValue = value,
                            this.$pristine && (this.$dirty = !0, this.$pristine = !1, $element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS), parentForm.$setDirty()),
                            forEach(this.$parsers,
                                function (fn) {
                                    value = fn(value)
                                }),
                            this.$modelValue !== value && (this.$modelValue = value, ngModelSet($scope, value), forEach(this.$viewChangeListeners,
                                function (listener) {
                                    try {
                                        listener()
                                    } catch (e) {
                                        $exceptionHandler(e)
                                    }
                                }))
                    };
                var ctrl = this;
                $scope.$watch(function () {
                    var value = ngModelGet($scope);
                    if (ctrl.$modelValue !== value) {
                        var formatters = ctrl.$formatters,
                            idx = formatters.length;
                        for (ctrl.$modelValue = value; idx--;) value = formatters[idx](value);
                        ctrl.$viewValue !== value && (ctrl.$viewValue = value, ctrl.$render())
                    }
                    return value
                })
            }
        ],
        ngModelDirective = function () {
            return {
                require: ["ngModel", "^?form"],
                controller: NgModelController,
                link: function (scope, element, attr, ctrls) {
                    var modelCtrl = ctrls[0],
                        formCtrl = ctrls[1] || nullFormCtrl;
                    formCtrl.$addControl(modelCtrl),
                        scope.$on("$destroy",
                            function () {
                                formCtrl.$removeControl(modelCtrl)
                            })
                }
            }
        },
        ngChangeDirective = valueFn({
            require: "ngModel",
            link: function (scope, element, attr, ctrl) {
                ctrl.$viewChangeListeners.push(function () {
                    scope.$eval(attr.ngChange)
                })
            }
        }),
        requiredDirective = function () {
            return {
                require: "?ngModel",
                link: function (scope, elm, attr, ctrl) {
                    if (ctrl) {
                        attr.required = !0;
                        var validator = function (value) {
                            return attr.required && ctrl.$isEmpty(value) ? void ctrl.$setValidity("required", !1) : (ctrl.$setValidity("required", !0), value)
                        };
                        ctrl.$formatters.push(validator),
                            ctrl.$parsers.unshift(validator),
                            attr.$observe("required",
                                function () {
                                    validator(ctrl.$viewValue)
                                })
                    }
                }
            }
        },
        ngListDirective = function () {
            return {
                require: "ngModel",
                link: function (scope, element, attr, ctrl) {
                    var match = /\/(.*)\//.exec(attr.ngList),
                        separator = match && new RegExp(match[1]) || attr.ngList || ",",
                        parse = function (viewValue) {
                            if (!isUndefined(viewValue)) {
                                var list = [];
                                return viewValue && forEach(viewValue.split(separator),
                                        function (value) {
                                            value && list.push(trim(value))
                                        }),
                                    list
                            }
                        };
                    ctrl.$parsers.push(parse),
                        ctrl.$formatters.push(function (value) {
                            return isArray(value) ? value.join(", ") : undefined
                        }),
                        ctrl.$isEmpty = function (value) {
                            return !value || !value.length
                        }
                }
            }
        },
        CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/,
        ngValueDirective = function () {
            return {
                priority: 100,
                compile: function (tpl, tplAttr) {
                    return CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue) ?
                        function (scope, elm, attr) {
                            attr.$set("value", scope.$eval(attr.ngValue))
                        } : function (scope, elm, attr) {
                            scope.$watch(attr.ngValue,
                                function (value) {
                                    attr.$set("value", value)
                                })
                        }
                }
            }
        },
        ngBindDirective = ngDirective(function (scope, element, attr) {
            element.addClass("ng-binding").data("$binding", attr.ngBind),
                scope.$watch(attr.ngBind,
                    function (value) {
                        element.text(value == undefined ? "" : value)
                    })
        }),
        ngBindTemplateDirective = ["$interpolate",
            function ($interpolate) {
                return function (scope, element, attr) {
                    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                    element.addClass("ng-binding").data("$binding", interpolateFn),
                        attr.$observe("ngBindTemplate",
                            function (value) {
                                element.text(value)
                            })
                }
            }
        ],
        ngBindHtmlDirective = ["$sce", "$parse",
            function ($sce, $parse) {
                return function (scope, element, attr) {
                    function getStringValue() {
                        return (parsed(scope) || "").toString()
                    }
                    element.addClass("ng-binding").data("$binding", attr.ngBindHtml);
                    var parsed = $parse(attr.ngBindHtml);
                    scope.$watch(getStringValue,
                        function () {
                            element.html($sce.getTrustedHtml(parsed(scope)) || "")
                        })
                }
            }
        ],
        ngClassDirective = classDirective("", !0),
        ngClassOddDirective = classDirective("Odd", 0),
        ngClassEvenDirective = classDirective("Even", 1),
        ngCloakDirective = ngDirective({
            compile: function (element, attr) {
                attr.$set("ngCloak", undefined),
                    element.removeClass("ng-cloak")
            }
        }),
        ngControllerDirective = [function () {
            return {
                scope: !0,
                controller: "@",
                priority: 500
            }
        }],
        ngEventDirectives = {};
    forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "),
        function (name) {
            var directiveName = directiveNormalize("ng-" + name);
            ngEventDirectives[directiveName] = ["$parse",
                function ($parse) {
                    return {
                        compile: function ($element, attr) {
                            var fn = $parse(attr[directiveName]);
                            return function (scope, element) {
                                element.on(lowercase(name),
                                    function (event) {
                                        scope.$apply(function () {
                                            fn(scope, {
                                                $event: event
                                            })
                                        })
                                    })
                            }
                        }
                    }
                }
            ]
        });
    var ngIfDirective = ["$animate",
            function ($animate) {
                return {
                    transclude: "element",
                    priority: 600,
                    terminal: !0,
                    restrict: "A",
                    $$tlb: !0,
                    link: function ($scope, $element, $attr, ctrl, $transclude) {
                        var block, childScope;
                        $scope.$watch($attr.ngIf,
                            function (value) {
                                toBoolean(value) ? childScope || (childScope = $scope.$new(), $transclude(childScope,
                                    function (clone) {
                                        clone[clone.length++] = document.createComment(" end ngIf: " + $attr.ngIf + " "),
                                            block = {
                                                clone: clone
                                            },
                                            $animate.enter(clone, $element.parent(), $element)
                                    })) : (childScope && (childScope.$destroy(), childScope = null), block && ($animate.leave(getBlockElements(block.clone)), block = null))
                            })
                    }
                }
            }
        ],
        ngIncludeDirective = ["$http", "$templateCache", "$anchorScroll", "$compile", "$animate", "$sce",
            function ($http, $templateCache, $anchorScroll, $compile, $animate, $sce) {
                return {
                    restrict: "ECA",
                    priority: 400,
                    terminal: !0,
                    transclude: "element",
                    compile: function (element, attr) {
                        var srcExp = attr.ngInclude || attr.src,
                            onloadExp = attr.onload || "",
                            autoScrollExp = attr.autoscroll;
                        return function (scope, $element, $attr, ctrl, $transclude) {
                            var currentScope, currentElement, changeCounter = 0,
                                cleanupLastIncludeContent = function () {
                                    currentScope && (currentScope.$destroy(), currentScope = null),
                                        currentElement && ($animate.leave(currentElement), currentElement = null)
                                };
                            scope.$watch($sce.parseAsResourceUrl(srcExp),
                                function (src) {
                                    var afterAnimation = function () {
                                            !isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll()
                                        },
                                        thisChangeId = ++changeCounter;
                                    src ? ($http.get(src, {
                                        cache: $templateCache
                                    }).success(function (response) {
                                        if (thisChangeId === changeCounter) {
                                            var newScope = scope.$new(),
                                                clone = $transclude(newScope, noop);
                                            cleanupLastIncludeContent(),
                                                currentScope = newScope,
                                                currentElement = clone,
                                                currentElement.html(response),
                                                $animate.enter(currentElement, null, $element, afterAnimation),
                                                $compile(currentElement.contents())(currentScope),
                                                currentScope.$emit("$includeContentLoaded"),
                                                scope.$eval(onloadExp)
                                        }
                                    }).error(function () {
                                        thisChangeId === changeCounter && cleanupLastIncludeContent()
                                    }), scope.$emit("$includeContentRequested")) : cleanupLastIncludeContent()
                                })
                        }
                    }
                }
            }
        ],
        ngInitDirective = ngDirective({
            priority: 450,
            compile: function () {
                return {
                    pre: function (scope, element, attrs) {
                        scope.$eval(attrs.ngInit)
                    }
                }
            }
        }),
        ngNonBindableDirective = ngDirective({
            terminal: !0,
            priority: 1e3
        }),
        ngPluralizeDirective = ["$locale", "$interpolate",
            function ($locale, $interpolate) {
                var BRACE = /{}/g;
                return {
                    restrict: "EA",
                    link: function (scope, element, attr) {
                        var numberExp = attr.count,
                            whenExp = attr.$attr.when && element.attr(attr.$attr.when),
                            offset = attr.offset || 0,
                            whens = scope.$eval(whenExp) || {},
                            whensExpFns = {},
                            startSymbol = $interpolate.startSymbol(),
                            endSymbol = $interpolate.endSymbol(),
                            isWhen = /^when(Minus)?(.+)$/;
                        forEach(attr,
                                function (expression, attributeName) {
                                    isWhen.test(attributeName) && (whens[lowercase(attributeName.replace("when", "").replace("Minus", "-"))] = element.attr(attr.$attr[attributeName]))
                                }),
                            forEach(whens,
                                function (expression, key) {
                                    whensExpFns[key] = $interpolate(expression.replace(BRACE, startSymbol + numberExp + "-" + offset + endSymbol))
                                }),
                            scope.$watch(function () {
                                    var value = parseFloat(scope.$eval(numberExp));
                                    return isNaN(value) ? "" : (value in whens || (value = $locale.pluralCat(value - offset)), whensExpFns[value](scope, element, !0))
                                },
                                function (newVal) {
                                    element.text(newVal)
                                })
                    }
                }
            }
        ],
        ngRepeatDirective = ["$parse", "$animate",
            function ($parse, $animate) {
                function getBlockStart(block) {
                    return block.clone[0]
                }

                function getBlockEnd(block) {
                    return block.clone[block.clone.length - 1]
                }
                var NG_REMOVED = "$$NG_REMOVED",
                    ngRepeatMinErr = minErr("ngRepeat");
                return {
                    transclude: "element",
                    priority: 1e3,
                    terminal: !0,
                    $$tlb: !0,
                    link: function ($scope, $element, $attr, ctrl, $transclude) {
                        var trackByExp, trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn, lhs, rhs, valueIdentifier, keyIdentifier, expression = $attr.ngRepeat,
                            match = expression.match(/^\s*(.+)\s+in\s+(.*?)\s*(\s+track\s+by\s+(.+)\s*)?$/),
                            hashFnLocals = {
                                $id: hashKey
                            };
                        if (!match) throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                        if (lhs = match[1], rhs = match[2], trackByExp = match[4], trackByExp ? (trackByExpGetter = $parse(trackByExp), trackByIdExpFn = function (key, value, index) {
                                return keyIdentifier && (hashFnLocals[keyIdentifier] = key),
                                    hashFnLocals[valueIdentifier] = value,
                                    hashFnLocals.$index = index,
                                    trackByExpGetter($scope, hashFnLocals)
                            }) : (trackByIdArrayFn = function (key, value) {
                                    return hashKey(value)
                                },
                                trackByIdObjFn = function (key) {
                                    return key
                                }), match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/), !match) throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                        valueIdentifier = match[3] || match[1],
                            keyIdentifier = match[2];
                        var lastBlockMap = {};
                        $scope.$watchCollection(rhs,
                            function (collection) {
                                var index, length, nextNode, arrayLength, childScope, key, value, trackById, trackByIdFn, collectionKeys, block, elementsToRemove, previousNode = $element[0],
                                    nextBlockMap = {},
                                    nextBlockOrder = [];
                                if (isArrayLike(collection)) collectionKeys = collection,
                                    trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                                else {
                                    trackByIdFn = trackByIdExpFn || trackByIdObjFn,
                                        collectionKeys = [];
                                    for (key in collection) collection.hasOwnProperty(key) && "$" != key.charAt(0) && collectionKeys.push(key);
                                    collectionKeys.sort()
                                }
                                for (arrayLength = collectionKeys.length, length = nextBlockOrder.length = collectionKeys.length, index = 0; length > index; index++)
                                    if (key = collection === collectionKeys ? index : collectionKeys[index], value = collection[key], trackById = trackByIdFn(key, value, index), assertNotHasOwnProperty(trackById, "`track by` id"), lastBlockMap.hasOwnProperty(trackById)) block = lastBlockMap[trackById],
                                        delete lastBlockMap[trackById],
                                        nextBlockMap[trackById] = block,
                                        nextBlockOrder[index] = block;
                                    else {
                                        if (nextBlockMap.hasOwnProperty(trackById)) throw forEach(nextBlockOrder,
                                                function (block) {
                                                    block && block.scope && (lastBlockMap[block.id] = block)
                                                }),
                                            ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}", expression, trackById);
                                        nextBlockOrder[index] = {
                                                id: trackById
                                            },
                                            nextBlockMap[trackById] = !1
                                    }
                                for (key in lastBlockMap) lastBlockMap.hasOwnProperty(key) && (block = lastBlockMap[key], elementsToRemove = getBlockElements(block.clone), $animate.leave(elementsToRemove), forEach(elementsToRemove,
                                    function (element) {
                                        element[NG_REMOVED] = !0
                                    }), block.scope.$destroy());
                                for (index = 0, length = collectionKeys.length; length > index; index++) {
                                    if (key = collection === collectionKeys ? index : collectionKeys[index], value = collection[key], block = nextBlockOrder[index], nextBlockOrder[index - 1] && (previousNode = getBlockEnd(nextBlockOrder[index - 1])), block.scope) {
                                        childScope = block.scope,
                                            nextNode = previousNode;
                                        do nextNode = nextNode.nextSibling;
                                        while (nextNode && nextNode[NG_REMOVED]);
                                        getBlockStart(block) != nextNode && $animate.move(getBlockElements(block.clone), null, jqLite(previousNode)),
                                            previousNode = getBlockEnd(block)
                                    } else childScope = $scope.$new();
                                    childScope[valueIdentifier] = value,
                                        keyIdentifier && (childScope[keyIdentifier] = key),
                                        childScope.$index = index,
                                        childScope.$first = 0 === index,
                                        childScope.$last = index === arrayLength - 1,
                                        childScope.$middle = !(childScope.$first || childScope.$last),
                                        childScope.$odd = !(childScope.$even = 0 === (1 & index)),
                                        block.scope || $transclude(childScope,
                                            function (clone) {
                                                clone[clone.length++] = document.createComment(" end ngRepeat: " + expression + " "),
                                                    $animate.enter(clone, null, jqLite(previousNode)),
                                                    previousNode = clone,
                                                    block.scope = childScope,
                                                    block.clone = clone,
                                                    nextBlockMap[block.id] = block
                                            })
                                }
                                lastBlockMap = nextBlockMap
                            })
                    }
                }
            }
        ],
        ngShowDirective = ["$animate",
            function ($animate) {
                return function (scope, element, attr) {
                    scope.$watch(attr.ngShow,
                        function (value) {
                            $animate[toBoolean(value) ? "removeClass" : "addClass"](element, "ng-hide")
                        })
                }
            }
        ],
        ngHideDirective = ["$animate",
            function ($animate) {
                return function (scope, element, attr) {
                    scope.$watch(attr.ngHide,
                        function (value) {
                            $animate[toBoolean(value) ? "addClass" : "removeClass"](element, "ng-hide")
                        })
                }
            }
        ],
        ngStyleDirective = ngDirective(function (scope, element, attr) {
            scope.$watch(attr.ngStyle,
                function (newStyles, oldStyles) {
                    oldStyles && newStyles !== oldStyles && forEach(oldStyles,
                            function (val, style) {
                                element.css(style, "")
                            }),
                        newStyles && element.css(newStyles)
                }, !0)
        }),
        ngSwitchDirective = ["$animate",
            function ($animate) {
                return {
                    restrict: "EA",
                    require: "ngSwitch",
                    controller: ["$scope",
                        function () {
                            this.cases = {}
                        }
                    ],
                    link: function (scope, element, attr, ngSwitchController) {
                        var selectedTranscludes, selectedElements, watchExpr = attr.ngSwitch || attr.on,
                            selectedScopes = [];
                        scope.$watch(watchExpr,
                            function (value) {
                                for (var i = 0,
                                        ii = selectedScopes.length; ii > i; i++) selectedScopes[i].$destroy(),
                                    $animate.leave(selectedElements[i]);
                                selectedElements = [],
                                    selectedScopes = [],
                                    (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) && (scope.$eval(attr.change), forEach(selectedTranscludes,
                                        function (selectedTransclude) {
                                            var selectedScope = scope.$new();
                                            selectedScopes.push(selectedScope),
                                                selectedTransclude.transclude(selectedScope,
                                                    function (caseElement) {
                                                        var anchor = selectedTransclude.element;
                                                        selectedElements.push(caseElement),
                                                            $animate.enter(caseElement, anchor.parent(), anchor)
                                                    })
                                        }))
                            })
                    }
                }
            }
        ],
        ngSwitchWhenDirective = ngDirective({
            transclude: "element",
            priority: 800,
            require: "^ngSwitch",
            compile: function (element, attrs) {
                return function (scope, element, attr, ctrl, $transclude) {
                    ctrl.cases["!" + attrs.ngSwitchWhen] = ctrl.cases["!" + attrs.ngSwitchWhen] || [],
                        ctrl.cases["!" + attrs.ngSwitchWhen].push({
                            transclude: $transclude,
                            element: element
                        })
                }
            }
        }),
        ngSwitchDefaultDirective = ngDirective({
            transclude: "element",
            priority: 800,
            require: "^ngSwitch",
            link: function (scope, element, attr, ctrl, $transclude) {
                ctrl.cases["?"] = ctrl.cases["?"] || [],
                    ctrl.cases["?"].push({
                        transclude: $transclude,
                        element: element
                    })
            }
        }),
        ngTranscludeDirective = ngDirective({
            controller: ["$element", "$transclude",
                function ($element, $transclude) {
                    if (!$transclude) throw minErr("ngTransclude")("orphan", "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}", startingTag($element));
                    this.$transclude = $transclude
                }
            ],
            link: function ($scope, $element, $attrs, controller) {
                controller.$transclude(function (clone) {
                    $element.html(""),
                        $element.append(clone)
                })
            }
        }),
        scriptDirective = ["$templateCache",
            function ($templateCache) {
                return {
                    restrict: "E",
                    terminal: !0,
                    compile: function (element, attr) {
                        if ("text/ng-template" == attr.type) {
                            var templateUrl = attr.id,
                                text = element[0].text;
                            $templateCache.put(templateUrl, text)
                        }
                    }
                }
            }
        ],
        ngOptionsMinErr = minErr("ngOptions"),
        ngOptionsDirective = valueFn({
            terminal: !0
        }),
        selectDirective = ["$compile", "$parse",
            function ($compile, $parse) {
                var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(.*?)(?:\s+track\s+by\s+(.*?))?$/,
                    nullModelCtrl = {
                        $setViewValue: noop
                    };
                return {
                    restrict: "E",
                    require: ["select", "?ngModel"],
                    controller: ["$element", "$scope", "$attrs",
                        function ($element, $scope, $attrs) {
                            var nullOption, unknownOption, self = this,
                                optionsMap = {},
                                ngModelCtrl = nullModelCtrl;
                            self.databound = $attrs.ngModel,
                                self.init = function (ngModelCtrl_, nullOption_, unknownOption_) {
                                    ngModelCtrl = ngModelCtrl_,
                                        nullOption = nullOption_,
                                        unknownOption = unknownOption_
                                },
                                self.addOption = function (value) {
                                    assertNotHasOwnProperty(value, '"option value"'),
                                        optionsMap[value] = !0,
                                        ngModelCtrl.$viewValue == value && ($element.val(value), unknownOption.parent() && unknownOption.remove())
                                },
                                self.removeOption = function (value) {
                                    this.hasOption(value) && (delete optionsMap[value], ngModelCtrl.$viewValue == value && this.renderUnknownOption(value))
                                },
                                self.renderUnknownOption = function (val) {
                                    var unknownVal = "? " + hashKey(val) + " ?";
                                    unknownOption.val(unknownVal),
                                        $element.prepend(unknownOption),
                                        $element.val(unknownVal),
                                        unknownOption.prop("selected", !0)
                                },
                                self.hasOption = function (value) {
                                    return optionsMap.hasOwnProperty(value)
                                },
                                $scope.$on("$destroy",
                                    function () {
                                        self.renderUnknownOption = noop
                                    })
                        }
                    ],
                    link: function (scope, element, attr, ctrls) {
                        function setupAsSingle(scope, selectElement, ngModelCtrl, selectCtrl) {
                            ngModelCtrl.$render = function () {
                                    var viewValue = ngModelCtrl.$viewValue;
                                    selectCtrl.hasOption(viewValue) ? (unknownOption.parent() && unknownOption.remove(), selectElement.val(viewValue), "" === viewValue && emptyOption.prop("selected", !0)) : isUndefined(viewValue) && emptyOption ? selectElement.val("") : selectCtrl.renderUnknownOption(viewValue)
                                },
                                selectElement.on("change",
                                    function () {
                                        scope.$apply(function () {
                                            unknownOption.parent() && unknownOption.remove(),
                                                ngModelCtrl.$setViewValue(selectElement.val())
                                        })
                                    })
                        }

                        function setupAsMultiple(scope, selectElement, ctrl) {
                            var lastView;
                            ctrl.$render = function () {
                                    var items = new HashMap(ctrl.$viewValue);
                                    forEach(selectElement.find("option"),
                                        function (option) {
                                            option.selected = isDefined(items.get(option.value))
                                        })
                                },
                                scope.$watch(function () {
                                    equals(lastView, ctrl.$viewValue) || (lastView = copy(ctrl.$viewValue), ctrl.$render())
                                }),
                                selectElement.on("change",
                                    function () {
                                        scope.$apply(function () {
                                            var array = [];
                                            forEach(selectElement.find("option"),
                                                    function (option) {
                                                        option.selected && array.push(option.value)
                                                    }),
                                                ctrl.$setViewValue(array)
                                        })
                                    })
                        }

                        function setupAsOptions(scope, selectElement, ctrl) {
                            function render() {
                                var optionGroupName, optionGroup, option, existingParent, existingOptions, existingOption, key, groupLength, length, groupIndex, index, selected, lastElement, element, label, optionGroups = {
                                        "": []
                                    },
                                    optionGroupNames = [""],
                                    modelValue = ctrl.$modelValue,
                                    values = valuesFn(scope) || [],
                                    keys = keyName ? sortedKeys(values) : values,
                                    locals = {},
                                    selectedSet = !1;
                                if (multiple)
                                    if (trackFn && isArray(modelValue)) {
                                        selectedSet = new HashMap([]);
                                        for (var trackIndex = 0; trackIndex < modelValue.length; trackIndex++) locals[valueName] = modelValue[trackIndex],
                                            selectedSet.put(trackFn(scope, locals), modelValue[trackIndex])
                                    } else selectedSet = new HashMap(modelValue);
                                for (index = 0; length = keys.length, length > index; index++) {
                                    if (key = index, keyName) {
                                        if (key = keys[index], "$" === key.charAt(0)) continue;
                                        locals[keyName] = key
                                    }
                                    if (locals[valueName] = values[key], optionGroupName = groupByFn(scope, locals) || "", (optionGroup = optionGroups[optionGroupName]) || (optionGroup = optionGroups[optionGroupName] = [], optionGroupNames.push(optionGroupName)), multiple) selected = isDefined(selectedSet.remove(trackFn ? trackFn(scope, locals) : valueFn(scope, locals)));
                                    else {
                                        if (trackFn) {
                                            var modelCast = {};
                                            modelCast[valueName] = modelValue,
                                                selected = trackFn(scope, modelCast) === trackFn(scope, locals)
                                        } else selected = modelValue === valueFn(scope, locals);
                                        selectedSet = selectedSet || selected
                                    }
                                    label = displayFn(scope, locals),
                                        label = isDefined(label) ? label : "",
                                        optionGroup.push({
                                            id: trackFn ? trackFn(scope, locals) : keyName ? keys[index] : index,
                                            label: label,
                                            selected: selected
                                        })
                                }
                                for (multiple || (nullOption || null === modelValue ? optionGroups[""].unshift({
                                        id: "",
                                        label: "",
                                        selected: !selectedSet
                                    }) : selectedSet || optionGroups[""].unshift({
                                        id: "?",
                                        label: "",
                                        selected: !0
                                    })), groupIndex = 0, groupLength = optionGroupNames.length; groupLength > groupIndex; groupIndex++) {
                                    for (optionGroupName = optionGroupNames[groupIndex], optionGroup = optionGroups[optionGroupName], optionGroupsCache.length <= groupIndex ? (existingParent = {
                                                element: optGroupTemplate.clone().attr("label", optionGroupName),
                                                label: optionGroup.label
                                            },
                                            existingOptions = [existingParent], optionGroupsCache.push(existingOptions), selectElement.append(existingParent.element)) : (existingOptions = optionGroupsCache[groupIndex], existingParent = existingOptions[0], existingParent.label != optionGroupName && existingParent.element.attr("label", existingParent.label = optionGroupName)), lastElement = null, index = 0, length = optionGroup.length; length > index; index++) option = optionGroup[index],
                                        (existingOption = existingOptions[index + 1]) ? (lastElement = existingOption.element, existingOption.label !== option.label && lastElement.text(existingOption.label = option.label), existingOption.id !== option.id && lastElement.val(existingOption.id = option.id), lastElement[0].selected !== option.selected && lastElement.prop("selected", existingOption.selected = option.selected)) : ("" === option.id && nullOption ? element = nullOption : (element = optionTemplate.clone()).val(option.id).attr("selected", option.selected).text(option.label), existingOptions.push(existingOption = {
                                            element: element,
                                            label: option.label,
                                            id: option.id,
                                            selected: option.selected
                                        }), lastElement ? lastElement.after(element) : existingParent.element.append(element), lastElement = element);
                                    for (index++; existingOptions.length > index;) existingOptions.pop().element.remove()
                                }
                                for (; optionGroupsCache.length > groupIndex;) optionGroupsCache.pop()[0].element.remove()
                            }
                            var match;
                            if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) throw ngOptionsMinErr("iexp", "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
                            var displayFn = $parse(match[2] || match[1]),
                                valueName = match[4] || match[6],
                                keyName = match[5],
                                groupByFn = $parse(match[3] || ""),
                                valueFn = $parse(match[2] ? match[1] : valueName),
                                valuesFn = $parse(match[7]),
                                track = match[8],
                                trackFn = track ? $parse(match[8]) : null,
                                optionGroupsCache = [
                                    [{
                                        element: selectElement,
                                        label: ""
                                    }]
                                ];
                            nullOption && ($compile(nullOption)(scope), nullOption.removeClass("ng-scope"), nullOption.remove()),
                                selectElement.html(""),
                                selectElement.on("change",
                                    function () {
                                        scope.$apply(function () {
                                            var optionGroup, key, value, optionElement, index, groupIndex, length, groupLength, trackIndex, collection = valuesFn(scope) || [],
                                                locals = {};
                                            if (multiple) {
                                                for (value = [], groupIndex = 0, groupLength = optionGroupsCache.length; groupLength > groupIndex; groupIndex++)
                                                    for (optionGroup = optionGroupsCache[groupIndex], index = 1, length = optionGroup.length; length > index; index++)
                                                        if ((optionElement = optionGroup[index].element)[0].selected) {
                                                            if (key = optionElement.val(), keyName && (locals[keyName] = key), trackFn)
                                                                for (trackIndex = 0; trackIndex < collection.length && (locals[valueName] = collection[trackIndex], trackFn(scope, locals) != key); trackIndex++);
                                                            else locals[valueName] = collection[key];
                                                            value.push(valueFn(scope, locals))
                                                        }
                                            } else if (key = selectElement.val(), "?" == key) value = undefined;
                                            else if ("" === key) value = null;
                                            else if (trackFn) {
                                                for (trackIndex = 0; trackIndex < collection.length; trackIndex++)
                                                    if (locals[valueName] = collection[trackIndex], trackFn(scope, locals) == key) {
                                                        value = valueFn(scope, locals);
                                                        break
                                                    }
                                            } else locals[valueName] = collection[key],
                                                keyName && (locals[keyName] = key),
                                                value = valueFn(scope, locals);
                                            ctrl.$setViewValue(value)
                                        })
                                    }),
                                ctrl.$render = render,
                                scope.$watch(render)
                        }
                        if (ctrls[1]) {
                            for (var emptyOption, selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, optionsExp = attr.ngOptions, nullOption = !1, optionTemplate = jqLite(document.createElement("option")), optGroupTemplate = jqLite(document.createElement("optgroup")), unknownOption = optionTemplate.clone(), i = 0, children = element.children(), ii = children.length; ii > i; i++)
                                if ("" === children[i].value) {
                                    emptyOption = nullOption = children.eq(i);
                                    break
                                }
                            if (selectCtrl.init(ngModelCtrl, nullOption, unknownOption), multiple && (attr.required || attr.ngRequired)) {
                                var requiredValidator = function (value) {
                                    return ngModelCtrl.$setValidity("required", !attr.required || value && value.length),
                                        value
                                };
                                ngModelCtrl.$parsers.push(requiredValidator),
                                    ngModelCtrl.$formatters.unshift(requiredValidator),
                                    attr.$observe("required",
                                        function () {
                                            requiredValidator(ngModelCtrl.$viewValue)
                                        })
                            }
                            optionsExp ? setupAsOptions(scope, element, ngModelCtrl) : multiple ? setupAsMultiple(scope, element, ngModelCtrl) : setupAsSingle(scope, element, ngModelCtrl, selectCtrl)
                        }
                    }
                }
            }
        ],
        optionDirective = ["$interpolate",
            function ($interpolate) {
                var nullSelectCtrl = {
                    addOption: noop,
                    removeOption: noop
                };
                return {
                    restrict: "E",
                    priority: 100,
                    compile: function (element, attr) {
                        if (isUndefined(attr.value)) {
                            var interpolateFn = $interpolate(element.text(), !0);
                            interpolateFn || attr.$set("value", element.text())
                        }
                        return function (scope, element, attr) {
                            var selectCtrlName = "$selectController",
                                parent = element.parent(),
                                selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                            selectCtrl && selectCtrl.databound ? element.prop("selected", !1) : selectCtrl = nullSelectCtrl,
                                interpolateFn ? scope.$watch(interpolateFn,
                                    function (newVal, oldVal) {
                                        attr.$set("value", newVal),
                                            newVal !== oldVal && selectCtrl.removeOption(oldVal),
                                            selectCtrl.addOption(newVal)
                                    }) : selectCtrl.addOption(attr.value),
                                element.on("$destroy",
                                    function () {
                                        selectCtrl.removeOption(attr.value)
                                    })
                        }
                    }
                }
            }
        ],
        styleDirective = valueFn({
            restrict: "E",
            terminal: !0
        });
    bindJQuery(),
        publishExternalAPI(angular),
        jqLite(document).ready(function () {
            angularInit(document, bootstrap)
        })
}(window, document), !angular.$$csp() && angular.element(document).find("head").prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide{display:none !important;}ng\\:form{display:block;}.ng-animate-start{border-spacing:1px 1px;-ms-zoom:1.0001;}.ng-animate-active{border-spacing:0px 0px;-ms-zoom:1;}</style>'),
    function (window, angular, undefined) {
        "use strict";
        angular.module("ngAnimate", ["ng"]).config(["$provide", "$animateProvider",
            function ($provide, $animateProvider) {
                function extractElementNode(element) {
                    for (var i = 0; i < element.length; i++) {
                        var elm = element[i];
                        if (elm.nodeType == ELEMENT_NODE) return elm
                    }
                }

                function isMatchingElement(elm1, elm2) {
                    return extractElementNode(elm1) == extractElementNode(elm2)
                }
                var noop = angular.noop,
                    forEach = angular.forEach,
                    selectors = $animateProvider.$$selectors,
                    ELEMENT_NODE = 1,
                    NG_ANIMATE_STATE = "$$ngAnimateState",
                    NG_ANIMATE_CLASS_NAME = "ng-animate",
                    rootAnimateState = {
                        running: !0
                    };
                $provide.decorator("$animate", ["$delegate", "$injector", "$sniffer", "$rootElement", "$timeout", "$rootScope", "$document",
                        function ($delegate, $injector, $sniffer, $rootElement, $timeout, $rootScope) {
                            function lookup(name) {
                                if (name) {
                                    var matches = [],
                                        flagMap = {},
                                        classes = name.substr(1).split(".");
                                    ($sniffer.transitions || $sniffer.animations) && classes.push("");
                                    for (var i = 0; i < classes.length; i++) {
                                        var klass = classes[i],
                                            selectorFactoryName = selectors[klass];
                                        selectorFactoryName && !flagMap[klass] && (matches.push($injector.get(selectorFactoryName)), flagMap[klass] = !0)
                                    }
                                    return matches
                                }
                            }

                            function performAnimation(animationEvent, className, element, parentElement, afterElement, domOperation, doneCallback) {
                                function onBeforeAnimationsComplete(cancelled) {
                                    if (fireDOMOperation(), cancelled === !0) return void closeAnimation();
                                    var data = element.data(NG_ANIMATE_STATE);
                                    data && (data.done = closeAnimation, element.data(NG_ANIMATE_STATE, data)),
                                        invokeRegisteredAnimationFns(animations, "after", closeAnimation)
                                }

                                function invokeRegisteredAnimationFns(animations, phase, allAnimationFnsComplete) {
                                    function progress(index, phase) {
                                        var phaseCompletionFlag = phase + "Complete",
                                            currentAnimation = animations[index];
                                        currentAnimation[phaseCompletionFlag] = !0,
                                            (currentAnimation[endFnName] || noop)();
                                        for (var i = 0; i < animations.length; i++)
                                            if (!animations[i][phaseCompletionFlag]) return;
                                        allAnimationFnsComplete()
                                    }
                                    var endFnName = phase + "End";
                                    forEach(animations,
                                        function (animation, index) {
                                            var animationPhaseCompleted = function () {
                                                progress(index, phase)
                                            };
                                            return "before" != phase || "enter" != animationEvent && "move" != animationEvent ? void(animation[phase] ? animation[endFnName] = isClassBased ? animation[phase](element, className, animationPhaseCompleted) : animation[phase](element, animationPhaseCompleted) : animationPhaseCompleted()) : void animationPhaseCompleted()
                                        })
                                }

                                function fireDoneCallbackAsync() {
                                    doneCallback && $timeout(doneCallback, 0, !1)
                                }

                                function fireDOMOperation() {
                                    fireDOMOperation.hasBeenRun || (fireDOMOperation.hasBeenRun = !0, domOperation())
                                }

                                function closeAnimation() {
                                    if (!closeAnimation.hasBeenRun) {
                                        closeAnimation.hasBeenRun = !0;
                                        var data = element.data(NG_ANIMATE_STATE);
                                        data && (isClassBased ? cleanup(element) : (data.closeAnimationTimeout = $timeout(function () {
                                                    cleanup(element)
                                                },
                                                0, !1), element.data(NG_ANIMATE_STATE, data))),
                                            fireDoneCallbackAsync()
                                    }
                                }
                                var node = extractElementNode(element);
                                if (!node) return fireDOMOperation(),
                                    void closeAnimation();
                                var currentClassName = node.className,
                                    classes = currentClassName + " " + className,
                                    animationLookup = (" " + classes).replace(/\s+/g, ".");
                                parentElement || (parentElement = afterElement ? afterElement.parent() : element.parent());
                                var matches = lookup(animationLookup),
                                    isClassBased = "addClass" == animationEvent || "removeClass" == animationEvent,
                                    ngAnimateState = element.data(NG_ANIMATE_STATE) || {};
                                if (animationsDisabled(element, parentElement) || 0 === matches.length) return fireDOMOperation(),
                                    void closeAnimation();
                                var animations = [];
                                if (ngAnimateState.running && isClassBased && ngAnimateState.structural || forEach(matches,
                                        function (animation) {
                                            if (!animation.allowCancel || animation.allowCancel(element, animationEvent, className)) {
                                                var beforeFn, afterFn = animation[animationEvent];
                                                "leave" == animationEvent ? (beforeFn = afterFn, afterFn = null) : beforeFn = animation["before" + animationEvent.charAt(0).toUpperCase() + animationEvent.substr(1)],
                                                    animations.push({
                                                        before: beforeFn,
                                                        after: afterFn
                                                    })
                                            }
                                        }), 0 === animations.length) return fireDOMOperation(),
                                    void fireDoneCallbackAsync();
                                var futureClassName = " " + currentClassName + " ";
                                ngAnimateState.running && ($timeout.cancel(ngAnimateState.closeAnimationTimeout), cleanup(element), cancelAnimations(ngAnimateState.animations), ngAnimateState.beforeComplete ? (ngAnimateState.done || noop)(!0) : isClassBased && !ngAnimateState.structural && (futureClassName = "removeClass" == ngAnimateState.event ? futureClassName.replace(ngAnimateState.className, "") : futureClassName + ngAnimateState.className + " "));
                                var classNameToken = " " + className + " ";
                                return "addClass" == animationEvent && futureClassName.indexOf(classNameToken) >= 0 || "removeClass" == animationEvent && -1 == futureClassName.indexOf(classNameToken) ? (fireDOMOperation(), void fireDoneCallbackAsync()) : (element.addClass(NG_ANIMATE_CLASS_NAME), element.data(NG_ANIMATE_STATE, {
                                    running: !0,
                                    event: animationEvent,
                                    className: className,
                                    structural: !isClassBased,
                                    animations: animations,
                                    done: onBeforeAnimationsComplete
                                }), void invokeRegisteredAnimationFns(animations, "before", onBeforeAnimationsComplete))
                            }

                            function cancelChildAnimations(element) {
                                var node = extractElementNode(element);
                                forEach(node.querySelectorAll("." + NG_ANIMATE_CLASS_NAME),
                                    function (element) {
                                        element = angular.element(element);
                                        var data = element.data(NG_ANIMATE_STATE);
                                        data && (cancelAnimations(data.animations), cleanup(element))
                                    })
                            }

                            function cancelAnimations(animations) {
                                var isCancelledFlag = !0;
                                forEach(animations,
                                    function (animation) {
                                        animations.beforeComplete || (animation.beforeEnd || noop)(isCancelledFlag),
                                            animations.afterComplete || (animation.afterEnd || noop)(isCancelledFlag)
                                    })
                            }

                            function cleanup(element) {
                                isMatchingElement(element, $rootElement) ? rootAnimateState.disabled || (rootAnimateState.running = !1, rootAnimateState.structural = !1) : (element.removeClass(NG_ANIMATE_CLASS_NAME), element.removeData(NG_ANIMATE_STATE))
                            }

                            function animationsDisabled(element, parentElement) {
                                if (rootAnimateState.disabled) return !0;
                                if (isMatchingElement(element, $rootElement)) return rootAnimateState.disabled || rootAnimateState.running;
                                do {
                                    if (0 === parentElement.length) break;
                                    var isRoot = isMatchingElement(parentElement, $rootElement),
                                        state = isRoot ? rootAnimateState : parentElement.data(NG_ANIMATE_STATE),
                                        result = state && (!!state.disabled || !!state.running);
                                    if (isRoot || result) return result;
                                    if (isRoot) return !0
                                } while (parentElement = parentElement.parent());
                                return !0
                            }
                            return $rootElement.data(NG_ANIMATE_STATE, rootAnimateState),
                                $rootScope.$$postDigest(function () {
                                    $rootScope.$$postDigest(function () {
                                        rootAnimateState.running = !1
                                    })
                                }), {
                                    enter: function (element, parentElement, afterElement, doneCallback) {
                                        this.enabled(!1, element),
                                            $delegate.enter(element, parentElement, afterElement),
                                            $rootScope.$$postDigest(function () {
                                                performAnimation("enter", "ng-enter", element, parentElement, afterElement, noop, doneCallback)
                                            })
                                    },
                                    leave: function (element, doneCallback) {
                                        cancelChildAnimations(element),
                                            this.enabled(!1, element),
                                            $rootScope.$$postDigest(function () {
                                                performAnimation("leave", "ng-leave", element, null, null,
                                                    function () {
                                                        $delegate.leave(element)
                                                    },
                                                    doneCallback)
                                            })
                                    },
                                    move: function (element, parentElement, afterElement, doneCallback) {
                                        cancelChildAnimations(element),
                                            this.enabled(!1, element),
                                            $delegate.move(element, parentElement, afterElement),
                                            $rootScope.$$postDigest(function () {
                                                performAnimation("move", "ng-move", element, parentElement, afterElement, noop, doneCallback)
                                            })
                                    },
                                    addClass: function (element, className, doneCallback) {
                                        performAnimation("addClass", className, element, null, null,
                                            function () {
                                                $delegate.addClass(element, className)
                                            },
                                            doneCallback)
                                    },
                                    removeClass: function (element, className, doneCallback) {
                                        performAnimation("removeClass", className, element, null, null,
                                            function () {
                                                $delegate.removeClass(element, className)
                                            },
                                            doneCallback)
                                    },
                                    enabled: function (value, element) {
                                        switch (arguments.length) {
                                            case 2:
                                                if (value) cleanup(element);
                                                else {
                                                    var data = element.data(NG_ANIMATE_STATE) || {};
                                                    data.disabled = !0,
                                                        element.data(NG_ANIMATE_STATE, data)
                                                }
                                                break;
                                            case 1:
                                                rootAnimateState.disabled = !value;
                                                break;
                                            default:
                                                value = !rootAnimateState.disabled
                                        }
                                        return !!value
                                    }
                                }
                        }
                    ]),
                    $animateProvider.register("", ["$window", "$sniffer", "$timeout",
                        function ($window, $sniffer, $timeout) {
                            function afterReflow(callback) {
                                animationReflowQueue.push(callback),
                                    $timeout.cancel(animationTimer),
                                    animationTimer = $timeout(function () {
                                            forEach(animationReflowQueue,
                                                    function (fn) {
                                                        fn()
                                                    }),
                                                animationReflowQueue = [],
                                                animationTimer = null,
                                                lookupCache = {}
                                        },
                                        10, !1)
                            }

                            function getElementAnimationDetails(element, cacheKey) {
                                var data = cacheKey ? lookupCache[cacheKey] : null;
                                if (!data) {
                                    var transitionDelayStyle, animationDelayStyle, transitionDurationStyle, transitionPropertyStyle, transitionDuration = 0,
                                        transitionDelay = 0,
                                        animationDuration = 0,
                                        animationDelay = 0;
                                    forEach(element,
                                            function (element) {
                                                if (element.nodeType == ELEMENT_NODE) {
                                                    var elementStyles = $window.getComputedStyle(element) || {};
                                                    transitionDurationStyle = elementStyles[TRANSITION_PROP + DURATION_KEY],
                                                        transitionDuration = Math.max(parseMaxTime(transitionDurationStyle), transitionDuration),
                                                        transitionPropertyStyle = elementStyles[TRANSITION_PROP + PROPERTY_KEY],
                                                        transitionDelayStyle = elementStyles[TRANSITION_PROP + DELAY_KEY],
                                                        transitionDelay = Math.max(parseMaxTime(transitionDelayStyle), transitionDelay),
                                                        animationDelayStyle = elementStyles[ANIMATION_PROP + DELAY_KEY],
                                                        animationDelay = Math.max(parseMaxTime(animationDelayStyle), animationDelay);
                                                    var aDuration = parseMaxTime(elementStyles[ANIMATION_PROP + DURATION_KEY]);
                                                    aDuration > 0 && (aDuration *= parseInt(elementStyles[ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY], 10) || 1),
                                                        animationDuration = Math.max(aDuration, animationDuration)
                                                }
                                            }),
                                        data = {
                                            total: 0,
                                            transitionPropertyStyle: transitionPropertyStyle,
                                            transitionDurationStyle: transitionDurationStyle,
                                            transitionDelayStyle: transitionDelayStyle,
                                            transitionDelay: transitionDelay,
                                            transitionDuration: transitionDuration,
                                            animationDelayStyle: animationDelayStyle,
                                            animationDelay: animationDelay,
                                            animationDuration: animationDuration
                                        },
                                        cacheKey && (lookupCache[cacheKey] = data)
                                }
                                return data
                            }

                            function parseMaxTime(str) {
                                var maxValue = 0,
                                    values = angular.isString(str) ? str.split(/\s*,\s*/) : [];
                                return forEach(values,
                                        function (value) {
                                            maxValue = Math.max(parseFloat(value) || 0, maxValue)
                                        }),
                                    maxValue
                            }

                            function getCacheKey(element) {
                                var parentElement = element.parent(),
                                    parentID = parentElement.data(NG_ANIMATE_PARENT_KEY);
                                return parentID || (parentElement.data(NG_ANIMATE_PARENT_KEY, ++parentCounter), parentID = parentCounter),
                                    parentID + "-" + extractElementNode(element).className
                            }

                            function animateSetup(element, className) {
                                var cacheKey = getCacheKey(element),
                                    eventCacheKey = cacheKey + " " + className,
                                    stagger = {},
                                    ii = lookupCache[eventCacheKey] ? ++lookupCache[eventCacheKey].total : 0;
                                if (ii > 0) {
                                    var staggerClassName = className + "-stagger",
                                        staggerCacheKey = cacheKey + " " + staggerClassName,
                                        applyClasses = !lookupCache[staggerCacheKey];
                                    applyClasses && element.addClass(staggerClassName),
                                        stagger = getElementAnimationDetails(element, staggerCacheKey),
                                        applyClasses && element.removeClass(staggerClassName)
                                }
                                element.addClass(className);
                                var timings = getElementAnimationDetails(element, eventCacheKey),
                                    maxDuration = Math.max(timings.transitionDuration, timings.animationDuration);
                                if (0 === maxDuration) return element.removeClass(className), !1;
                                var activeClassName = "";
                                return timings.transitionDuration > 0 ? (element.addClass(NG_ANIMATE_FALLBACK_CLASS_NAME), activeClassName += NG_ANIMATE_FALLBACK_ACTIVE_CLASS_NAME + " ", blockTransitions(element)) : blockKeyframeAnimations(element),
                                    forEach(className.split(" "),
                                        function (klass, i) {
                                            activeClassName += (i > 0 ? " " : "") + klass + "-active"
                                        }),
                                    element.data(NG_ANIMATE_CSS_DATA_KEY, {
                                        className: className,
                                        activeClassName: activeClassName,
                                        maxDuration: maxDuration,
                                        classes: className + " " + activeClassName,
                                        timings: timings,
                                        stagger: stagger,
                                        ii: ii
                                    }), !0
                            }

                            function blockTransitions(element) {
                                extractElementNode(element).style[TRANSITION_PROP + PROPERTY_KEY] = "none"
                            }

                            function blockKeyframeAnimations(element) {
                                extractElementNode(element).style[ANIMATION_PROP] = "none 0s"
                            }

                            function unblockTransitions(element) {
                                var prop = TRANSITION_PROP + PROPERTY_KEY,
                                    node = extractElementNode(element);
                                node.style[prop] && node.style[prop].length > 0 && (node.style[prop] = "")
                            }

                            function unblockKeyframeAnimations(element) {
                                var prop = ANIMATION_PROP,
                                    node = extractElementNode(element);
                                node.style[prop] && node.style[prop].length > 0 && (node.style[prop] = "")
                            }

                            function animateRun(element, className, activeAnimationComplete) {
                                function onAnimationProgress(event) {
                                    event.stopPropagation();
                                    var ev = event.originalEvent || event,
                                        timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now(),
                                        elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
                                    Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration && activeAnimationComplete()
                                }
                                var data = element.data(NG_ANIMATE_CSS_DATA_KEY),
                                    node = extractElementNode(element);
                                if (-1 == node.className.indexOf(className) || !data) return void activeAnimationComplete();
                                var applyFallbackStyle, timings = data.timings,
                                    stagger = data.stagger,
                                    maxDuration = data.maxDuration,
                                    activeClassName = data.activeClassName,
                                    maxDelayTime = 1e3 * Math.max(timings.transitionDelay, timings.animationDelay),
                                    startTime = Date.now(),
                                    css3AnimationEvents = ANIMATIONEND_EVENT + " " + TRANSITIONEND_EVENT,
                                    ii = data.ii,
                                    style = "",
                                    appliedStyles = [];
                                if (timings.transitionDuration > 0) {
                                    var propertyStyle = timings.transitionPropertyStyle;
                                    if (-1 == propertyStyle.indexOf("all")) {
                                        applyFallbackStyle = !0;
                                        var fallbackProperty = $sniffer.msie ? "-ms-zoom" : "border-spacing";
                                        style += CSS_PREFIX + "transition-property: " + propertyStyle + ", " + fallbackProperty + "; ",
                                            style += CSS_PREFIX + "transition-duration: " + timings.transitionDurationStyle + ", " + timings.transitionDuration + "s; ",
                                            appliedStyles.push(CSS_PREFIX + "transition-property"),
                                            appliedStyles.push(CSS_PREFIX + "transition-duration")
                                    }
                                }
                                if (ii > 0) {
                                    if (stagger.transitionDelay > 0 && 0 === stagger.transitionDuration) {
                                        var delayStyle = timings.transitionDelayStyle;
                                        applyFallbackStyle && (delayStyle += ", " + timings.transitionDelay + "s"),
                                            style += CSS_PREFIX + "transition-delay: " + prepareStaggerDelay(delayStyle, stagger.transitionDelay, ii) + "; ",
                                            appliedStyles.push(CSS_PREFIX + "transition-delay")
                                    }
                                    stagger.animationDelay > 0 && 0 === stagger.animationDuration && (style += CSS_PREFIX + "animation-delay: " + prepareStaggerDelay(timings.animationDelayStyle, stagger.animationDelay, ii) + "; ", appliedStyles.push(CSS_PREFIX + "animation-delay"))
                                }
                                if (appliedStyles.length > 0) {
                                    var oldStyle = node.getAttribute("style") || "";
                                    node.setAttribute("style", oldStyle + " " + style)
                                }
                                return element.on(css3AnimationEvents, onAnimationProgress),
                                    element.addClass(activeClassName),
                                    function () {
                                        element.off(css3AnimationEvents, onAnimationProgress),
                                            element.removeClass(activeClassName),
                                            animateClose(element, className);
                                        var node = extractElementNode(element);
                                        for (var i in appliedStyles) node.style.removeProperty(appliedStyles[i])
                                    }
                            }

                            function prepareStaggerDelay(delayStyle, staggerDelay, index) {
                                var style = "";
                                return forEach(delayStyle.split(","),
                                        function (val, i) {
                                            style += (i > 0 ? "," : "") + (index * staggerDelay + parseInt(val, 10)) + "s"
                                        }),
                                    style
                            }

                            function animateBefore(element, className) {
                                return animateSetup(element, className) ?
                                    function (cancelled) {
                                        cancelled && animateClose(element, className)
                                    } : void 0
                            }

                            function animateAfter(element, className, afterAnimationComplete) {
                                return element.data(NG_ANIMATE_CSS_DATA_KEY) ? animateRun(element, className, afterAnimationComplete) : (animateClose(element, className), void afterAnimationComplete())
                            }

                            function animate(element, className, animationComplete) {
                                var preReflowCancellation = animateBefore(element, className);
                                if (!preReflowCancellation) return void animationComplete();
                                var cancel = preReflowCancellation;
                                return afterReflow(function () {
                                        unblockTransitions(element),
                                            unblockKeyframeAnimations(element),
                                            cancel = animateAfter(element, className, animationComplete)
                                    }),
                                    function (cancelled) {
                                        (cancel || noop)(cancelled)
                                    }
                            }

                            function animateClose(element, className) {
                                element.removeClass(className),
                                    element.removeClass(NG_ANIMATE_FALLBACK_CLASS_NAME),
                                    element.removeData(NG_ANIMATE_CSS_DATA_KEY)
                            }

                            function suffixClasses(classes, suffix) {
                                var className = "";
                                return classes = angular.isArray(classes) ? classes : classes.split(/\s+/),
                                    forEach(classes,
                                        function (klass, i) {
                                            klass && klass.length > 0 && (className += (i > 0 ? " " : "") + klass + suffix)
                                        }),
                                    className
                            }
                            var TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT, CSS_PREFIX = "";
                            window.ontransitionend === undefined && window.onwebkittransitionend !== undefined ? (CSS_PREFIX = "-webkit-", TRANSITION_PROP = "WebkitTransition", TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend") : (TRANSITION_PROP = "transition", TRANSITIONEND_EVENT = "transitionend"),
                                window.onanimationend === undefined && window.onwebkitanimationend !== undefined ? (CSS_PREFIX = "-webkit-", ANIMATION_PROP = "WebkitAnimation", ANIMATIONEND_EVENT = "webkitAnimationEnd animationend") : (ANIMATION_PROP = "animation", ANIMATIONEND_EVENT = "animationend");
                            var animationTimer, DURATION_KEY = "Duration",
                                PROPERTY_KEY = "Property",
                                DELAY_KEY = "Delay",
                                ANIMATION_ITERATION_COUNT_KEY = "IterationCount",
                                NG_ANIMATE_PARENT_KEY = "$$ngAnimateKey",
                                NG_ANIMATE_CSS_DATA_KEY = "$$ngAnimateCSS3Data",
                                NG_ANIMATE_FALLBACK_CLASS_NAME = "ng-animate-start",
                                NG_ANIMATE_FALLBACK_ACTIVE_CLASS_NAME = "ng-animate-active",
                                ELAPSED_TIME_MAX_DECIMAL_PLACES = 3,
                                lookupCache = {},
                                parentCounter = 0,
                                animationReflowQueue = [];
                            return {
                                allowCancel: function (element, animationEvent, className) {
                                    var oldClasses = (element.data(NG_ANIMATE_CSS_DATA_KEY) || {}).classes;
                                    if (!oldClasses || ["enter", "leave", "move"].indexOf(animationEvent) >= 0) return !0;
                                    var parentElement = element.parent(),
                                        clone = angular.element(extractElementNode(element).cloneNode());
                                    clone.attr("style", "position:absolute; top:-9999px; left:-9999px"),
                                        clone.removeAttr("id"),
                                        clone.html(""),
                                        forEach(oldClasses.split(" "),
                                            function (klass) {
                                                clone.removeClass(klass)
                                            });
                                    var suffix = "addClass" == animationEvent ? "-add" : "-remove";
                                    clone.addClass(suffixClasses(className, suffix)),
                                        parentElement.append(clone);
                                    var timings = getElementAnimationDetails(clone);
                                    return clone.remove(),
                                        Math.max(timings.transitionDuration, timings.animationDuration) > 0
                                },
                                enter: function (element, animationCompleted) {
                                    return animate(element, "ng-enter", animationCompleted)
                                },
                                leave: function (element, animationCompleted) {
                                    return animate(element, "ng-leave", animationCompleted)
                                },
                                move: function (element, animationCompleted) {
                                    return animate(element, "ng-move", animationCompleted)
                                },
                                beforeAddClass: function (element, className, animationCompleted) {
                                    var cancellationMethod = animateBefore(element, suffixClasses(className, "-add"));
                                    return cancellationMethod ? (afterReflow(function () {
                                        unblockTransitions(element),
                                            unblockKeyframeAnimations(element),
                                            animationCompleted()
                                    }), cancellationMethod) : void animationCompleted()
                                },
                                addClass: function (element, className, animationCompleted) {
                                    return animateAfter(element, suffixClasses(className, "-add"), animationCompleted)
                                },
                                beforeRemoveClass: function (element, className, animationCompleted) {
                                    var cancellationMethod = animateBefore(element, suffixClasses(className, "-remove"));
                                    return cancellationMethod ? (afterReflow(function () {
                                        unblockTransitions(element),
                                            unblockKeyframeAnimations(element),
                                            animationCompleted()
                                    }), cancellationMethod) : void animationCompleted()
                                },
                                removeClass: function (element, className, animationCompleted) {
                                    return animateAfter(element, suffixClasses(className, "-remove"), animationCompleted)
                                }
                            }
                        }
                    ])
            }
        ])
    }(window, window.angular),
    function (window, angular) {
        "use strict";

        function makeMap(str) {
            var i, obj = {},
                items = str.split(",");
            for (i = 0; i < items.length; i++) obj[items[i]] = !0;
            return obj
        }

        function htmlParser(html, handler) {
            function parseStartTag(tag, tagName, rest, unary) {
                if (tagName = angular.lowercase(tagName), blockElements[tagName])
                    for (; stack.last() && inlineElements[stack.last()];) parseEndTag("", stack.last());
                optionalEndTagElements[tagName] && stack.last() == tagName && parseEndTag("", tagName),
                    unary = voidElements[tagName] || !!unary,
                    unary || stack.push(tagName);
                var attrs = {};
                rest.replace(ATTR_REGEXP,
                        function (match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
                            var value = doubleQuotedValue || singleQuotedValue || unquotedValue || "";
                            attrs[name] = decodeEntities(value)
                        }),
                    handler.start && handler.start(tagName, attrs, unary)
            }

            function parseEndTag(tag, tagName) {
                var i, pos = 0;
                if (tagName = angular.lowercase(tagName))
                    for (pos = stack.length - 1; pos >= 0 && stack[pos] != tagName; pos--);
                if (pos >= 0) {
                    for (i = stack.length - 1; i >= pos; i--) handler.end && handler.end(stack[i]);
                    stack.length = pos
                }
            }
            var index, chars, match, stack = [],
                last = html;
            for (stack.last = function () {
                    return stack[stack.length - 1]
                }; html;) {
                if (chars = !0, stack.last() && specialElements[stack.last()]) html = html.replace(new RegExp("(.*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", "i"),
                        function (all, text) {
                            return text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1"),
                                handler.chars && handler.chars(decodeEntities(text)),
                                ""
                        }),
                    parseEndTag("", stack.last());
                else if (0 === html.indexOf("<!--") ? (index = html.indexOf("-->"), index >= 0 && (handler.comment && handler.comment(html.substring(4, index)), html = html.substring(index + 3), chars = !1)) : BEGING_END_TAGE_REGEXP.test(html) ? (match = html.match(END_TAG_REGEXP), match && (html = html.substring(match[0].length), match[0].replace(END_TAG_REGEXP, parseEndTag), chars = !1)) : BEGIN_TAG_REGEXP.test(html) && (match = html.match(START_TAG_REGEXP), match && (html = html.substring(match[0].length), match[0].replace(START_TAG_REGEXP, parseStartTag), chars = !1)), chars) {
                    index = html.indexOf("<");
                    var text = 0 > index ? html : html.substring(0, index);
                    html = 0 > index ? "" : html.substring(index),
                        handler.chars && handler.chars(decodeEntities(text))
                }
                if (html == last) throw "Parse Error: " + html;
                last = html
            }
            parseEndTag()
        }

        function decodeEntities(value) {
            return hiddenPre.innerHTML = value.replace(/</g, "&lt;"),
                hiddenPre.innerText || hiddenPre.textContent || ""
        }

        function encodeEntities(value) {
            return value.replace(/&/g, "&amp;").replace(NON_ALPHANUMERIC_REGEXP,
                function (value) {
                    return "&#" + value.charCodeAt(0) + ";"
                }).replace(/</g, "&lt;").replace(/>/g, "&gt;")
        }

        function htmlSanitizeWriter(buf) {
            var ignore = !1,
                out = angular.bind(buf, buf.push);
            return {
                start: function (tag, attrs, unary) {
                    tag = angular.lowercase(tag), !ignore && specialElements[tag] && (ignore = tag),
                        ignore || 1 != validElements[tag] || (out("<"), out(tag), angular.forEach(attrs,
                            function (value, key) {
                                var lkey = angular.lowercase(key);
                                1 != validAttrs[lkey] || uriAttrs[lkey] === !0 && !value.match(URI_REGEXP) || (out(" "), out(key), out('="'), out(encodeEntities(value)), out('"'))
                            }), out(unary ? "/>" : ">"))
                },
                end: function (tag) {
                    tag = angular.lowercase(tag),
                        ignore || 1 != validElements[tag] || (out("</"), out(tag), out(">")),
                        tag == ignore && (ignore = !1)
                },
                chars: function (chars) {
                    ignore || out(encodeEntities(chars))
                }
            }
        }
        var $sanitize = function (html) {
                var buf = [];
                return htmlParser(html, htmlSanitizeWriter(buf)),
                    buf.join("")
            },
            START_TAG_REGEXP = /^<\s*([\w:-]+)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*>/,
            END_TAG_REGEXP = /^<\s*\/\s*([\w:-]+)[^>]*>/,
            ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,
            BEGIN_TAG_REGEXP = /^</,
            BEGING_END_TAGE_REGEXP = /^<\s*\//,
            COMMENT_REGEXP = /<!--(.*?)-->/g,
            CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g,
            URI_REGEXP = /^((ftp|https?):\/\/|mailto:|#)/i,
            NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g,
            voidElements = makeMap("area,br,col,hr,img,wbr"),
            optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
            optionalEndTagInlineElements = makeMap("rp,rt"),
            optionalEndTagElements = angular.extend({},
                optionalEndTagInlineElements, optionalEndTagBlockElements),
            blockElements = angular.extend({},
                optionalEndTagBlockElements, makeMap("address,article,aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul")),
            inlineElements = angular.extend({},
                optionalEndTagInlineElements, makeMap("a,abbr,acronym,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var")),
            specialElements = makeMap("script,style"),
            validElements = angular.extend({},
                voidElements, blockElements, inlineElements, optionalEndTagElements),
            uriAttrs = makeMap("background,cite,href,longdesc,src,usemap"),
            validAttrs = angular.extend({},
                uriAttrs, makeMap("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,scope,scrolling,shape,span,start,summary,target,title,type,valign,value,vspace,width")),
            hiddenPre = document.createElement("pre");
        angular.module("ngSanitize", []).value("$sanitize", $sanitize),
            angular.module("ngSanitize").directive("ngBindHtml", ["$sanitize",
                function ($sanitize) {
                    return function (scope, element, attr) {
                        element.addClass("ng-binding").data("$binding", attr.ngBindHtml),
                            scope.$watch(attr.ngBindHtml,
                                function (value) {
                                    value = $sanitize(value),
                                        element.html(value || "")
                                })
                    }
                }
            ]),
            angular.module("ngSanitize").filter("linky",
                function () {
                    var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s\.\;\,\(\)\{\}\<\>]/,
                        MAILTO_REGEXP = /^mailto:/;
                    return function (text) {
                        if (!text) return text;
                        for (var match, url, i, raw = text,
                                html = [], writer = htmlSanitizeWriter(html); match = raw.match(LINKY_URL_REGEXP);) url = match[0],
                            match[2] == match[3] && (url = "mailto:" + url),
                            i = match.index,
                            writer.chars(raw.substr(0, i)),
                            writer.start("a", {
                                href: url
                            }),
                            writer.chars(match[0].replace(MAILTO_REGEXP, "")),
                            writer.end("a"),
                            raw = raw.substring(i + match[0].length);
                        return writer.chars(raw),
                            html.join("")
                    }
                })
    }(window, window.angular);
var angularLocalStorage = angular.module("LocalStorageModule", []);
angularLocalStorage.value("prefix", "ls"),
    angularLocalStorage.constant("cookie", {
        expiry: 30,
        path: "/"
    }),
    angularLocalStorage.constant("notify", {
        setItem: !0,
        removeItem: !1
    }),
    angularLocalStorage.service("localStorageService", ["$rootScope", "prefix", "cookie", "notify",
        function ($rootScope, prefix, cookie, notify) {
            "." !== prefix.substr(-1) && (prefix = prefix ? prefix + "." : "");
            var browserSupportsLocalStorage = function () {
                    try {
                        return "localStorage" in window && null !== window.localStorage
                    } catch (e) {
                        return $rootScope.$broadcast("LocalStorageModule.notification.error", e.message), !1
                    }
                },
                addToLocalStorage = function (key, value) {
                    if (!browserSupportsLocalStorage()) return $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED"),
                        notify.setItem && $rootScope.$broadcast("LocalStorageModule.notification.setitem", {
                            key: key,
                            newvalue: value,
                            storageType: "cookie"
                        }),
                        addToCookies(key, value);
                    "undefined" == typeof value && (value = null);
                    try {
                        (angular.isObject(value) || angular.isArray(value)) && (value = angular.toJson(value)),
                        localStorage.setItem(prefix + key, value),
                            notify.setItem && $rootScope.$broadcast("LocalStorageModule.notification.setitem", {
                                key: key,
                                newvalue: value,
                                storageType: "localStorage"
                            })
                    } catch (e) {
                        return $rootScope.$broadcast("LocalStorageModule.notification.error", e.message),
                            addToCookies(key, value)
                    }
                    return !0
                },
                getFromLocalStorage = function (key) {
                    if (!browserSupportsLocalStorage()) return $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED"),
                        getFromCookies(key);
                    var item = localStorage.getItem(prefix + key);
                    return item ? "{" === item.charAt(0) || "[" === item.charAt(0) ? angular.fromJson(item) : item : null
                },
                removeFromLocalStorage = function (key) {
                    if (!browserSupportsLocalStorage()) return $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED"),
                        notify.removeItem && $rootScope.$broadcast("LocalStorageModule.notification.removeitem", {
                            key: key,
                            storageType: "cookie"
                        }),
                        removeFromCookies(key);
                    try {
                        localStorage.removeItem(prefix + key),
                            notify.removeItem && $rootScope.$broadcast("LocalStorageModule.notification.removeitem", {
                                key: key,
                                storageType: "localStorage"
                            })
                    } catch (e) {
                        return $rootScope.$broadcast("LocalStorageModule.notification.error", e.message),
                            removeFromCookies(key)
                    }
                    return !0
                },
                getKeysForLocalStorage = function () {
                    if (!browserSupportsLocalStorage()) return $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED"), !1;
                    var prefixLength = prefix.length,
                        keys = [];
                    for (var key in localStorage)
                        if (key.substr(0, prefixLength) === prefix) try {
                            keys.push(key.substr(prefixLength))
                        } catch (e) {
                            return $rootScope.$broadcast("LocalStorageModule.notification.error", e.Description), []
                        }
                    return keys
                },
                clearAllFromLocalStorage = function () {
                    if (!browserSupportsLocalStorage()) return $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED"),
                        clearAllFromCookies();
                    var prefixLength = prefix.length;
                    for (var key in localStorage)
                        if (key.substr(0, prefixLength) === prefix) try {
                            removeFromLocalStorage(key.substr(prefixLength))
                        } catch (e) {
                            return $rootScope.$broadcast("LocalStorageModule.notification.error", e.message),
                                clearAllFromCookies()
                        }
                    return !0
                },
                browserSupportsCookies = function () {
                    try {
                        return navigator.cookieEnabled || "cookie" in document && (document.cookie.length > 0 || (document.cookie = "test").indexOf.call(document.cookie, "test") > -1)
                    } catch (e) {
                        return $rootScope.$broadcast("LocalStorageModule.notification.error", e.message), !1
                    }
                },
                addToCookies = function (key, value) {
                    if ("undefined" == typeof value) return !1;
                    if (!browserSupportsCookies()) return $rootScope.$broadcast("LocalStorageModule.notification.error", "COOKIES_NOT_SUPPORTED"), !1;
                    try {
                        var expiry = "",
                            expiryDate = new Date;
                        null === value && (cookie.expiry = -1, value = ""),
                            0 !== cookie.expiry && (expiryDate.setTime(expiryDate.getTime() + 24 * cookie.expiry * 60 * 60 * 1e3), expiry = "; expires=" + expiryDate.toGMTString()),
                            key && (document.cookie = prefix + key + "=" + encodeURIComponent(value) + expiry + "; path=" + cookie.path)
                    } catch (e) {
                        return $rootScope.$broadcast("LocalStorageModule.notification.error", e.message), !1
                    }
                    return !0
                },
                getFromCookies = function (key) {
                    if (!browserSupportsCookies()) return $rootScope.$broadcast("LocalStorageModule.notification.error", "COOKIES_NOT_SUPPORTED"), !1;
                    for (var cookies = document.cookie.split(";"), i = 0; i < cookies.length; i++) {
                        for (var thisCookie = cookies[i];
                            " " == thisCookie.charAt(0);) thisCookie = thisCookie.substring(1, thisCookie.length);
                        if (0 === thisCookie.indexOf(prefix + key + "=")) return decodeURIComponent(thisCookie.substring(prefix.length + key.length + 1, thisCookie.length))
                    }
                    return null
                },
                removeFromCookies = function (key) {
                    addToCookies(key, null)
                },
                clearAllFromCookies = function () {
                    for (var thisCookie = null,
                            prefixLength = prefix.length,
                            cookies = document.cookie.split(";"), i = 0; i < cookies.length; i++) {
                        for (thisCookie = cookies[i];
                            " " == thisCookie.charAt(0);) thisCookie = thisCookie.substring(1, thisCookie.length);
                        key = thisCookie.substring(prefixLength, thisCookie.indexOf("=")),
                            removeFromCookies(key)
                    }
                };
            return {
                isSupported: browserSupportsLocalStorage,
                set: addToLocalStorage,
                add: addToLocalStorage,
                get: getFromLocalStorage,
                keys: getKeysForLocalStorage,
                remove: removeFromLocalStorage,
                clearAll: clearAllFromLocalStorage,
                cookie: {
                    set: addToCookies,
                    add: addToCookies,
                    get: getFromCookies,
                    remove: removeFromCookies,
                    clearAll: clearAllFromCookies
                }
            }
        }
    ]),
    angular.module("ui.bootstrap.transition", []).factory("$transition", ["$q", "$timeout", "$rootScope",
        function ($q, $timeout, $rootScope) {
            function findEndEventName(endEventNames) {
                for (var name in endEventNames)
                    if (void 0 !== transElement.style[name]) return endEventNames[name]
            }
            var $transition = function (element, trigger, options) {
                    options = options || {};
                    var deferred = $q.defer(),
                        endEventName = $transition[options.animation ? "animationEndEventName" : "transitionEndEventName"],
                        transitionEndHandler = function () {
                            $rootScope.$apply(function () {
                                element.unbind(endEventName, transitionEndHandler),
                                    deferred.resolve(element)
                            })
                        };
                    return endEventName && element.bind(endEventName, transitionEndHandler),
                        $timeout(function () {
                            angular.isString(trigger) ? element.addClass(trigger) : angular.isFunction(trigger) ? trigger(element) : angular.isObject(trigger) && element.css(trigger),
                                endEventName || deferred.resolve(element)
                        }),
                        deferred.promise.cancel = function () {
                            endEventName && element.unbind(endEventName, transitionEndHandler),
                                deferred.reject("Transition cancelled")
                        },
                        deferred.promise
                },
                transElement = document.createElement("trans"),
                transitionEndEventNames = {
                    WebkitTransition: "webkitTransitionEnd",
                    MozTransition: "transitionend",
                    OTransition: "oTransitionEnd",
                    transition: "transitionend"
                },
                animationEndEventNames = {
                    WebkitTransition: "webkitAnimationEnd",
                    MozTransition: "animationend",
                    OTransition: "oAnimationEnd",
                    transition: "animationend"
                };
            return $transition.transitionEndEventName = findEndEventName(transitionEndEventNames),
                $transition.animationEndEventName = findEndEventName(animationEndEventNames),
                $transition
        }
    ]);
var dialogModule = angular.module("ui.bootstrap.dialog", ["ui.bootstrap.transition"]);
if (dialogModule.controller("MessageBoxController", ["$scope", "dialog", "model",
        function ($scope, dialog, model) {
            $scope.title = model.title,
                $scope.message = model.message,
                $scope.buttons = model.buttons,
                $scope.close = function (res) {
                    dialog.close(res)
                }
        }
    ]), dialogModule.provider("$dialog",
        function () {
            var defaults = {
                    backdrop: !0,
                    dialogClass: "modal",
                    backdropClass: "modal-backdrop",
                    transitionClass: "fade",
                    triggerClass: "in",
                    resolve: {},
                    backdropFade: !1,
                    dialogFade: !1,
                    keyboard: !0,
                    backdropClick: !0
                },
                globalOptions = {},
                activeBackdrops = {
                    value: 0
                };
            this.options = function (value) {
                    globalOptions = value
                },
                this.$get = ["$http", "$document", "$compile", "$rootScope", "$controller", "$templateCache", "$q", "$transition", "$injector",
                    function ($http, $document, $compile, $rootScope, $controller, $templateCache, $q, $transition, $injector) {
                        function createElement(clazz) {
                            var el = angular.element("<div>");
                            return el.addClass(clazz),
                                el
                        }

                        function Dialog(opts) {
                            var self = this,
                                options = this.options = angular.extend({},
                                    defaults, globalOptions, opts);
                            this._open = !1,
                                this.backdropEl = createElement(options.backdropClass),
                                options.backdropFade && (this.backdropEl.addClass(options.transitionClass), this.backdropEl.removeClass(options.triggerClass)),
                                this.modalEl = createElement(options.dialogClass),
                                options.dialogFade && (this.modalEl.addClass(options.transitionClass), this.modalEl.removeClass(options.triggerClass)),
                                this.handledEscapeKey = function (e) {
                                    27 === e.which && (self.close(), e.preventDefault(), self.$scope.$apply())
                                },
                                this.handleBackDropClick = function (e) {
                                    self.close(),
                                        e.preventDefault(),
                                        self.$scope.$apply()
                                }
                        }
                        var body = $document.find("body");
                        return Dialog.prototype.isOpen = function () {
                                return this._open
                            },
                            Dialog.prototype.open = function (templateUrl, controller) {
                                var self = this,
                                    options = this.options;
                                if (templateUrl && (options.templateUrl = templateUrl), controller && (options.controller = controller), !options.template && !options.templateUrl) throw new Error("Dialog.open expected template or templateUrl, neither found. Use options or open method to specify them.");
                                return this._loadResolves().then(function (locals) {
                                        var $scope = locals.$scope = self.$scope = locals.$scope ? locals.$scope : $rootScope.$new();
                                        if (self.modalEl.html(locals.$template), self.options.controller) {
                                            var ctrl = $controller(self.options.controller, locals);
                                            self.modalEl.children().data("ngControllerController", ctrl)
                                        }
                                        $compile(self.modalEl)($scope),
                                            self._addElementsToDom(),
                                            setTimeout(function () {
                                                self.options.dialogFade && self.modalEl.addClass(self.options.triggerClass),
                                                    self.options.backdropFade && self.backdropEl.addClass(self.options.triggerClass)
                                            }),
                                            self._bindEvents()
                                    }),
                                    this.deferred = $q.defer(),
                                    this.deferred.promise
                            },
                            Dialog.prototype.close = function (result) {
                                function removeTriggerClass(el) {
                                    el.removeClass(self.options.triggerClass)
                                }

                                function onCloseComplete() {
                                    self._open && self._onCloseComplete(result)
                                }
                                var self = this,
                                    fadingElements = this._getFadingElements();
                                if (fadingElements.length > 0)
                                    for (var i = fadingElements.length - 1; i >= 0; i--) $transition(fadingElements[i], removeTriggerClass).then(onCloseComplete);
                                else this._onCloseComplete(result)
                            },
                            Dialog.prototype._getFadingElements = function () {
                                var elements = [];
                                return this.options.dialogFade && elements.push(this.modalEl),
                                    this.options.backdropFade && elements.push(this.backdropEl),
                                    elements
                            },
                            Dialog.prototype._bindEvents = function () {
                                this.options.keyboard && body.bind("keydown", this.handledEscapeKey),
                                    this.options.backdrop && this.options.backdropClick && this.backdropEl.bind("click", this.handleBackDropClick)
                            },
                            Dialog.prototype._unbindEvents = function () {
                                this.options.keyboard && body.unbind("keydown", this.handledEscapeKey),
                                    this.options.backdrop && this.options.backdropClick && this.backdropEl.unbind("click", this.handleBackDropClick)
                            },
                            Dialog.prototype._onCloseComplete = function (result) {
                                this._removeElementsFromDom(),
                                    this._unbindEvents(),
                                    this.deferred.resolve(result)
                            },
                            Dialog.prototype._addElementsToDom = function () {
                                body.append(this.modalEl),
                                    this.options.backdrop && (0 === activeBackdrops.value && body.append(this.backdropEl), activeBackdrops.value++),
                                    this._open = !0
                            },
                            Dialog.prototype._removeElementsFromDom = function () {
                                this.modalEl.remove(),
                                    this.options.backdrop && (activeBackdrops.value--, 0 === activeBackdrops.value && this.backdropEl.remove()),
                                    this._open = !1
                            },
                            Dialog.prototype._loadResolves = function () {
                                var templatePromise, values = [],
                                    keys = [],
                                    self = this;
                                return this.options.template ? templatePromise = $q.when(this.options.template) : this.options.templateUrl && (templatePromise = $http.get(this.options.templateUrl, {
                                        cache: $templateCache
                                    }).then(function (response) {
                                        return response.data
                                    })),
                                    angular.forEach(this.options.resolve || [],
                                        function (value, key) {
                                            keys.push(key),
                                                values.push(angular.isString(value) ? $injector.get(value) : $injector.invoke(value))
                                        }),
                                    keys.push("$template"),
                                    values.push(templatePromise),
                                    $q.all(values).then(function (values) {
                                        var locals = {};
                                        return angular.forEach(values,
                                                function (value, index) {
                                                    locals[keys[index]] = value
                                                }),
                                            locals.dialog = self,
                                            locals
                                    })
                            }, {
                                dialog: function (opts) {
                                    return new Dialog(opts)
                                },
                                messageBox: function (title, message, buttons) {
                                    return new Dialog({
                                        templateUrl: "template/dialog/message.html",
                                        controller: "MessageBoxController",
                                        resolve: {
                                            model: function () {
                                                return {
                                                    title: title,
                                                    message: message,
                                                    buttons: buttons
                                                }
                                            }
                                        }
                                    })
                                }
                            }
                    }
                ]
        }), angular.module("ui.bootstrap.dropdownToggle", []).directive("dropdownToggle", ["$document", "$location",
        function ($document) {
            var openElement = null,
                closeMenu = angular.noop;
            return {
                restrict: "CA",
                link: function (scope, element) {
                    scope.$watch("$location.path",
                            function () {
                                closeMenu()
                            }),
                        element.parent().bind("click",
                            function () {
                                closeMenu()
                            }),
                        element.bind("click",
                            function (event) {
                                var elementWasOpen = element === openElement;
                                event.preventDefault(),
                                    event.stopPropagation(),
                                    openElement && closeMenu(),
                                    elementWasOpen || (element.parent().addClass("open"), openElement = element, closeMenu = function (event) {
                                            event && (event.preventDefault(), event.stopPropagation()),
                                                $document.unbind("click", closeMenu),
                                                element.parent().removeClass("open"),
                                                closeMenu = angular.noop,
                                                openElement = null
                                        },
                                        $document.bind("click", closeMenu))
                            })
                }
            }
        }
    ]), angular.module("ui.bootstrap.tooltip", ["ui.bootstrap.position"]).provider("$tooltip",
        function () {
            function snake_case(name) {
                var regexp = /[A-Z]/g,
                    separator = "-";
                return name.replace(regexp,
                    function (letter, pos) {
                        return (pos ? separator : "") + letter.toLowerCase()
                    })
            }
            var defaultOptions = {
                    placement: "top",
                    animation: !0,
                    popupDelay: 0
                },
                triggerMap = {
                    mouseenter: "mouseleave",
                    click: "click",
                    focus: "blur"
                },
                globalOptions = {};
            this.options = function (value) {
                    angular.extend(globalOptions, value)
                },
                this.setTriggers = function (triggers) {
                    angular.extend(triggerMap, triggers)
                },
                this.$get = ["$window", "$compile", "$timeout", "$parse", "$document", "$position", "$interpolate",
                    function ($window, $compile, $timeout, $parse, $document, $position, $interpolate) {
                        return function (type, prefix, defaultTriggerShow) {
                            function getTriggers(trigger) {
                                var show = trigger || options.trigger || defaultTriggerShow,
                                    hide = triggerMap[show] || show;
                                return {
                                    show: show,
                                    hide: hide
                                }
                            }
                            var options = angular.extend({},
                                    defaultOptions, globalOptions),
                                directiveName = snake_case(type),
                                startSym = $interpolate.startSymbol(),
                                endSym = $interpolate.endSymbol(),
                                template = "<" + directiveName + '-popup title="' + startSym + "tt_title" + endSym + '" content="' + startSym + "tt_content" + endSym + '" placement="' + startSym + "tt_placement" + endSym + '" animation="tt_animation()" is-open="tt_isOpen"></' + directiveName + "-popup>";
                            return {
                                restrict: "EA",
                                scope: !0,
                                link: function (scope, element, attrs) {
                                    function toggleTooltipBind() {
                                        scope.tt_isOpen ? hideTooltipBind() : showTooltipBind()
                                    }

                                    function showTooltipBind() {
                                        scope.tt_popupDelay ? popupTimeout = $timeout(show, scope.tt_popupDelay) : scope.$apply(show)
                                    }

                                    function hideTooltipBind() {
                                        scope.$apply(function () {
                                            hide()
                                        })
                                    }

                                    function show() {
                                        var position, ttWidth, ttHeight, ttPosition;
                                        if (scope.tt_content) {
                                            switch (transitionTimeout && $timeout.cancel(transitionTimeout), tooltip.css({
                                                top: 0,
                                                left: 0,
                                                display: "block"
                                            }), appendToBody ? ($body = $body || $document.find("body"), $body.append(tooltip)) : element.after(tooltip), position = appendToBody ? $position.offset(element) : $position.position(element), ttWidth = tooltip.prop("offsetWidth"), ttHeight = tooltip.prop("offsetHeight"), scope.tt_placement) {
                                                case "mouse":
                                                    var mousePos = $position.mouse();
                                                    ttPosition = {
                                                        top: mousePos.y,
                                                        left: mousePos.x
                                                    };
                                                    break;
                                                case "right":
                                                    ttPosition = {
                                                        top: position.top + position.height / 2 - ttHeight / 2,
                                                        left: position.left + position.width
                                                    };
                                                    break;
                                                case "bottom":
                                                    ttPosition = {
                                                        top: position.top + position.height,
                                                        left: position.left + position.width / 2 - ttWidth / 2
                                                    };
                                                    break;
                                                case "left":
                                                    ttPosition = {
                                                        top: position.top + position.height / 2 - ttHeight / 2,
                                                        left: position.left - ttWidth
                                                    };
                                                    break;
                                                default:
                                                    ttPosition = {
                                                        top: position.top - ttHeight,
                                                        left: position.left + position.width / 2 - ttWidth / 2
                                                    }
                                            }
                                            ttPosition.top += "px",
                                                ttPosition.left += "px",
                                                tooltip.css(ttPosition),
                                                scope.tt_isOpen = !0
                                        }
                                    }

                                    function hide() {
                                        scope.tt_isOpen = !1,
                                            $timeout.cancel(popupTimeout),
                                            angular.isDefined(scope.tt_animation) && scope.tt_animation() ? transitionTimeout = $timeout(function () {
                                                    tooltip.remove()
                                                },
                                                500) : tooltip.remove()
                                    }
                                    var transitionTimeout, popupTimeout, $body, tooltip = $compile(template)(scope),
                                        appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : !1,
                                        triggers = getTriggers(void 0),
                                        hasRegisteredTriggers = !1;
                                    scope.tt_isOpen = !1,
                                        attrs.$observe(type,
                                            function (val) {
                                                scope.tt_content = val
                                            }),
                                        attrs.$observe(prefix + "Title",
                                            function (val) {
                                                scope.tt_title = val
                                            }),
                                        attrs.$observe(prefix + "Placement",
                                            function (val) {
                                                scope.tt_placement = angular.isDefined(val) ? val : options.placement
                                            }),
                                        attrs.$observe(prefix + "Animation",
                                            function (val) {
                                                scope.tt_animation = angular.isDefined(val) ? $parse(val) : function () {
                                                    return options.animation
                                                }
                                            }),
                                        attrs.$observe(prefix + "PopupDelay",
                                            function (val) {
                                                var delay = parseInt(val, 10);
                                                scope.tt_popupDelay = isNaN(delay) ? options.popupDelay : delay
                                            }),
                                        attrs.$observe(prefix + "Trigger",
                                            function (val) {
                                                hasRegisteredTriggers && (element.unbind(triggers.show, showTooltipBind), element.unbind(triggers.hide, hideTooltipBind)),
                                                    triggers = getTriggers(val),
                                                    triggers.show === triggers.hide ? element.bind(triggers.show, toggleTooltipBind) : (element.bind(triggers.show, showTooltipBind), element.bind(triggers.hide, hideTooltipBind)),
                                                    hasRegisteredTriggers = !0
                                            }),
                                        attrs.$observe(prefix + "AppendToBody",
                                            function (val) {
                                                appendToBody = angular.isDefined(val) ? $parse(val)(scope) : appendToBody
                                            }),
                                        appendToBody && scope.$on("$locationChangeSuccess",
                                            function () {
                                                scope.tt_isOpen && hide()
                                            }),
                                        scope.$on("$destroy",
                                            function () {
                                                scope.tt_isOpen ? hide() : tooltip.remove()
                                            })
                                }
                            }
                        }
                    }
                ]
        }).directive("tooltipPopup",
        function () {
            return {
                restrict: "E",
                replace: !0,
                scope: {
                    content: "@",
                    placement: "@",
                    animation: "&",
                    isOpen: "&"
                },
                templateUrl: "template/tooltip/tooltip-popup.html"
            }
        }).directive("tooltip", ["$tooltip",
        function ($tooltip) {
            return $tooltip("tooltip", "tooltip", "mouseenter")
        }
    ]).directive("tooltipHtmlUnsafePopup",
        function () {
            return {
                restrict: "E",
                replace: !0,
                scope: {
                    content: "@",
                    placement: "@",
                    animation: "&",
                    isOpen: "&"
                },
                templateUrl: "template/tooltip/tooltip-html-unsafe-popup.html"
            }
        }).directive("tooltipHtmlUnsafe", ["$tooltip",
        function ($tooltip) {
            return $tooltip("tooltipHtmlUnsafe", "tooltip", "mouseenter")
        }
    ]), angular.module("ui.bootstrap.popover", ["ui.bootstrap.tooltip"]).directive("popoverPopup",
        function () {
            return {
                restrict: "EA",
                replace: !0,
                scope: {
                    title: "@",
                    content: "@",
                    placement: "@",
                    animation: "&",
                    isOpen: "&"
                },
                templateUrl: "template/popover/popover.html"
            }
        }).directive("popover", ["$compile", "$timeout", "$parse", "$window", "$tooltip",
        function ($compile, $timeout, $parse, $window, $tooltip) {
            return $tooltip("popover", "popover", "click")
        }
    ]), angular.module("ui.bootstrap.position", []).factory("$position", ["$document", "$window",
        function ($document, $window) {
            function getStyle(el, cssprop) {
                return el.currentStyle ? el.currentStyle[cssprop] : $window.getComputedStyle ? $window.getComputedStyle(el)[cssprop] : el.style[cssprop]
            }

            function isStaticPositioned(element) {
                return "static" === (getStyle(element, "position") || "static")
            }
            var mouseX, mouseY;
            $document.bind("mousemove",
                function (event) {
                    mouseX = event.pageX,
                        mouseY = event.pageY
                });
            var parentOffsetEl = function (element) {
                for (var docDomEl = $document[0], offsetParent = element.offsetParent || docDomEl; offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent);) offsetParent = offsetParent.offsetParent;
                return offsetParent || docDomEl
            };
            return {
                position: function (element) {
                    var elBCR = this.offset(element),
                        offsetParentBCR = {
                            top: 0,
                            left: 0
                        },
                        offsetParentEl = parentOffsetEl(element[0]);
                    return offsetParentEl != $document[0] && (offsetParentBCR = this.offset(angular.element(offsetParentEl)), offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop, offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft), {
                        width: element.prop("offsetWidth"),
                        height: element.prop("offsetHeight"),
                        top: elBCR.top - offsetParentBCR.top,
                        left: elBCR.left - offsetParentBCR.left
                    }
                },
                offset: function (element) {
                    var boundingClientRect = element[0].getBoundingClientRect();
                    return {
                        width: element.prop("offsetWidth"),
                        height: element.prop("offsetHeight"),
                        top: boundingClientRect.top + ($window.pageYOffset || $document[0].body.scrollTop),
                        left: boundingClientRect.left + ($window.pageXOffset || $document[0].body.scrollLeft)
                    }
                },
                mouse: function () {
                    return {
                        x: mouseX,
                        y: mouseY
                    }
                }
            }
        }
    ]), angular.module("ui.bootstrap.tabs", []).directive("tabs",
        function () {
            return function () {
                throw new Error("The `tabs` directive is deprecated, please migrate to `tabset`. Instructions can be found at http://github.com/angular-ui/bootstrap/tree/master/CHANGELOG.md")
            }
        }).controller("TabsetController", ["$scope", "$element",
        function ($scope) {
            var ctrl = this,
                tabs = ctrl.tabs = $scope.tabs = [];
            ctrl.select = function (tab) {
                    angular.forEach(tabs,
                            function (tab) {
                                tab.active = !1
                            }),
                        tab.active = !0
                },
                ctrl.addTab = function (tab) {
                    tabs.push(tab),
                        (1 === tabs.length || tab.active) && ctrl.select(tab)
                },
                ctrl.removeTab = function (tab) {
                    var index = tabs.indexOf(tab);
                    if (tab.active && tabs.length > 1) {
                        var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
                        ctrl.select(tabs[newActiveIndex])
                    }
                    tabs.splice(index, 1)
                }
        }
    ]).directive("tabset",
        function () {
            return {
                restrict: "EA",
                transclude: !0,
                replace: !0,
                require: "^tabset",
                scope: {},
                controller: "TabsetController",
                templateUrl: "template/tabs/tabset.html",
                compile: function (elm, attrs, transclude) {
                    return function (scope, element, attrs, tabsetCtrl) {
                        scope.vertical = angular.isDefined(attrs.vertical) ? scope.$eval(attrs.vertical) : !1,
                            scope.type = angular.isDefined(attrs.type) ? scope.$parent.$eval(attrs.type) : "tabs",
                            scope.direction = angular.isDefined(attrs.direction) ? scope.$parent.$eval(attrs.direction) : "top",
                            scope.tabsAbove = "below" != scope.direction,
                            tabsetCtrl.$scope = scope,
                            tabsetCtrl.$transcludeFn = transclude
                    }
                }
            }
        }).directive("tab", ["$parse", "$http", "$templateCache", "$compile",
        function ($parse) {
            return {
                require: "^tabset",
                restrict: "EA",
                replace: !0,
                templateUrl: "template/tabs/tab.html",
                transclude: !0,
                scope: {
                    heading: "@",
                    onSelect: "&select",
                    onDeselect: "&deselect"
                },
                controller: function () {},
                compile: function (elm, attrs, transclude) {
                    return function (scope, elm, attrs, tabsetCtrl) {
                        var getActive, setActive;
                        attrs.active ? (getActive = $parse(attrs.active), setActive = getActive.assign, scope.$parent.$watch(getActive,
                                function (value) {
                                    scope.active = !!value
                                }), scope.active = getActive(scope.$parent)) : setActive = getActive = angular.noop,
                            scope.$watch("active",
                                function (active) {
                                    setActive(scope.$parent, active),
                                        active ? (tabsetCtrl.select(scope), scope.onSelect()) : scope.onDeselect()
                                }),
                            scope.disabled = !1,
                            attrs.disabled && scope.$parent.$watch($parse(attrs.disabled),
                                function (value) {
                                    scope.disabled = !!value
                                }),
                            scope.select = function () {
                                scope.disabled || (scope.active = !0)
                            },
                            tabsetCtrl.addTab(scope),
                            scope.$on("$destroy",
                                function () {
                                    tabsetCtrl.removeTab(scope)
                                }),
                            scope.active && setActive(scope.$parent, !0),
                            scope.$transcludeFn = transclude
                    }
                }
            }
        }
    ]).directive("tabHeadingTransclude", [function () {
        return {
            restrict: "A",
            require: "^tab",
            link: function (scope, elm) {
                scope.$watch("headingElement",
                    function (heading) {
                        heading && (elm.html(""), elm.append(heading))
                    })
            }
        }
    }]).directive("tabContentTransclude", ["$compile", "$parse",
        function () {
            function isTabHeading(node) {
                return node.tagName && (node.hasAttribute("tab-heading") || node.hasAttribute("data-tab-heading") || "tab-heading" === node.tagName.toLowerCase() || "data-tab-heading" === node.tagName.toLowerCase())
            }
            return {
                restrict: "A",
                require: "^tabset",
                link: function (scope, elm, attrs) {
                    var tab = scope.$eval(attrs.tabContentTransclude);
                    tab.$transcludeFn(tab.$parent,
                        function (contents) {
                            angular.forEach(contents,
                                function (node) {
                                    isTabHeading(node) ? tab.headingElement = node : elm.append(node)
                                })
                        })
                }
            }
        }
    ]).directive("tabsetTitles",
        function () {
            return {
                restrict: "A",
                require: "^tabset",
                templateUrl: "template/tabs/tabset-titles.html",
                replace: !0,
                link: function (scope, elm, attrs, tabsetCtrl) {
                    scope.$eval(attrs.tabsetTitles) ? tabsetCtrl.$transcludeFn(tabsetCtrl.$scope.$parent,
                        function (node) {
                            elm.append(node)
                        }) : elm.remove()
                }
            }
        }), angular.module("ui.bootstrap.carousel", ["ui.bootstrap.transition"]).controller("CarouselController", ["$scope", "$timeout", "$transition", "$q",
        function ($scope, $timeout, $transition) {
            function restartTimer() {
                function go() {
                    isPlaying ? ($scope.next(), restartTimer()) : $scope.pause()
                }
                currentTimeout && $timeout.cancel(currentTimeout);
                var interval = +$scope.interval;
                !isNaN(interval) && interval >= 0 && (currentTimeout = $timeout(go, interval))
            }
            $scope.currentIndex = -1;
            var currentTimeout, isPlaying, self = this,
                slides = self.slides = [];
            self.currentSlide = null,
                self.select = function (nextSlide, direction) {
                    function goNext() {
                        self.currentSlide && angular.isString(direction) && !$scope.noTransition && nextSlide.$element ? (nextSlide.$element.addClass(direction), nextSlide.$element[0].offsetWidth = nextSlide.$element[0].offsetWidth, angular.forEach(slides,
                                    function (slide) {
                                        angular.extend(slide, {
                                            direction: "",
                                            entering: !1,
                                            leaving: !1,
                                            active: !1
                                        })
                                    }), angular.extend(nextSlide, {
                                    direction: direction,
                                    active: !0,
                                    entering: !0
                                }), angular.extend(self.currentSlide || {}, {
                                    direction: direction,
                                    leaving: !0
                                }), $scope.$currentTransition = $transition(nextSlide.$element, {}),
                                function (next, current) {
                                    $scope.$currentTransition.then(function () {
                                            transitionDone(next, current)
                                        },
                                        function () {
                                            transitionDone(next, current)
                                        })
                                }(nextSlide, self.currentSlide)) : transitionDone(nextSlide, self.currentSlide),
                            self.currentSlide = nextSlide,
                            $scope.currentIndex = nextIndex,
                            restartTimer()
                    }

                    function transitionDone(next, current) {
                        angular.extend(next, {
                                direction: "",
                                active: !0,
                                leaving: !1,
                                entering: !1
                            }),
                            angular.extend(current || {}, {
                                direction: "",
                                active: !1,
                                leaving: !1,
                                entering: !1
                            }),
                            $scope.$currentTransition = null
                    }
                    var nextIndex = slides.indexOf(nextSlide);
                    void 0 === direction && (direction = nextIndex > $scope.currentIndex ? "next" : "prev"),
                        nextSlide && nextSlide !== self.currentSlide && ($scope.$currentTransition ? ($scope.$currentTransition.cancel(), $timeout(goNext)) : goNext())
                },
                self.indexOfSlide = function (slide) {
                    return slides.indexOf(slide)
                },
                $scope.next = function () {
                    var newIndex = $scope.currentIndex + 1 < slides.length ? ($scope.currentIndex + 1) % slides.length : $scope.currentIndex;
                    return $scope.$currentTransition ? void 0 : self.select(slides[newIndex], "next")
                },
                $scope.prev = function () {
                    var newIndex = $scope.currentIndex - 1 < 0 ? slides.length - 1 : $scope.currentIndex - 1;
                    return $scope.$currentTransition ? void 0 : self.select(slides[newIndex], "prev")
                },
                $scope.select = function (slide) {
                    self.select(slide)
                },
                $scope.isActive = function (slide) {
                    return self.currentSlide === slide
                },
                $scope.slides = function () {
                    return slides
                },
                $scope.$watch("interval", restartTimer),
                $scope.play = function () {
                    isPlaying || (isPlaying = !0, restartTimer())
                },
                $scope.pause = function () {
                    $scope.noPause || (isPlaying = !1, currentTimeout && $timeout.cancel(currentTimeout))
                },
                self.addSlide = function (slide, element) {
                    slide.$element = element,
                        slides.push(slide),
                        1 === slides.length || slide.active ? (self.select(slides[slides.length - 1]), 1 == slides.length && $scope.play()) : slide.active = !1
                },
                self.removeSlide = function (slide) {
                    var index = slides.indexOf(slide);
                    slides.splice(index, 1),
                        slides.length > 0 && slide.active ? self.select(index >= slides.length ? slides[index - 1] : slides[index]) : $scope.currentIndex > index && $scope.currentIndex--
                }
        }
    ]).directive("carousel", [function () {
        return {
            restrict: "EA",
            transclude: !0,
            replace: !0,
            controller: "CarouselController",
            require: "carousel",
            templateUrl: "views/template/carousel/carousel.html",
            scope: {
                interval: "=",
                noTransition: "=",
                noPause: "="
            }
        }
    }]).directive("slide", ["$parse",
        function ($parse) {
            return {
                require: "^carousel",
                restrict: "EA",
                transclude: !0,
                replace: !0,
                templateUrl: "views/template/carousel/slide.html",
                scope: {},
                link: function (scope, element, attrs, carouselCtrl) {
                    if (attrs.active) {
                        var getActive = $parse(attrs.active),
                            setActive = getActive.assign,
                            lastValue = scope.active = getActive(scope.$parent);
                        scope.$watch(function () {
                            var parentActive = getActive(scope.$parent);
                            return parentActive !== scope.active && (parentActive !== lastValue ? lastValue = scope.active = parentActive : setActive(scope.$parent, parentActive = lastValue = scope.active)),
                                parentActive
                        })
                    }
                    carouselCtrl.addSlide(scope, element),
                        scope.$on("$destroy",
                            function () {
                                carouselCtrl.removeSlide(scope)
                            }),
                        scope.$watch("active",
                            function (active) {
                                active && carouselCtrl.select(scope)
                            })
                }
            }
        }
    ]), angular.module("ui.sortable", []).value("uiSortableConfig", {}).directive("uiSortable", ["uiSortableConfig",
        function (uiSortableConfig) {
            return {
                require: "?ngModel",
                link: function (scope, element, attrs, ngModel) {
                    var onReceive, onRemove, onStart, onUpdate, opts;
                    opts = angular.extend({},
                            uiSortableConfig, scope.$eval(attrs.uiSortable)),
                        ngModel && (ngModel.$render = function () {
                                element.sortable("refresh")
                            },
                            onStart = function (e, ui) {
                                ui.item.sortable = {
                                    index: ui.item.index()
                                }
                            },
                            onUpdate = function (e, ui) {
                                ui.item.sortable.resort = ngModel
                            },
                            onReceive = function (e, ui) {
                                ui.item.sortable.relocate = !0,
                                    ngModel.$modelValue.splice(ui.item.index(), 0, ui.item.sortable.moved)
                            },
                            onRemove = function (e, ui) {
                                ui.item.sortable.moved = 1 === ngModel.$modelValue.length ? ngModel.$modelValue.splice(0, 1)[0] : ngModel.$modelValue.splice(ui.item.sortable.index, 1)[0]
                            },
                            onStop = function (e, ui) {
                                if (ui.item.sortable.resort && !ui.item.sortable.relocate) {
                                    var end, start;
                                    start = ui.item.sortable.index,
                                        end = ui.item.index(),
                                        ui.item.sortable.resort.$modelValue.splice(end, 0, ui.item.sortable.resort.$modelValue.splice(start, 1)[0])
                                }(ui.item.sortable.resort || ui.item.sortable.relocate) && scope.$apply()
                            },
                            opts.start = function (_start) {
                                return function (e, ui) {
                                    onStart(e, ui),
                                        "function" == typeof _start && _start(e, ui)
                                }
                            }(opts.start), opts.stop = function (_stop) {
                                return function (e, ui) {
                                    onStop(e, ui),
                                        "function" == typeof _stop && _stop(e, ui)
                                }
                            }(opts.stop), opts.update = function (_update) {
                                return function (e, ui) {
                                    onUpdate(e, ui),
                                        "function" == typeof _update && _update(e, ui)
                                }
                            }(opts.update), opts.receive = function (_receive) {
                                return function (e, ui) {
                                    onReceive(e, ui),
                                        "function" == typeof _receive && _receive(e, ui)
                                }
                            }(opts.receive), opts.remove = function (_remove) {
                                return function (e, ui) {
                                    onRemove(e, ui),
                                        "function" == typeof _remove && _remove(e, ui)
                                }
                            }(opts.remove)),
                        element.sortable(opts)
                }
            }
        }
    ]), angular.module("angularMoment", []).directive("amTimeAgo", ["$window", "$timeout",
        function ($window, $timeout) {
            "use strict";
            return function (scope, element, attr) {
                function updateTime(momentInstance) {
                    element.text(momentInstance.fromNow());
                    var howOld = $window.moment().diff(momentInstance, "minute"),
                        secondsUntilUpdate = 3600;
                    1 > howOld ? secondsUntilUpdate = 1 : 60 > howOld ? secondsUntilUpdate = 30 : 180 > howOld && (secondsUntilUpdate = 300),
                        activeTimeout = $timeout(function () {
                                updateTime(momentInstance)
                            },
                            1e3 * secondsUntilUpdate, !1)
                }
                var activeTimeout = null;
                scope.$watch(attr.amTimeAgo,
                    function (value) {
                        "undefined" != typeof value && null !== value && (angular.isNumber(value) && (value = new Date(value)), activeTimeout && ($timeout.cancel(activeTimeout), activeTimeout = null), updateTime($window.moment(value)))
                    })
            }
        }
    ]), window.CodeMirror = function () {
        "use strict";

        function CodeMirror(place, options) {
            if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);
            this.options = options = options || {};
            for (var opt in defaults) !options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt) && (options[opt] = defaults[opt]);
            setGuttersForLineNumbers(options);
            var docStart = "string" == typeof options.value ? 0 : options.value.first,
                display = this.display = makeDisplay(place, docStart);
            display.wrapper.CodeMirror = this,
                updateGutters(this),
                options.autofocus && !mobile && focusInput(this),
                this.state = {
                    keyMaps: [],
                    overlays: [],
                    modeGen: 0,
                    overwrite: !1,
                    focused: !1,
                    suppressEdits: !1,
                    pasteIncoming: !1,
                    draggingText: !1,
                    highlight: new Delayed
                },
                themeChanged(this),
                options.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap");
            var doc = options.value;
            "string" == typeof doc && (doc = new Doc(options.value, options.mode)),
                operation(this, attachDoc)(this, doc),
                ie && setTimeout(bind(resetInput, this, !0), 20),
                registerEventHandlers(this);
            var hasFocus;
            try {
                hasFocus = document.activeElement == display.input
            } catch (e) {}
            hasFocus || options.autofocus && !mobile ? setTimeout(bind(onFocus, this), 20) : onBlur(this),
                operation(this,
                    function () {
                        for (var opt in optionHandlers) optionHandlers.propertyIsEnumerable(opt) && optionHandlers[opt](this, options[opt], Init);
                        for (var i = 0; i < initHooks.length; ++i) initHooks[i](this)
                    })()
        }

        function makeDisplay(place, docStart) {
            var d = {},
                input = d.input = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none; font-size: 4px;");
            return webkit ? input.style.width = "1000px" : input.setAttribute("wrap", "off"),
                ios && (input.style.border = "1px solid black"),
                input.setAttribute("autocorrect", "off"),
                input.setAttribute("autocapitalize", "off"),
                input.setAttribute("spellcheck", "false"),
                d.inputDiv = elt("div", [input], null, "overflow: hidden; position: relative; width: 3px; height: 0px;"),
                d.scrollbarH = elt("div", [elt("div", null, null, "height: 1px")], "CodeMirror-hscrollbar"),
                d.scrollbarV = elt("div", [elt("div", null, null, "width: 1px")], "CodeMirror-vscrollbar"),
                d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler"),
                d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler"),
                d.lineDiv = elt("div", null, "CodeMirror-code"),
                d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1"),
                d.cursor = elt("div", " ", "CodeMirror-cursor"),
                d.otherCursor = elt("div", " ", "CodeMirror-cursor CodeMirror-secondarycursor"),
                d.measure = elt("div", null, "CodeMirror-measure"),
                d.lineSpace = elt("div", [d.measure, d.selectionDiv, d.lineDiv, d.cursor, d.otherCursor], null, "position: relative; outline: none"),
                d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative"),
                d.sizer = elt("div", [d.mover], "CodeMirror-sizer"),
                d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerCutOff + "px; width: 1px;"),
                d.gutters = elt("div", null, "CodeMirror-gutters"),
                d.lineGutter = null,
                d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll"),
                d.scroller.setAttribute("tabIndex", "-1"),
                d.wrapper = elt("div", [d.inputDiv, d.scrollbarH, d.scrollbarV, d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror"),
                ie_lt8 && (d.gutters.style.zIndex = -1, d.scroller.style.paddingRight = 0),
                place.appendChild ? place.appendChild(d.wrapper) : place(d.wrapper),
                ios && (input.style.width = "0px"),
                webkit || (d.scroller.draggable = !0),
                khtml ? (d.inputDiv.style.height = "1px", d.inputDiv.style.position = "absolute") : ie_lt8 && (d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = "18px"),
                d.viewOffset = d.lastSizeC = 0,
                d.showingFrom = d.showingTo = docStart,
                d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null,
                d.prevInput = "",
                d.alignWidgets = !1,
                d.pollingFast = !1,
                d.poll = new Delayed,
                d.cachedCharWidth = d.cachedTextHeight = null,
                d.measureLineCache = [],
                d.measureLineCachePos = 0,
                d.inaccurateSelection = !1,
                d.maxLine = null,
                d.maxLineLength = 0,
                d.maxLineChanged = !1,
                d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null,
                d
        }

        function loadMode(cm) {
            cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption),
                cm.doc.iter(function (line) {
                    line.stateAfter && (line.stateAfter = null),
                        line.styles && (line.styles = null)
                }),
                cm.doc.frontier = cm.doc.first,
                startWorker(cm, 100),
                cm.state.modeGen++,
                cm.curOp && regChange(cm)
        }

        function wrappingChanged(cm) {
            cm.options.lineWrapping ? (cm.display.wrapper.className += " CodeMirror-wrap", cm.display.sizer.style.minWidth = "") : (cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-wrap", ""), computeMaxLength(cm)),
                estimateLineHeights(cm),
                regChange(cm),
                clearCaches(cm),
                setTimeout(function () {
                        updateScrollbars(cm)
                    },
                    100)
        }

        function estimateHeight(cm) {
            var th = textHeight(cm.display),
                wrapping = cm.options.lineWrapping,
                perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
            return function (line) {
                return lineIsHidden(cm.doc, line) ? 0 : wrapping ? (Math.ceil(line.text.length / perLine) || 1) * th : th
            }
        }

        function estimateLineHeights(cm) {
            var doc = cm.doc,
                est = estimateHeight(cm);
            doc.iter(function (line) {
                var estHeight = est(line);
                estHeight != line.height && updateLineHeight(line, estHeight)
            })
        }

        function keyMapChanged(cm) {
            var map = keyMap[cm.options.keyMap],
                style = map.style;
            cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, "") + (style ? " cm-keymap-" + style : ""),
                cm.state.disableInput = map.disableInput
        }

        function themeChanged(cm) {
            cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-"),
                clearCaches(cm)
        }

        function guttersChanged(cm) {
            updateGutters(cm),
                regChange(cm),
                setTimeout(function () {
                        alignHorizontally(cm)
                    },
                    20)
        }

        function updateGutters(cm) {
            var gutters = cm.display.gutters,
                specs = cm.options.gutters;
            removeChildren(gutters);
            for (var i = 0; i < specs.length; ++i) {
                var gutterClass = specs[i],
                    gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
                "CodeMirror-linenumbers" == gutterClass && (cm.display.lineGutter = gElt, gElt.style.width = (cm.display.lineNumWidth || 1) + "px")
            }
            gutters.style.display = i ? "" : "none"
        }

        function lineLength(doc, line) {
            if (0 == line.height) return 0;
            for (var merged, len = line.text.length,
                    cur = line; merged = collapsedSpanAtStart(cur);) {
                var found = merged.find();
                cur = getLine(doc, found.from.line),
                    len += found.from.ch - found.to.ch
            }
            for (cur = line; merged = collapsedSpanAtEnd(cur);) {
                var found = merged.find();
                len -= cur.text.length - found.from.ch,
                    cur = getLine(doc, found.to.line),
                    len += cur.text.length - found.to.ch
            }
            return len
        }

        function computeMaxLength(cm) {
            var d = cm.display,
                doc = cm.doc;
            d.maxLine = getLine(doc, doc.first),
                d.maxLineLength = lineLength(doc, d.maxLine),
                d.maxLineChanged = !0,
                doc.iter(function (line) {
                    var len = lineLength(doc, line);
                    len > d.maxLineLength && (d.maxLineLength = len, d.maxLine = line)
                })
        }

        function setGuttersForLineNumbers(options) {
            var found = indexOf(options.gutters, "CodeMirror-linenumbers"); - 1 == found && options.lineNumbers ? options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]) : found > -1 && !options.lineNumbers && (options.gutters = options.gutters.slice(0), options.gutters.splice(found, 1))
        }

        function updateScrollbars(cm) {
            var d = cm.display,
                docHeight = cm.doc.height,
                totalHeight = docHeight + paddingVert(d);
            d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + "px",
                d.gutters.style.height = Math.max(totalHeight, d.scroller.clientHeight - scrollerCutOff) + "px";
            var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight),
                needsH = d.scroller.scrollWidth > d.scroller.clientWidth + 1,
                needsV = scrollHeight > d.scroller.clientHeight + 1;
            needsV ? (d.scrollbarV.style.display = "block", d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + "px" : "0", d.scrollbarV.firstChild.style.height = scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight + "px") : (d.scrollbarV.style.display = "", d.scrollbarV.firstChild.style.height = "0"),
                needsH ? (d.scrollbarH.style.display = "block", d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + "px" : "0", d.scrollbarH.firstChild.style.width = d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth + "px") : (d.scrollbarH.style.display = "", d.scrollbarH.firstChild.style.width = "0"),
                needsH && needsV ? (d.scrollbarFiller.style.display = "block", d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + "px") : d.scrollbarFiller.style.display = "",
                needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter ? (d.gutterFiller.style.display = "block", d.gutterFiller.style.height = scrollbarWidth(d.measure) + "px", d.gutterFiller.style.width = d.gutters.offsetWidth + "px") : d.gutterFiller.style.display = "",
                mac_geLion && 0 === scrollbarWidth(d.measure) && (d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? "18px" : "12px", d.scrollbarV.style.pointerEvents = d.scrollbarH.style.pointerEvents = "none")
        }

        function visibleLines(display, doc, viewPort) {
            var top = display.scroller.scrollTop,
                height = display.wrapper.clientHeight;
            "number" == typeof viewPort ? top = viewPort : viewPort && (top = viewPort.top, height = viewPort.bottom - viewPort.top),
                top = Math.floor(top - paddingTop(display));
            var bottom = Math.ceil(top + height);
            return {
                from: lineAtHeight(doc, top),
                to: lineAtHeight(doc, bottom)
            }
        }

        function alignHorizontally(cm) {
            var display = cm.display;
            if (display.alignWidgets || display.gutters.firstChild && cm.options.fixedGutter) {
                for (var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft, gutterW = display.gutters.offsetWidth, l = comp + "px", n = display.lineDiv.firstChild; n; n = n.nextSibling)
                    if (n.alignable)
                        for (var i = 0,
                                a = n.alignable; i < a.length; ++i) a[i].style.left = l;
                cm.options.fixedGutter && (display.gutters.style.left = comp + gutterW + "px")
            }
        }

        function maybeUpdateLineNumberWidth(cm) {
            if (!cm.options.lineNumbers) return !1;
            var doc = cm.doc,
                last = lineNumberFor(cm.options, doc.first + doc.size - 1),
                display = cm.display;
            if (last.length != display.lineNumChars) {
                var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt")),
                    innerW = test.firstChild.offsetWidth,
                    padding = test.offsetWidth - innerW;
                return display.lineGutter.style.width = "",
                    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding),
                    display.lineNumWidth = display.lineNumInnerWidth + padding,
                    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1,
                    display.lineGutter.style.width = display.lineNumWidth + "px", !0
            }
            return !1
        }

        function lineNumberFor(options, i) {
            return String(options.lineNumberFormatter(i + options.firstLineNumber))
        }

        function compensateForHScroll(display) {
            return getRect(display.scroller).left - getRect(display.sizer).left
        }

        function updateDisplay(cm, changes, viewPort, forced) {
            for (var updated, oldFrom = cm.display.showingFrom,
                    oldTo = cm.display.showingTo,
                    visible = visibleLines(cm.display, cm.doc, viewPort), first = !0;; first = !1) {
                var oldWidth = cm.display.scroller.clientWidth;
                if (!updateDisplayInner(cm, changes, visible, forced)) break;
                if (updated = !0, changes = [], updateSelection(cm), updateScrollbars(cm), first && cm.options.lineWrapping && oldWidth != cm.display.scroller.clientWidth) forced = !0;
                else if (forced = !1, viewPort && (viewPort = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, "number" == typeof viewPort ? viewPort : viewPort.top)), visible = visibleLines(cm.display, cm.doc, viewPort), visible.from >= cm.display.showingFrom && visible.to <= cm.display.showingTo) break
            }
            return updated && (signalLater(cm, "update", cm), (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo) && signalLater(cm, "viewportChange", cm, cm.display.showingFrom, cm.display.showingTo)),
                updated
        }

        function updateDisplayInner(cm, changes, visible, forced) {
            var display = cm.display,
                doc = cm.doc;
            if (!display.wrapper.clientWidth) return display.showingFrom = display.showingTo = doc.first,
                void(display.viewOffset = 0);
            if (!(!forced && 0 == changes.length && visible.from > display.showingFrom && visible.to < display.showingTo)) {
                maybeUpdateLineNumberWidth(cm) && (changes = [{
                    from: doc.first,
                    to: doc.first + doc.size
                }]);
                var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + "px";
                display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : "0";
                var positionsChangedFrom = 1 / 0;
                if (cm.options.lineNumbers)
                    for (var i = 0; i < changes.length; ++i) changes[i].diff && changes[i].from < positionsChangedFrom && (positionsChangedFrom = changes[i].from);
                var end = doc.first + doc.size,
                    from = Math.max(visible.from - cm.options.viewportMargin, doc.first),
                    to = Math.min(end, visible.to + cm.options.viewportMargin);
                if (display.showingFrom < from && from - display.showingFrom < 20 && (from = Math.max(doc.first, display.showingFrom)), display.showingTo > to && display.showingTo - to < 20 && (to = Math.min(end, display.showingTo)), sawCollapsedSpans)
                    for (from = lineNo(visualLine(doc, getLine(doc, from))); end > to && lineIsHidden(doc, getLine(doc, to));) ++to;
                var intact = [{
                    from: Math.max(display.showingFrom, doc.first),
                    to: Math.min(display.showingTo, end)
                }];
                if (intact = intact[0].from >= intact[0].to ? [] : computeIntact(intact, changes), sawCollapsedSpans)
                    for (var i = 0; i < intact.length; ++i)
                        for (var merged, range = intact[i]; merged = collapsedSpanAtEnd(getLine(doc, range.to - 1));) {
                            var newTo = merged.find().from.line;
                            if (!(newTo > range.from)) {
                                intact.splice(i--, 1);
                                break
                            }
                            range.to = newTo
                        }
                for (var intactLines = 0,
                        i = 0; i < intact.length; ++i) {
                    var range = intact[i];
                    range.from < from && (range.from = from),
                        range.to > to && (range.to = to),
                        range.from >= range.to ? intact.splice(i--, 1) : intactLines += range.to - range.from
                }
                if (!forced && intactLines == to - from && from == display.showingFrom && to == display.showingTo) return void updateViewOffset(cm);
                intact.sort(function (a, b) {
                    return a.from - b.from
                });
                try {
                    var focused = document.activeElement
                } catch (e) {}
                .7 * (to - from) > intactLines && (display.lineDiv.style.display = "none"),
                    patchDisplay(cm, from, to, intact, positionsChangedFrom),
                    display.lineDiv.style.display = "",
                    focused && document.activeElement != focused && focused.offsetHeight && focused.focus();
                var different = from != display.showingFrom || to != display.showingTo || display.lastSizeC != display.wrapper.clientHeight;
                return different && (display.lastSizeC = display.wrapper.clientHeight, startWorker(cm, 400)),
                    display.showingFrom = from,
                    display.showingTo = to,
                    updateHeightsInViewport(cm),
                    updateViewOffset(cm), !0
            }
        }

        function updateHeightsInViewport(cm) {
            for (var height, display = cm.display,
                    prevBottom = display.lineDiv.offsetTop,
                    node = display.lineDiv.firstChild; node; node = node.nextSibling)
                if (node.lineObj) {
                    if (ie_lt8) {
                        var bot = node.offsetTop + node.offsetHeight;
                        height = bot - prevBottom,
                            prevBottom = bot
                    } else {
                        var box = getRect(node);
                        height = box.bottom - box.top
                    }
                    var diff = node.lineObj.height - height;
                    if (2 > height && (height = textHeight(display)), diff > .001 || -.001 > diff) {
                        updateLineHeight(node.lineObj, height);
                        var widgets = node.lineObj.widgets;
                        if (widgets)
                            for (var i = 0; i < widgets.length; ++i) widgets[i].height = widgets[i].node.offsetHeight
                    }
                }
        }

        function updateViewOffset(cm) {
            var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom));
            cm.display.mover.style.top = off + "px"
        }

        function computeIntact(intact, changes) {
            for (var i = 0,
                    l = changes.length || 0; l > i; ++i) {
                for (var change = changes[i], intact2 = [], diff = change.diff || 0, j = 0, l2 = intact.length; l2 > j; ++j) {
                    var range = intact[j];
                    change.to <= range.from && change.diff ? intact2.push({
                        from: range.from + diff,
                        to: range.to + diff
                    }) : change.to <= range.from || change.from >= range.to ? intact2.push(range) : (change.from > range.from && intact2.push({
                        from: range.from,
                        to: change.from
                    }), change.to < range.to && intact2.push({
                        from: change.to + diff,
                        to: range.to + diff
                    }))
                }
                intact = intact2
            }
            return intact
        }

        function getDimensions(cm) {
            for (var d = cm.display,
                    left = {},
                    width = {},
                    n = d.gutters.firstChild,
                    i = 0; n; n = n.nextSibling, ++i) left[cm.options.gutters[i]] = n.offsetLeft,
                width[cm.options.gutters[i]] = n.offsetWidth;
            return {
                fixedPos: compensateForHScroll(d),
                gutterTotalWidth: d.gutters.offsetWidth,
                gutterLeft: left,
                gutterWidth: width,
                wrapperWidth: d.wrapper.clientWidth
            }
        }

        function patchDisplay(cm, from, to, intact, updateNumbersFrom) {
            function rm(node) {
                var next = node.nextSibling;
                return webkit && mac && cm.display.currentWheelTarget == node ? (node.style.display = "none", node.lineObj = null) : node.parentNode.removeChild(node),
                    next
            }
            var dims = getDimensions(cm),
                display = cm.display,
                lineNumbers = cm.options.lineNumbers;
            intact.length || webkit && cm.display.currentWheelTarget || removeChildren(display.lineDiv);
            var container = display.lineDiv,
                cur = container.firstChild,
                nextIntact = intact.shift(),
                lineN = from;
            for (cm.doc.iter(from, to,
                    function (line) {
                        if (nextIntact && nextIntact.to == lineN && (nextIntact = intact.shift()), lineIsHidden(cm.doc, line)) {
                            if (0 != line.height && updateLineHeight(line, 0), line.widgets && cur && cur.previousSibling)
                                for (var i = 0; i < line.widgets.length; ++i) {
                                    var w = line.widgets[i];
                                    if (w.showIfHidden) {
                                        var prev = cur.previousSibling;
                                        if (/pre/i.test(prev.nodeName)) {
                                            var wrap = elt("div", null, null, "position: relative");
                                            prev.parentNode.replaceChild(wrap, prev),
                                                wrap.appendChild(prev),
                                                prev = wrap
                                        }
                                        var wnode = prev.appendChild(elt("div", [w.node], "CodeMirror-linewidget"));
                                        w.handleMouseEvents || (wnode.ignoreEvents = !0),
                                            positionLineWidget(w, wnode, prev, dims)
                                    }
                                }
                        } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {
                            for (; cur.lineObj != line;) cur = rm(cur);
                            lineNumbers && lineN >= updateNumbersFrom && cur.lineNumber && setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN)),
                                cur = cur.nextSibling
                        } else {
                            if (line.widgets)
                                for (var reuse, j = 0,
                                        search = cur; search && 20 > j; ++j, search = search.nextSibling)
                                    if (search.lineObj == line && /div/i.test(search.nodeName)) {
                                        reuse = search;
                                        break
                                    }
                            var lineNode = buildLineElement(cm, line, lineN, dims, reuse);
                            if (lineNode != reuse) container.insertBefore(lineNode, cur);
                            else {
                                for (; cur != reuse;) cur = rm(cur);
                                cur = cur.nextSibling
                            }
                            lineNode.lineObj = line
                        }++lineN
                    }); cur;) cur = rm(cur)
        }

        function buildLineElement(cm, line, lineNo, dims, reuse) {
            var wrap, built = buildLineContent(cm, line),
                lineElement = built.pre,
                markers = line.gutterMarkers,
                display = cm.display,
                bgClass = built.bgClass ? built.bgClass + " " + (line.bgClass || "") : line.bgClass;
            if (!(cm.options.lineNumbers || markers || bgClass || line.wrapClass || line.widgets)) return lineElement;
            if (reuse) {
                reuse.alignable = null;
                for (var next, isOk = !0,
                        widgetsSeen = 0,
                        insertBefore = null,
                        n = reuse.firstChild; n; n = next)
                    if (next = n.nextSibling, /\bCodeMirror-linewidget\b/.test(n.className)) {
                        for (var i = 0; i < line.widgets.length; ++i) {
                            var widget = line.widgets[i];
                            if (widget.node == n.firstChild) {
                                widget.above || insertBefore || (insertBefore = n),
                                    positionLineWidget(widget, n, reuse, dims),
                                    ++widgetsSeen;
                                break
                            }
                        }
                        if (i == line.widgets.length) {
                            isOk = !1;
                            break
                        }
                    } else reuse.removeChild(n);
                reuse.insertBefore(lineElement, insertBefore),
                    isOk && widgetsSeen == line.widgets.length && (wrap = reuse, reuse.className = line.wrapClass || "")
            }
            if (wrap || (wrap = elt("div", null, line.wrapClass, "position: relative"), wrap.appendChild(lineElement)), bgClass && wrap.insertBefore(elt("div", null, bgClass + " CodeMirror-linebackground"), wrap.firstChild), cm.options.lineNumbers || markers) {
                var gutterWrap = wrap.insertBefore(elt("div", null, null, "position: absolute; left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"), wrap.firstChild);
                if (cm.options.fixedGutter && (wrap.alignable || (wrap.alignable = [])).push(gutterWrap), !cm.options.lineNumbers || markers && markers["CodeMirror-linenumbers"] || (wrap.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineNo), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + display.lineNumInnerWidth + "px"))), markers)
                    for (var k = 0; k < cm.options.gutters.length; ++k) {
                        var id = cm.options.gutters[k],
                            found = markers.hasOwnProperty(id) && markers[id];
                        found && gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"))
                    }
            }
            if (ie_lt8 && (wrap.style.zIndex = 2), line.widgets && wrap != reuse)
                for (var i = 0,
                        ws = line.widgets; i < ws.length; ++i) {
                    var widget = ws[i],
                        node = elt("div", [widget.node], "CodeMirror-linewidget");
                    widget.handleMouseEvents || (node.ignoreEvents = !0),
                        positionLineWidget(widget, node, wrap, dims),
                        widget.above ? wrap.insertBefore(node, cm.options.lineNumbers && 0 != line.height ? gutterWrap : lineElement) : wrap.appendChild(node),
                        signalLater(widget, "redraw")
                }
            return wrap
        }

        function positionLineWidget(widget, node, wrap, dims) {
            if (widget.noHScroll) {
                (wrap.alignable || (wrap.alignable = [])).push(node);
                var width = dims.wrapperWidth;
                node.style.left = dims.fixedPos + "px",
                    widget.coverGutter || (width -= dims.gutterTotalWidth, node.style.paddingLeft = dims.gutterTotalWidth + "px"),
                    node.style.width = width + "px"
            }
            widget.coverGutter && (node.style.zIndex = 5, node.style.position = "relative", widget.noHScroll || (node.style.marginLeft = -dims.gutterTotalWidth + "px"))
        }

        function updateSelection(cm) {
            var display = cm.display,
                collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);
            if (collapsed || cm.options.showCursorWhenSelecting ? updateSelectionCursor(cm) : display.cursor.style.display = display.otherCursor.style.display = "none", collapsed ? display.selectionDiv.style.display = "none" : updateSelectionRange(cm), cm.options.moveInputWithCursor) {
                var headPos = cursorCoords(cm, cm.doc.sel.head, "div"),
                    wrapOff = getRect(display.wrapper),
                    lineOff = getRect(display.lineDiv);
                display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top)) + "px",
                    display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left)) + "px"
            }
        }

        function updateSelectionCursor(cm) {
            var display = cm.display,
                pos = cursorCoords(cm, cm.doc.sel.head, "div");
            display.cursor.style.left = pos.left + "px",
                display.cursor.style.top = pos.top + "px",
                display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px",
                display.cursor.style.display = "",
                pos.other ? (display.otherCursor.style.display = "", display.otherCursor.style.left = pos.other.left + "px", display.otherCursor.style.top = pos.other.top + "px", display.otherCursor.style.height = .85 * (pos.other.bottom - pos.other.top) + "px") : display.otherCursor.style.display = "none"
        }

        function updateSelectionRange(cm) {
            function add(left, top, width, bottom) {
                0 > top && (top = 0),
                    fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px; top: " + top + "px; width: " + (null == width ? clientWidth - left : width) + "px; height: " + (bottom - top) + "px"))
            }

            function drawForLine(line, fromArg, toArg) {
                function coords(ch, bias) {
                    return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
                }
                var start, end, lineObj = getLine(doc, line),
                    lineLen = lineObj.text.length;
                return iterateBidiSections(getOrder(lineObj), fromArg || 0, null == toArg ? lineLen : toArg,
                    function (from, to, dir) {
                        var rightPos, left, right, leftPos = coords(from, "left");
                        if (from == to) rightPos = leftPos,
                            left = right = leftPos.left;
                        else {
                            if (rightPos = coords(to - 1, "right"), "rtl" == dir) {
                                var tmp = leftPos;
                                leftPos = rightPos,
                                    rightPos = tmp
                            }
                            left = leftPos.left,
                                right = rightPos.right
                        }
                        null == fromArg && 0 == from && (left = pl),
                            rightPos.top - leftPos.top > 3 && (add(left, leftPos.top, null, leftPos.bottom), left = pl, leftPos.bottom < rightPos.top && add(left, leftPos.bottom, null, rightPos.top)),
                            null == toArg && to == lineLen && (right = clientWidth),
                            (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left) && (start = leftPos),
                            (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right) && (end = rightPos),
                            pl + 1 > left && (left = pl),
                            add(left, rightPos.top, right - left, rightPos.bottom)
                    }), {
                    start: start,
                    end: end
                }
            }
            var display = cm.display,
                doc = cm.doc,
                sel = cm.doc.sel,
                fragment = document.createDocumentFragment(),
                clientWidth = display.lineSpace.offsetWidth,
                pl = paddingLeft(cm.display);
            if (sel.from.line == sel.to.line) drawForLine(sel.from.line, sel.from.ch, sel.to.ch);
            else {
                var fromLine = getLine(doc, sel.from.line),
                    toLine = getLine(doc, sel.to.line),
                    singleVLine = visualLine(doc, fromLine) == visualLine(doc, toLine),
                    leftEnd = drawForLine(sel.from.line, sel.from.ch, singleVLine ? fromLine.text.length : null).end,
                    rightStart = drawForLine(sel.to.line, singleVLine ? 0 : null, sel.to.ch).start;
                singleVLine && (leftEnd.top < rightStart.top - 2 ? (add(leftEnd.right, leftEnd.top, null, leftEnd.bottom), add(pl, rightStart.top, rightStart.left, rightStart.bottom)) : add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom)),
                    leftEnd.bottom < rightStart.top && add(pl, leftEnd.bottom, null, rightStart.top)
            }
            removeChildrenAndAdd(display.selectionDiv, fragment),
                display.selectionDiv.style.display = ""
        }

        function restartBlink(cm) {
            if (cm.state.focused) {
                var display = cm.display;
                clearInterval(display.blinker);
                var on = !0;
                display.cursor.style.visibility = display.otherCursor.style.visibility = "",
                    cm.options.cursorBlinkRate > 0 && (display.blinker = setInterval(function () {
                            display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? "" : "hidden"
                        },
                        cm.options.cursorBlinkRate))
            }
        }

        function startWorker(cm, time) {
            cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo && cm.state.highlight.set(time, bind(highlightWorker, cm))
        }

        function highlightWorker(cm) {
            var doc = cm.doc;
            if (doc.frontier < doc.first && (doc.frontier = doc.first), !(doc.frontier >= cm.display.showingTo)) {
                var prevChange, end = +new Date + cm.options.workTime,
                    state = copyState(doc.mode, getStateBefore(cm, doc.frontier)),
                    changed = [];
                doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500),
                        function (line) {
                            if (doc.frontier >= cm.display.showingFrom) {
                                var oldStyles = line.styles;
                                line.styles = highlightLine(cm, line, state);
                                for (var ischange = !oldStyles || oldStyles.length != line.styles.length,
                                        i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
                                ischange && (prevChange && prevChange.end == doc.frontier ? prevChange.end++ : changed.push(prevChange = {
                                        start: doc.frontier,
                                        end: doc.frontier + 1
                                    })),
                                    line.stateAfter = copyState(doc.mode, state)
                            } else processLine(cm, line, state),
                                line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
                            return ++doc.frontier, +new Date > end ? (startWorker(cm, cm.options.workDelay), !0) : void 0
                        }),
                    changed.length && operation(cm,
                        function () {
                            for (var i = 0; i < changed.length; ++i) regChange(this, changed[i].start, changed[i].end)
                        })()
            }
        }

        function findStartLine(cm, n, precise) {
            for (var minindent, minline, doc = cm.doc,
                    lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100), search = n; search > lim; --search) {
                if (search <= doc.first) return doc.first;
                var line = getLine(doc, search - 1);
                if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
                var indented = countColumn(line.text, null, cm.options.tabSize);
                (null == minline || minindent > indented) && (minline = search - 1, minindent = indented)
            }
            return minline
        }

        function getStateBefore(cm, n, precise) {
            var doc = cm.doc,
                display = cm.display;
            if (!doc.mode.startState) return !0;
            var pos = findStartLine(cm, n, precise),
                state = pos > doc.first && getLine(doc, pos - 1).stateAfter;
            return state = state ? copyState(doc.mode, state) : startState(doc.mode),
                doc.iter(pos, n,
                    function (line) {
                        processLine(cm, line, state);
                        var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;
                        line.stateAfter = save ? copyState(doc.mode, state) : null,
                            ++pos
                    }),
                precise && (doc.frontier = pos),
                state
        }

        function paddingTop(display) {
            return display.lineSpace.offsetTop
        }

        function paddingVert(display) {
            return display.mover.offsetHeight - display.lineSpace.offsetHeight
        }

        function paddingLeft(display) {
            var e = removeChildrenAndAdd(display.measure, elt("pre", null, null, "text-align: left")).appendChild(elt("span", "x"));
            return e.offsetLeft
        }

        function measureChar(cm, line, ch, data, bias) {
            var dir = -1;
            if (data = data || measureLine(cm, line), data.crude) {
                var left = data.left + ch * data.width;
                return {
                    left: left,
                    right: left + data.width,
                    top: data.top,
                    bottom: data.bottom
                }
            }
            for (var pos = ch;; pos += dir) {
                var r = data[pos];
                if (r) break;
                0 > dir && 0 == pos && (dir = 1)
            }
            return bias = pos > ch ? "left" : ch > pos ? "right" : bias,
                "left" == bias && r.leftSide ? r = r.leftSide : "right" == bias && r.rightSide && (r = r.rightSide), {
                    left: ch > pos ? r.right : r.left,
                    right: pos > ch ? r.left : r.right,
                    top: r.top,
                    bottom: r.bottom
                }
        }

        function findCachedMeasurement(cm, line) {
            for (var cache = cm.display.measureLineCache,
                    i = 0; i < cache.length; ++i) {
                var memo = cache[i];
                if (memo.text == line.text && memo.markedSpans == line.markedSpans && cm.display.scroller.clientWidth == memo.width && memo.classes == line.textClass + "|" + line.wrapClass) return memo
            }
        }

        function clearCachedMeasurement(cm, line) {
            var exists = findCachedMeasurement(cm, line);
            exists && (exists.text = exists.measure = exists.markedSpans = null)
        }

        function measureLine(cm, line) {
            var cached = findCachedMeasurement(cm, line);
            if (cached) return cached.measure;
            var measure = measureLineInner(cm, line),
                cache = cm.display.measureLineCache,
                memo = {
                    text: line.text,
                    width: cm.display.scroller.clientWidth,
                    markedSpans: line.markedSpans,
                    measure: measure,
                    classes: line.textClass + "|" + line.wrapClass
                };
            return 16 == cache.length ? cache[++cm.display.measureLineCachePos % 16] = memo : cache.push(memo),
                measure
        }

        function measureLineInner(cm, line) {
            function measureRect(rect) {
                var top = rect.top - outer.top,
                    bot = rect.bottom - outer.top;
                bot > maxBot && (bot = maxBot),
                    0 > top && (top = 0);
                for (var i = vranges.length - 2; i >= 0; i -= 2) {
                    var rtop = vranges[i],
                        rbot = vranges[i + 1];
                    if (!(rtop > bot || top > rbot) && (top >= rtop && rbot >= bot || rtop >= top && bot >= rbot || Math.min(bot, rbot) - Math.max(top, rtop) >= bot - top >> 1)) {
                        vranges[i] = Math.min(top, rtop),
                            vranges[i + 1] = Math.max(bot, rbot);
                        break
                    }
                }
                return 0 > i && (i = vranges.length, vranges.push(top, bot)), {
                    left: rect.left - outer.left,
                    right: rect.right - outer.left,
                    top: i,
                    bottom: null
                }
            }

            function finishRect(rect) {
                rect.bottom = vranges[rect.top + 1],
                    rect.top = vranges[rect.top]
            }
            if (!cm.options.lineWrapping && line.text.length >= cm.options.crudeMeasuringFrom) return crudelyMeasureLine(cm, line);
            var display = cm.display,
                measure = emptyArray(line.text.length),
                pre = buildLineContent(cm, line, measure, !0).pre;
            if (ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {
                for (var fragment = document.createDocumentFragment(), chunk = 10, n = pre.childNodes.length, i = 0, chunks = Math.ceil(n / chunk); chunks > i; ++i) {
                    for (var wrap = elt("div", null, null, "display: inline-block"), j = 0; chunk > j && n; ++j) wrap.appendChild(pre.firstChild),
                        --n;
                    fragment.appendChild(wrap)
                }
                pre.appendChild(fragment)
            }
            removeChildrenAndAdd(display.measure, pre);
            var outer = getRect(display.lineDiv),
                vranges = [],
                data = emptyArray(line.text.length),
                maxBot = pre.offsetHeight;
            ie_lt9 && display.measure.first != pre && removeChildrenAndAdd(display.measure, pre);
            for (var cur, i = 0; i < measure.length; ++i)
                if (cur = measure[i]) {
                    var node = cur,
                        rect = null;
                    if (/\bCodeMirror-widget\b/.test(cur.className) && cur.getClientRects) {
                        1 == cur.firstChild.nodeType && (node = cur.firstChild);
                        var rects = node.getClientRects();
                        rects.length > 1 && (rect = data[i] = measureRect(rects[0]), rect.rightSide = measureRect(rects[rects.length - 1]))
                    }
                    rect || (rect = data[i] = measureRect(getRect(node))),
                        cur.measureRight && (rect.right = getRect(cur.measureRight).left),
                        cur.leftSide && (rect.leftSide = measureRect(getRect(cur.leftSide)))
                }
            removeChildren(cm.display.measure);
            for (var cur, i = 0; i < data.length; ++i)(cur = data[i]) && (finishRect(cur), cur.leftSide && finishRect(cur.leftSide), cur.rightSide && finishRect(cur.rightSide));
            return data
        }

        function crudelyMeasureLine(cm, line) {
            var copy = new Line(line.text.slice(0, 100), null);
            line.textClass && (copy.textClass = line.textClass);
            var measure = measureLineInner(cm, copy),
                left = measureChar(cm, copy, 0, measure, "left"),
                right = measureChar(cm, copy, 99, measure, "right");
            return {
                crude: !0,
                top: left.top,
                left: left.left,
                bottom: left.bottom,
                width: (right.right - left.left) / 100
            }
        }

        function measureLineWidth(cm, line) {
            var hasBadSpan = !1;
            if (line.markedSpans)
                for (var i = 0; i < line.markedSpans; ++i) {
                    var sp = line.markedSpans[i];
                    !sp.collapsed || null != sp.to && sp.to != line.text.length || (hasBadSpan = !0)
                }
            var cached = !hasBadSpan && findCachedMeasurement(cm, line);
            if (cached || line.text.length >= cm.options.crudeMeasuringFrom) return measureChar(cm, line, line.text.length, cached && cached.measure, "right").right;
            var pre = buildLineContent(cm, line, null, !0).pre,
                end = pre.appendChild(zeroWidthElement(cm.display.measure));
            return removeChildrenAndAdd(cm.display.measure, pre),
                getRect(end).right - getRect(cm.display.lineDiv).left
        }

        function clearCaches(cm) {
            cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0,
                cm.display.cachedCharWidth = cm.display.cachedTextHeight = null,
                cm.options.lineWrapping || (cm.display.maxLineChanged = !0),
                cm.display.lineNumChars = null
        }

        function pageScrollX() {
            return window.pageXOffset || (document.documentElement || document.body).scrollLeft
        }

        function pageScrollY() {
            return window.pageYOffset || (document.documentElement || document.body).scrollTop
        }

        function intoCoordSystem(cm, lineObj, rect, context) {
            if (lineObj.widgets)
                for (var i = 0; i < lineObj.widgets.length; ++i)
                    if (lineObj.widgets[i].above) {
                        var size = widgetHeight(lineObj.widgets[i]);
                        rect.top += size,
                            rect.bottom += size
                    }
            if ("line" == context) return rect;
            context || (context = "local");
            var yOff = heightAtLine(cm, lineObj);
            if ("local" == context ? yOff += paddingTop(cm.display) : yOff -= cm.display.viewOffset, "page" == context || "window" == context) {
                var lOff = getRect(cm.display.lineSpace);
                yOff += lOff.top + ("window" == context ? 0 : pageScrollY());
                var xOff = lOff.left + ("window" == context ? 0 : pageScrollX());
                rect.left += xOff,
                    rect.right += xOff
            }
            return rect.top += yOff,
                rect.bottom += yOff,
                rect
        }

        function fromCoordSystem(cm, coords, context) {
            if ("div" == context) return coords;
            var left = coords.left,
                top = coords.top;
            if ("page" == context) left -= pageScrollX(),
                top -= pageScrollY();
            else if ("local" == context || !context) {
                var localBox = getRect(cm.display.sizer);
                left += localBox.left,
                    top += localBox.top
            }
            var lineSpaceBox = getRect(cm.display.lineSpace);
            return {
                left: left - lineSpaceBox.left,
                top: top - lineSpaceBox.top
            }
        }

        function charCoords(cm, pos, context, lineObj, bias) {
            return lineObj || (lineObj = getLine(cm.doc, pos.line)),
                intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, null, bias), context)
        }

        function cursorCoords(cm, pos, context, lineObj, measurement) {
            function get(ch, right) {
                var m = measureChar(cm, lineObj, ch, measurement, right ? "right" : "left");
                return right ? m.left = m.right : m.right = m.left,
                    intoCoordSystem(cm, lineObj, m, context)
            }

            function getBidi(ch, partPos) {
                var part = order[partPos],
                    right = part.level % 2;
                return ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level ? (part = order[--partPos], ch = bidiRight(part) - (part.level % 2 ? 0 : 1), right = !0) : ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level && (part = order[++partPos], ch = bidiLeft(part) - part.level % 2, right = !1),
                    right && ch == part.to && ch > part.from ? get(ch - 1) : get(ch, right)
            }
            lineObj = lineObj || getLine(cm.doc, pos.line),
                measurement || (measurement = measureLine(cm, lineObj));
            var order = getOrder(lineObj),
                ch = pos.ch;
            if (!order) return get(ch);
            var partPos = getBidiPartAt(order, ch),
                val = getBidi(ch, partPos);
            return null != bidiOther && (val.other = getBidi(ch, bidiOther)),
                val
        }

        function PosWithInfo(line, ch, outside, xRel) {
            var pos = new Pos(line, ch);
            return pos.xRel = xRel,
                outside && (pos.outside = !0),
                pos
        }

        function coordsChar(cm, x, y) {
            var doc = cm.doc;
            if (y += cm.display.viewOffset, 0 > y) return PosWithInfo(doc.first, 0, !0, -1);
            var lineNo = lineAtHeight(doc, y),
                last = doc.first + doc.size - 1;
            if (lineNo > last) return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, !0, 1);
            for (0 > x && (x = 0);;) {
                var lineObj = getLine(doc, lineNo),
                    found = coordsCharInner(cm, lineObj, lineNo, x, y),
                    merged = collapsedSpanAtEnd(lineObj),
                    mergedPos = merged && merged.find();
                if (!merged || !(found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0)) return found;
                lineNo = mergedPos.to.line
            }
        }

        function coordsCharInner(cm, lineObj, lineNo, x, y) {
            function getX(ch) {
                var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, measurement);
                return wrongLine = !0,
                    innerOff > sp.bottom ? sp.left - adjust : innerOff < sp.top ? sp.left + adjust : (wrongLine = !1, sp.left)
            }
            var innerOff = y - heightAtLine(cm, lineObj),
                wrongLine = !1,
                adjust = 2 * cm.display.wrapper.clientWidth,
                measurement = measureLine(cm, lineObj),
                bidi = getOrder(lineObj),
                dist = lineObj.text.length,
                from = lineLeft(lineObj),
                to = lineRight(lineObj),
                fromX = getX(from),
                fromOutside = wrongLine,
                toX = getX(to),
                toOutside = wrongLine;
            if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
            for (;;) {
                if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : 1 >= to - from) {
                    for (var ch = fromX > x || toX - x >= x - fromX ? from : to, xDiff = x - (ch == from ? fromX : toX); isExtendingChar.test(lineObj.text.charAt(ch));) ++ch;
                    var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside, 0 > xDiff ? -1 : xDiff ? 1 : 0);
                    return pos
                }
                var step = Math.ceil(dist / 2),
                    middle = from + step;
                if (bidi) {
                    middle = from;
                    for (var i = 0; step > i; ++i) middle = moveVisually(lineObj, middle, 1)
                }
                var middleX = getX(middle);
                middleX > x ? (to = middle, toX = middleX, (toOutside = wrongLine) && (toX += 1e3), dist = step) : (from = middle, fromX = middleX, fromOutside = wrongLine, dist -= step)
            }
        }

        function textHeight(display) {
            if (null != display.cachedTextHeight) return display.cachedTextHeight;
            if (null == measureText) {
                measureText = elt("pre");
                for (var i = 0; 49 > i; ++i) measureText.appendChild(document.createTextNode("x")),
                    measureText.appendChild(elt("br"));
                measureText.appendChild(document.createTextNode("x"))
            }
            removeChildrenAndAdd(display.measure, measureText);
            var height = measureText.offsetHeight / 50;
            return height > 3 && (display.cachedTextHeight = height),
                removeChildren(display.measure),
                height || 1
        }

        function charWidth(display) {
            if (null != display.cachedCharWidth) return display.cachedCharWidth;
            var anchor = elt("span", "x"),
                pre = elt("pre", [anchor]);
            removeChildrenAndAdd(display.measure, pre);
            var width = anchor.offsetWidth;
            return width > 2 && (display.cachedCharWidth = width),
                width || 10
        }

        function startOperation(cm) {
            cm.curOp = {
                    changes: [],
                    forceUpdate: !1,
                    updateInput: null,
                    userSelChange: null,
                    textChanged: null,
                    selectionChanged: !1,
                    cursorActivity: !1,
                    updateMaxLine: !1,
                    updateScrollPos: !1,
                    id: ++nextOpId
                },
                delayedCallbackDepth++ || (delayedCallbacks = [])
        }

        function endOperation(cm) {
            var op = cm.curOp,
                doc = cm.doc,
                display = cm.display;
            if (cm.curOp = null, op.updateMaxLine && computeMaxLength(cm), display.maxLineChanged && !cm.options.lineWrapping && display.maxLine) {
                var width = measureLineWidth(cm, display.maxLine);
                display.sizer.style.minWidth = Math.max(0, width + 3 + scrollerCutOff) + "px",
                    display.maxLineChanged = !1;
                var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);
                maxScrollLeft < doc.scrollLeft && !op.updateScrollPos && setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), !0)
            }
            var newScrollPos, updated;
            if (op.updateScrollPos) newScrollPos = op.updateScrollPos;
            else if (op.selectionChanged && display.scroller.clientHeight) {
                var coords = cursorCoords(cm, doc.sel.head);
                newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom)
            }(op.changes.length || op.forceUpdate || newScrollPos && null != newScrollPos.scrollTop) && (updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop, op.forceUpdate), cm.display.scroller.offsetHeight && (cm.doc.scrollTop = cm.display.scroller.scrollTop)), !updated && op.selectionChanged && updateSelection(cm),
                op.updateScrollPos ? (display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = newScrollPos.scrollTop, display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = newScrollPos.scrollLeft, alignHorizontally(cm), op.scrollToPos && scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos.from), clipPos(cm.doc, op.scrollToPos.to), op.scrollToPos.margin)) : newScrollPos && scrollCursorIntoView(cm),
                op.selectionChanged && restartBlink(cm),
                cm.state.focused && op.updateInput && resetInput(cm, op.userSelChange);
            var hidden = op.maybeHiddenMarkers,
                unhidden = op.maybeUnhiddenMarkers;
            if (hidden)
                for (var i = 0; i < hidden.length; ++i) hidden[i].lines.length || signal(hidden[i], "hide");
            if (unhidden)
                for (var i = 0; i < unhidden.length; ++i) unhidden[i].lines.length && signal(unhidden[i], "unhide");
            var delayed;
            if (--delayedCallbackDepth || (delayed = delayedCallbacks, delayedCallbacks = null), op.textChanged && signal(cm, "change", cm, op.textChanged), op.cursorActivity && signal(cm, "cursorActivity", cm), delayed)
                for (var i = 0; i < delayed.length; ++i) delayed[i]()
        }

        function operation(cm1, f) {
            return function () {
                var cm = cm1 || this,
                    withOp = !cm.curOp;
                withOp && startOperation(cm);
                try {
                    var result = f.apply(cm, arguments)
                } finally {
                    withOp && endOperation(cm)
                }
                return result
            }
        }

        function docOperation(f) {
            return function () {
                var result, withOp = this.cm && !this.cm.curOp;
                withOp && startOperation(this.cm);
                try {
                    result = f.apply(this, arguments)
                } finally {
                    withOp && endOperation(this.cm)
                }
                return result
            }
        }

        function runInOp(cm, f) {
            var result, withOp = !cm.curOp;
            withOp && startOperation(cm);
            try {
                result = f()
            } finally {
                withOp && endOperation(cm)
            }
            return result
        }

        function regChange(cm, from, to, lendiff) {
            null == from && (from = cm.doc.first),
                null == to && (to = cm.doc.first + cm.doc.size),
                cm.curOp.changes.push({
                    from: from,
                    to: to,
                    diff: lendiff
                })
        }

        function slowPoll(cm) {
            cm.display.pollingFast || cm.display.poll.set(cm.options.pollInterval,
                function () {
                    readInput(cm),
                        cm.state.focused && slowPoll(cm)
                })
        }

        function fastPoll(cm) {
            function p() {
                var changed = readInput(cm);
                changed || missed ? (cm.display.pollingFast = !1, slowPoll(cm)) : (missed = !0, cm.display.poll.set(60, p))
            }
            var missed = !1;
            cm.display.pollingFast = !0,
                cm.display.poll.set(20, p)
        }

        function readInput(cm) {
            var input = cm.display.input,
                prevInput = cm.display.prevInput,
                doc = cm.doc,
                sel = doc.sel;
            if (!cm.state.focused || hasSelection(input) || isReadOnly(cm) || cm.state.disableInput) return !1;
            cm.state.pasteIncoming && cm.state.fakedLastChar && (input.value = input.value.substring(0, input.value.length - 1), cm.state.fakedLastChar = !1);
            var text = input.value;
            if (text == prevInput && posEq(sel.from, sel.to)) return !1;
            if (ie && !ie_lt9 && cm.display.inputHasSelection === text) return resetInput(cm, !0), !1;
            var withOp = !cm.curOp;
            withOp && startOperation(cm),
                sel.shift = !1;
            for (var same = 0,
                    l = Math.min(prevInput.length, text.length); l > same && prevInput.charCodeAt(same) == text.charCodeAt(same);) ++same;
            var from = sel.from,
                to = sel.to;
            same < prevInput.length ? from = Pos(from.line, from.ch - (prevInput.length - same)) : cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming && (to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + (text.length - same))));
            var updateInput = cm.curOp.updateInput,
                changeEvent = {
                    from: from,
                    to: to,
                    text: splitLines(text.slice(same)),
                    origin: cm.state.pasteIncoming ? "paste" : "+input"
                };
            return makeChange(cm.doc, changeEvent, "end"),
                cm.curOp.updateInput = updateInput,
                signalLater(cm, "inputRead", cm, changeEvent),
                text.length > 1e3 || text.indexOf("\n") > -1 ? input.value = cm.display.prevInput = "" : cm.display.prevInput = text,
                withOp && endOperation(cm),
                cm.state.pasteIncoming = !1, !0
        }

        function resetInput(cm, user) {
            var minimal, selected, doc = cm.doc;
            if (posEq(doc.sel.from, doc.sel.to)) user && (cm.display.prevInput = cm.display.input.value = "", ie && !ie_lt9 && (cm.display.inputHasSelection = null));
            else {
                cm.display.prevInput = "",
                    minimal = hasCopyEvent && (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1e3);
                var content = minimal ? "-" : selected || cm.getSelection();
                cm.display.input.value = content,
                    cm.state.focused && selectInput(cm.display.input),
                    ie && !ie_lt9 && (cm.display.inputHasSelection = content)
            }
            cm.display.inaccurateSelection = minimal
        }

        function focusInput(cm) {
            "nocursor" == cm.options.readOnly || mobile && document.activeElement == cm.display.input || cm.display.input.focus()
        }

        function isReadOnly(cm) {
            return cm.options.readOnly || cm.doc.cantEdit
        }

        function registerEventHandlers(cm) {
            function reFocus() {
                cm.state.focused && setTimeout(bind(focusInput, cm), 0)
            }

            function onResize() {
                null == resizeTimer && (resizeTimer = setTimeout(function () {
                        resizeTimer = null,
                            d.cachedCharWidth = d.cachedTextHeight = knownScrollbarWidth = null,
                            clearCaches(cm),
                            runInOp(cm, bind(regChange, cm))
                    },
                    100))
            }

            function unregister() {
                for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode);
                p ? setTimeout(unregister, 5e3) : off(window, "resize", onResize)
            }

            function drag_(e) {
                signalDOMEvent(cm, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e)) || e_stop(e)
            }

            function prepareCopy() {
                d.inaccurateSelection && (d.prevInput = "", d.inaccurateSelection = !1, d.input.value = cm.getSelection(), selectInput(d.input))
            }
            var d = cm.display;
            on(d.scroller, "mousedown", operation(cm, onMouseDown)),
                ie ? on(d.scroller, "dblclick", operation(cm,
                    function (e) {
                        if (!signalDOMEvent(cm, e)) {
                            var pos = posFromMouse(cm, e);
                            if (pos && !clickInGutter(cm, e) && !eventInWidget(cm.display, e)) {
                                e_preventDefault(e);
                                var word = findWordAt(getLine(cm.doc, pos.line).text, pos);
                                extendSelection(cm.doc, word.from, word.to)
                            }
                        }
                    })) : on(d.scroller, "dblclick",
                    function (e) {
                        signalDOMEvent(cm, e) || e_preventDefault(e)
                    }),
                on(d.lineSpace, "selectstart",
                    function (e) {
                        eventInWidget(d, e) || e_preventDefault(e)
                    }),
                captureMiddleClick || on(d.scroller, "contextmenu",
                    function (e) {
                        onContextMenu(cm, e)
                    }),
                on(d.scroller, "scroll",
                    function () {
                        d.scroller.clientHeight && (setScrollTop(cm, d.scroller.scrollTop), setScrollLeft(cm, d.scroller.scrollLeft, !0), signal(cm, "scroll", cm))
                    }),
                on(d.scrollbarV, "scroll",
                    function () {
                        d.scroller.clientHeight && setScrollTop(cm, d.scrollbarV.scrollTop)
                    }),
                on(d.scrollbarH, "scroll",
                    function () {
                        d.scroller.clientHeight && setScrollLeft(cm, d.scrollbarH.scrollLeft)
                    }),
                on(d.scroller, "mousewheel",
                    function (e) {
                        onScrollWheel(cm, e)
                    }),
                on(d.scroller, "DOMMouseScroll",
                    function (e) {
                        onScrollWheel(cm, e)
                    }),
                on(d.scrollbarH, "mousedown", reFocus),
                on(d.scrollbarV, "mousedown", reFocus),
                on(d.wrapper, "scroll",
                    function () {
                        d.wrapper.scrollTop = d.wrapper.scrollLeft = 0
                    });
            var resizeTimer;
            on(window, "resize", onResize),
                setTimeout(unregister, 5e3),
                on(d.input, "keyup", operation(cm,
                    function (e) {
                        signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)) || 16 == e.keyCode && (cm.doc.sel.shift = !1)
                    })),
                on(d.input, "input",
                    function () {
                        ie && !ie_lt9 && cm.display.inputHasSelection && (cm.display.inputHasSelection = null),
                            fastPoll(cm)
                    }),
                on(d.input, "keydown", operation(cm, onKeyDown)),
                on(d.input, "keypress", operation(cm, onKeyPress)),
                on(d.input, "focus", bind(onFocus, cm)),
                on(d.input, "blur", bind(onBlur, cm)),
                cm.options.dragDrop && (on(d.scroller, "dragstart",
                    function (e) {
                        onDragStart(cm, e)
                    }), on(d.scroller, "dragenter", drag_), on(d.scroller, "dragover", drag_), on(d.scroller, "drop", operation(cm, onDrop))),
                on(d.scroller, "paste",
                    function (e) {
                        eventInWidget(d, e) || (focusInput(cm), fastPoll(cm))
                    }),
                on(d.input, "paste",
                    function () {
                        if (webkit && !cm.state.fakedLastChar && !(new Date - cm.state.lastMiddleDown < 200)) {
                            var start = d.input.selectionStart,
                                end = d.input.selectionEnd;
                            d.input.value += "$",
                                d.input.selectionStart = start,
                                d.input.selectionEnd = end,
                                cm.state.fakedLastChar = !0
                        }
                        cm.state.pasteIncoming = !0,
                            fastPoll(cm)
                    }),
                on(d.input, "cut", prepareCopy),
                on(d.input, "copy", prepareCopy),
                khtml && on(d.sizer, "mouseup",
                    function () {
                        document.activeElement == d.input && d.input.blur(),
                            focusInput(cm)
                    })
        }

        function eventInWidget(display, e) {
            for (var n = e_target(e); n != display.wrapper; n = n.parentNode)
                if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover) return !0
        }

        function posFromMouse(cm, e, liberal) {
            var display = cm.display;
            if (!liberal) {
                var target = e_target(e);
                if (target == display.scrollbarH || target == display.scrollbarH.firstChild || target == display.scrollbarV || target == display.scrollbarV.firstChild || target == display.scrollbarFiller || target == display.gutterFiller) return null
            }
            var x, y, space = getRect(display.lineSpace);
            try {
                x = e.clientX,
                    y = e.clientY
            } catch (e) {
                return null
            }
            return coordsChar(cm, x - space.left, y - space.top)
        }

        function onMouseDown(e) {
            function doSelect(cur) {
                if (!posEq(lastPos, cur)) {
                    if (lastPos = cur, "single" == type) return void extendSelection(cm.doc, clipPos(doc, start), cur);
                    if (startstart = clipPos(doc, startstart), startend = clipPos(doc, startend), "double" == type) {
                        var word = findWordAt(getLine(doc, cur.line).text, cur);
                        posLess(cur, startstart) ? extendSelection(cm.doc, word.from, startend) : extendSelection(cm.doc, startstart, word.to)
                    } else "triple" == type && (posLess(cur, startstart) ? extendSelection(cm.doc, startend, clipPos(doc, Pos(cur.line, 0))) : extendSelection(cm.doc, startstart, clipPos(doc, Pos(cur.line + 1, 0))))
                }
            }

            function extend(e) {
                var curCount = ++counter,
                    cur = posFromMouse(cm, e, !0);
                if (cur)
                    if (posEq(cur, last)) {
                        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
                        outside && setTimeout(operation(cm,
                            function () {
                                counter == curCount && (display.scroller.scrollTop += outside, extend(e))
                            }), 50)
                    } else {
                        cm.state.focused || onFocus(cm),
                            last = cur,
                            doSelect(cur);
                        var visible = visibleLines(display, doc);
                        (cur.line >= visible.to || cur.line < visible.from) && setTimeout(operation(cm,
                            function () {
                                counter == curCount && extend(e)
                            }), 150)
                    }
            }

            function done(e) {
                counter = 1 / 0,
                    e_preventDefault(e),
                    focusInput(cm),
                    off(document, "mousemove", move),
                    off(document, "mouseup", up)
            }
            if (!signalDOMEvent(this, e)) {
                var cm = this,
                    display = cm.display,
                    doc = cm.doc,
                    sel = doc.sel;
                if (sel.shift = e.shiftKey, eventInWidget(display, e)) return void(webkit || (display.scroller.draggable = !1, setTimeout(function () {
                        display.scroller.draggable = !0
                    },
                    100)));
                if (!clickInGutter(cm, e)) {
                    var start = posFromMouse(cm, e);
                    switch (e_button(e)) {
                        case 3:
                            return void(captureMiddleClick && onContextMenu.call(cm, cm, e));
                        case 2:
                            return webkit && (cm.state.lastMiddleDown = +new Date),
                                start && extendSelection(cm.doc, start),
                                setTimeout(bind(focusInput, cm), 20),
                                void e_preventDefault(e)
                    }
                    if (!start) return void(e_target(e) == display.scroller && e_preventDefault(e));
                    cm.state.focused || onFocus(cm);
                    var now = +new Date,
                        type = "single";
                    if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) type = "triple",
                        e_preventDefault(e),
                        setTimeout(bind(focusInput, cm), 20),
                        selectLine(cm, start.line);
                    else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {
                        type = "double",
                            lastDoubleClick = {
                                time: now,
                                pos: start
                            },
                            e_preventDefault(e);
                        var word = findWordAt(getLine(doc, start.line).text, start);
                        extendSelection(cm.doc, word.from, word.to)
                    } else lastClick = {
                        time: now,
                        pos: start
                    };
                    var last = start;
                    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) && !posLess(start, sel.from) && !posLess(sel.to, start) && "single" == type) {
                        var dragEnd = operation(cm,
                            function (e2) {
                                webkit && (display.scroller.draggable = !1),
                                    cm.state.draggingText = !1,
                                    off(document, "mouseup", dragEnd),
                                    off(display.scroller, "drop", dragEnd),
                                    Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10 && (e_preventDefault(e2), extendSelection(cm.doc, start), focusInput(cm))
                            });
                        return webkit && (display.scroller.draggable = !0),
                            cm.state.draggingText = dragEnd,
                            display.scroller.dragDrop && display.scroller.dragDrop(),
                            on(document, "mouseup", dragEnd),
                            void on(display.scroller, "drop", dragEnd)
                    }
                    e_preventDefault(e),
                        "single" == type && extendSelection(cm.doc, clipPos(doc, start));
                    var startstart = sel.from,
                        startend = sel.to,
                        lastPos = start,
                        editorSize = getRect(display.wrapper),
                        counter = 0,
                        move = operation(cm,
                            function (e) {
                                ie || e_button(e) ? extend(e) : done(e)
                            }),
                        up = operation(cm, done);
                    on(document, "mousemove", move),
                        on(document, "mouseup", up)
                }
            }
        }

        function gutterEvent(cm, e, type, prevent, signalfn) {
            try {
                var mX = e.clientX,
                    mY = e.clientY
            } catch (e) {
                return !1
            }
            if (mX >= Math.floor(getRect(cm.display.gutters).right)) return !1;
            prevent && e_preventDefault(e);
            var display = cm.display,
                lineBox = getRect(display.lineDiv);
            if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
            mY -= lineBox.top - display.viewOffset;
            for (var i = 0; i < cm.options.gutters.length; ++i) {
                var g = display.gutters.childNodes[i];
                if (g && getRect(g).right >= mX) {
                    var line = lineAtHeight(cm.doc, mY),
                        gutter = cm.options.gutters[i];
                    return signalfn(cm, type, cm, line, gutter, e),
                        e_defaultPrevented(e)
                }
            }
        }

        function contextMenuInGutter(cm, e) {
            return hasHandler(cm, "gutterContextMenu") ? gutterEvent(cm, e, "gutterContextMenu", !1, signal) : !1
        }

        function clickInGutter(cm, e) {
            return gutterEvent(cm, e, "gutterClick", !0, signalLater)
        }

        function onDrop(e) {
            var cm = this;
            if (!(signalDOMEvent(cm, e) || eventInWidget(cm.display, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e)))) {
                e_preventDefault(e),
                    ie && (lastDrop = +new Date);
                var pos = posFromMouse(cm, e, !0),
                    files = e.dataTransfer.files;
                if (pos && !isReadOnly(cm))
                    if (files && files.length && window.FileReader && window.File)
                        for (var n = files.length,
                                text = Array(n), read = 0, loadFile = function (file, i) {
                                    var reader = new FileReader;
                                    reader.onload = function () {
                                            text[i] = reader.result,
                                                ++read == n && (pos = clipPos(cm.doc, pos), makeChange(cm.doc, {
                                                        from: pos,
                                                        to: pos,
                                                        text: splitLines(text.join("\n")),
                                                        origin: "paste"
                                                    },
                                                    "around"))
                                        },
                                        reader.readAsText(file)
                                },
                                i = 0; n > i; ++i) loadFile(files[i], i);
                    else {
                        if (cm.state.draggingText && !posLess(pos, cm.doc.sel.from) && !posLess(cm.doc.sel.to, pos)) return cm.state.draggingText(e),
                            void setTimeout(bind(focusInput, cm), 20);
                        try {
                            var text = e.dataTransfer.getData("Text");
                            if (text) {
                                var curFrom = cm.doc.sel.from,
                                    curTo = cm.doc.sel.to;
                                setSelection(cm.doc, pos, pos),
                                    cm.state.draggingText && replaceRange(cm.doc, "", curFrom, curTo, "paste"),
                                    cm.replaceSelection(text, null, "paste"),
                                    focusInput(cm),
                                    onFocus(cm)
                            }
                        } catch (e) {}
                    }
            }
        }

        function onDragStart(cm, e) {
            if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) return void e_stop(e);
            if (!signalDOMEvent(cm, e) && !eventInWidget(cm.display, e)) {
                var txt = cm.getSelection();
                if (e.dataTransfer.setData("Text", txt), e.dataTransfer.setDragImage && !safari) {
                    var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
                    img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
                        opera && (img.width = img.height = 1, cm.display.wrapper.appendChild(img), img._top = img.offsetTop),
                        e.dataTransfer.setDragImage(img, 0, 0),
                        opera && img.parentNode.removeChild(img)
                }
            }
        }

        function setScrollTop(cm, val) {
            Math.abs(cm.doc.scrollTop - val) < 2 || (cm.doc.scrollTop = val, gecko || updateDisplay(cm, [], val), cm.display.scroller.scrollTop != val && (cm.display.scroller.scrollTop = val), cm.display.scrollbarV.scrollTop != val && (cm.display.scrollbarV.scrollTop = val), gecko && updateDisplay(cm, []), startWorker(cm, 100))
        }

        function setScrollLeft(cm, val, isScroller) {
            (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) || (val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth), cm.doc.scrollLeft = val, alignHorizontally(cm), cm.display.scroller.scrollLeft != val && (cm.display.scroller.scrollLeft = val), cm.display.scrollbarH.scrollLeft != val && (cm.display.scrollbarH.scrollLeft = val))
        }

        function onScrollWheel(cm, e) {
            var dx = e.wheelDeltaX,
                dy = e.wheelDeltaY;
            null == dx && e.detail && e.axis == e.HORIZONTAL_AXIS && (dx = e.detail),
                null == dy && e.detail && e.axis == e.VERTICAL_AXIS ? dy = e.detail : null == dy && (dy = e.wheelDelta);
            var display = cm.display,
                scroll = display.scroller;
            if (dx && scroll.scrollWidth > scroll.clientWidth || dy && scroll.scrollHeight > scroll.clientHeight) {
                if (dy && mac && webkit)
                    for (var cur = e.target; cur != scroll; cur = cur.parentNode)
                        if (cur.lineObj) {
                            cm.display.currentWheelTarget = cur;
                            break
                        }
                if (dx && !gecko && !opera && null != wheelPixelsPerUnit) return dy && setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight))),
                    setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth))),
                    e_preventDefault(e),
                    void(display.wheelStartX = null);
                if (dy && null != wheelPixelsPerUnit) {
                    var pixels = dy * wheelPixelsPerUnit,
                        top = cm.doc.scrollTop,
                        bot = top + display.wrapper.clientHeight;
                    0 > pixels ? top = Math.max(0, top + pixels - 50) : bot = Math.min(cm.doc.height, bot + pixels + 50),
                        updateDisplay(cm, [], {
                            top: top,
                            bottom: bot
                        })
                }
                20 > wheelSamples && (null == display.wheelStartX ? (display.wheelStartX = scroll.scrollLeft, display.wheelStartY = scroll.scrollTop, display.wheelDX = dx, display.wheelDY = dy, setTimeout(function () {
                        if (null != display.wheelStartX) {
                            var movedX = scroll.scrollLeft - display.wheelStartX,
                                movedY = scroll.scrollTop - display.wheelStartY,
                                sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
                            display.wheelStartX = display.wheelStartY = null,
                                sample && (wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1), ++wheelSamples)
                        }
                    },
                    200)) : (display.wheelDX += dx, display.wheelDY += dy))
            }
        }

        function doHandleBinding(cm, bound, dropShift) {
            if ("string" == typeof bound && (bound = commands[bound], !bound)) return !1;
            cm.display.pollingFast && readInput(cm) && (cm.display.pollingFast = !1);
            var doc = cm.doc,
                prevShift = doc.sel.shift,
                done = !1;
            try {
                isReadOnly(cm) && (cm.state.suppressEdits = !0),
                    dropShift && (doc.sel.shift = !1),
                    done = bound(cm) != Pass
            } finally {
                doc.sel.shift = prevShift,
                    cm.state.suppressEdits = !1
            }
            return done
        }

        function allKeyMaps(cm) {
            var maps = cm.state.keyMaps.slice(0);
            return cm.options.extraKeys && maps.push(cm.options.extraKeys),
                maps.push(cm.options.keyMap),
                maps
        }

        function handleKeyBinding(cm, e) {
            var startMap = getKeyMap(cm.options.keyMap),
                next = startMap.auto;
            clearTimeout(maybeTransition),
                next && !isModifierKey(e) && (maybeTransition = setTimeout(function () {
                        getKeyMap(cm.options.keyMap) == startMap && (cm.options.keyMap = next.call ? next.call(null, cm) : next, keyMapChanged(cm))
                    },
                    50));
            var name = keyName(e, !0),
                handled = !1;
            if (!name) return !1;
            var keymaps = allKeyMaps(cm);
            return handled = e.shiftKey ? lookupKey("Shift-" + name, keymaps,
                    function (b) {
                        return doHandleBinding(cm, b, !0)
                    }) || lookupKey(name, keymaps,
                    function (b) {
                        return ("string" == typeof b ? /^go[A-Z]/.test(b) : b.motion) ? doHandleBinding(cm, b) : void 0
                    }) : lookupKey(name, keymaps,
                    function (b) {
                        return doHandleBinding(cm, b)
                    }),
                handled && (e_preventDefault(e), restartBlink(cm), ie_lt9 && (e.oldKeyCode = e.keyCode, e.keyCode = 0), signalLater(cm, "keyHandled", cm, name, e)),
                handled
        }

        function handleCharBinding(cm, e, ch) {
            var handled = lookupKey("'" + ch + "'", allKeyMaps(cm),
                function (b) {
                    return doHandleBinding(cm, b, !0)
                });
            return handled && (e_preventDefault(e), restartBlink(cm), signalLater(cm, "keyHandled", cm, "'" + ch + "'", e)),
                handled
        }

        function onKeyDown(e) {
            var cm = this;
            if (cm.state.focused || onFocus(cm), !(signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))) {
                ie && 27 == e.keyCode && (e.returnValue = !1);
                var code = e.keyCode;
                cm.doc.sel.shift = 16 == code || e.shiftKey;
                var handled = handleKeyBinding(cm, e);
                opera && (lastStoppedKey = handled ? code : null, !handled && 88 == code && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey) && cm.replaceSelection(""))
            }
        }

        function onKeyPress(e) {
            var cm = this;
            if (!(signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))) {
                var keyCode = e.keyCode,
                    charCode = e.charCode;
                if (opera && keyCode == lastStoppedKey) return lastStoppedKey = null,
                    void e_preventDefault(e);
                if (!(opera && (!e.which || e.which < 10) || khtml) || !handleKeyBinding(cm, e)) {
                    var ch = String.fromCharCode(null == charCode ? keyCode : charCode);
                    this.options.electricChars && this.doc.mode.electricChars && this.options.smartIndent && !isReadOnly(this) && this.doc.mode.electricChars.indexOf(ch) > -1 && setTimeout(operation(cm,
                            function () {
                                indentLine(cm, cm.doc.sel.to.line, "smart")
                            }), 75),
                        handleCharBinding(cm, e, ch) || (ie && !ie_lt9 && (cm.display.inputHasSelection = null), fastPoll(cm))
                }
            }
        }

        function onFocus(cm) {
            "nocursor" != cm.options.readOnly && (cm.state.focused || (signal(cm, "focus", cm), cm.state.focused = !0, -1 == cm.display.wrapper.className.search(/\bCodeMirror-focused\b/) && (cm.display.wrapper.className += " CodeMirror-focused"), cm.curOp || (resetInput(cm, !0), webkit && setTimeout(bind(resetInput, cm, !0), 0))), slowPoll(cm), restartBlink(cm))
        }

        function onBlur(cm) {
            cm.state.focused && (signal(cm, "blur", cm), cm.state.focused = !1, cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-focused", "")),
                clearInterval(cm.display.blinker),
                setTimeout(function () {
                        cm.state.focused || (cm.doc.sel.shift = !1)
                    },
                    150)
        }

        function onContextMenu(cm, e) {
            function prepareSelectAllHack() {
                if (null != display.input.selectionStart) {
                    var extval = display.input.value = "​" + (posEq(sel.from, sel.to) ? "" : display.input.value);
                    display.prevInput = "​",
                        display.input.selectionStart = 1,
                        display.input.selectionEnd = extval.length
                }
            }

            function rehide() {
                if (display.inputDiv.style.position = "relative", display.input.style.cssText = oldCSS, ie_lt9 && (display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos), slowPoll(cm), null != display.input.selectionStart) {
                    (!ie || ie_lt9) && prepareSelectAllHack(),
                        clearTimeout(detectingSelectAll);
                    var i = 0,
                        poll = function () {
                            " " == display.prevInput && 0 == display.input.selectionStart ? operation(cm, commands.selectAll)(cm) : i++ < 10 ? detectingSelectAll = setTimeout(poll, 500) : resetInput(cm)
                        };
                    detectingSelectAll = setTimeout(poll, 200)
                }
            }
            if (!signalDOMEvent(cm, e, "contextmenu")) {
                var display = cm.display,
                    sel = cm.doc.sel;
                if (!eventInWidget(display, e) && !contextMenuInGutter(cm, e)) {
                    var pos = posFromMouse(cm, e),
                        scrollPos = display.scroller.scrollTop;
                    if (pos && !opera) {
                        var reset = cm.options.resetSelectionOnContextMenu;
                        reset && (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to)) && operation(cm, setSelection)(cm.doc, pos, pos);
                        var oldCSS = display.input.style.cssText;
                        if (display.inputDiv.style.position = "absolute", display.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) + "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: white; outline: none;border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);", focusInput(cm), resetInput(cm, !0), posEq(sel.from, sel.to) && (display.input.value = display.prevInput = " "), ie && !ie_lt9 && prepareSelectAllHack(), captureMiddleClick) {
                            e_stop(e);
                            var mouseup = function () {
                                off(window, "mouseup", mouseup),
                                    setTimeout(rehide, 20)
                            };
                            on(window, "mouseup", mouseup)
                        } else setTimeout(rehide, 50)
                    }
                }
            }
        }

        function clipPostChange(doc, change, pos) {
            if (!posLess(change.from, pos)) return clipPos(doc, pos);
            var diff = change.text.length - 1 - (change.to.line - change.from.line);
            if (pos.line > change.to.line + diff) {
                var preLine = pos.line - diff,
                    lastLine = doc.first + doc.size - 1;
                return preLine > lastLine ? Pos(lastLine, getLine(doc, lastLine).text.length) : clipToLen(pos, getLine(doc, preLine).text.length)
            }
            if (pos.line == change.to.line + diff) return clipToLen(pos, lst(change.text).length + (1 == change.text.length ? change.from.ch : 0) + getLine(doc, change.to.line).text.length - change.to.ch);
            var inside = pos.line - change.from.line;
            return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch))
        }

        function computeSelAfterChange(doc, change, hint) {
            if (hint && "object" == typeof hint) return {
                anchor: clipPostChange(doc, change, hint.anchor),
                head: clipPostChange(doc, change, hint.head)
            };
            if ("start" == hint) return {
                anchor: change.from,
                head: change.from
            };
            var end = changeEnd(change);
            if ("around" == hint) return {
                anchor: change.from,
                head: end
            };
            if ("end" == hint) return {
                anchor: end,
                head: end
            };
            var adjustPos = function (pos) {
                if (posLess(pos, change.from)) return pos;
                if (!posLess(change.to, pos)) return end;
                var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,
                    ch = pos.ch;
                return pos.line == change.to.line && (ch += end.ch - change.to.ch),
                    Pos(line, ch)
            };
            return {
                anchor: adjustPos(doc.sel.anchor),
                head: adjustPos(doc.sel.head)
            }
        }

        function filterChange(doc, change, update) {
            var obj = {
                canceled: !1,
                from: change.from,
                to: change.to,
                text: change.text,
                origin: change.origin,
                cancel: function () {
                    this.canceled = !0
                }
            };
            return update && (obj.update = function (from, to, text, origin) {
                    from && (this.from = clipPos(doc, from)),
                        to && (this.to = clipPos(doc, to)),
                        text && (this.text = text),
                        void 0 !== origin && (this.origin = origin)
                }),
                signal(doc, "beforeChange", doc, obj),
                doc.cm && signal(doc.cm, "beforeChange", doc.cm, obj),
                obj.canceled ? null : {
                    from: obj.from,
                    to: obj.to,
                    text: obj.text,
                    origin: obj.origin
                }
        }

        function makeChange(doc, change, selUpdate, ignoreReadOnly) {
            if (doc.cm) {
                if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);
                if (doc.cm.state.suppressEdits) return
            }
            if (!(hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) || (change = filterChange(doc, change, !0))) {
                var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
                if (split) {
                    for (var i = split.length - 1; i >= 1; --i) makeChangeNoReadonly(doc, {
                        from: split[i].from,
                        to: split[i].to,
                        text: [""]
                    });
                    split.length && makeChangeNoReadonly(doc, {
                            from: split[0].from,
                            to: split[0].to,
                            text: change.text
                        },
                        selUpdate)
                } else makeChangeNoReadonly(doc, change, selUpdate)
            }
        }

        function makeChangeNoReadonly(doc, change, selUpdate) {
            if (1 != change.text.length || "" != change.text[0] || !posEq(change.from, change.to)) {
                var selAfter = computeSelAfterChange(doc, change, selUpdate);
                addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : 0 / 0),
                    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
                var rebased = [];
                linkedDocs(doc,
                    function (doc, sharedHist) {
                        sharedHist || -1 != indexOf(rebased, doc.history) || (rebaseHist(doc.history, change), rebased.push(doc.history)),
                            makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change))
                    })
            }
        }

        function makeChangeFromHistory(doc, type) {
            if (!doc.cm || !doc.cm.state.suppressEdits) {
                var hist = doc.history,
                    event = ("undo" == type ? hist.done : hist.undone).pop();
                if (event) {
                    var anti = {
                        changes: [],
                        anchorBefore: event.anchorAfter,
                        headBefore: event.headAfter,
                        anchorAfter: event.anchorBefore,
                        headAfter: event.headBefore,
                        generation: hist.generation
                    };
                    ("undo" == type ? hist.undone : hist.done).push(anti),
                        hist.generation = event.generation || ++hist.maxGeneration;
                    for (var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange"), i = event.changes.length - 1; i >= 0; --i) {
                        var change = event.changes[i];
                        if (change.origin = type, filter && !filterChange(doc, change, !1)) return void(("undo" == type ? hist.done : hist.undone).length = 0);
                        anti.changes.push(historyChangeFromChange(doc, change));
                        var after = i ? computeSelAfterChange(doc, change, null) : {
                            anchor: event.anchorBefore,
                            head: event.headBefore
                        };
                        makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
                        var rebased = [];
                        linkedDocs(doc,
                            function (doc, sharedHist) {
                                sharedHist || -1 != indexOf(rebased, doc.history) || (rebaseHist(doc.history, change), rebased.push(doc.history)),
                                    makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change))
                            })
                    }
                }
            }
        }

        function shiftDoc(doc, distance) {
            function shiftPos(pos) {
                return Pos(pos.line + distance, pos.ch)
            }
            doc.first += distance,
                doc.cm && regChange(doc.cm, doc.first, doc.first, distance),
                doc.sel.head = shiftPos(doc.sel.head),
                doc.sel.anchor = shiftPos(doc.sel.anchor),
                doc.sel.from = shiftPos(doc.sel.from),
                doc.sel.to = shiftPos(doc.sel.to)
        }

        function makeChangeSingleDoc(doc, change, selAfter, spans) {
            if (doc.cm && !doc.cm.curOp) return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
            if (change.to.line < doc.first) return void shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
            if (!(change.from.line > doc.lastLine())) {
                if (change.from.line < doc.first) {
                    var shift = change.text.length - 1 - (doc.first - change.from.line);
                    shiftDoc(doc, shift),
                        change = {
                            from: Pos(doc.first, 0),
                            to: Pos(change.to.line + shift, change.to.ch),
                            text: [lst(change.text)],
                            origin: change.origin
                        }
                }
                var last = doc.lastLine();
                change.to.line > last && (change = {
                        from: change.from,
                        to: Pos(last, getLine(doc, last).text.length),
                        text: [change.text[0]],
                        origin: change.origin
                    }),
                    change.removed = getBetween(doc, change.from, change.to),
                    selAfter || (selAfter = computeSelAfterChange(doc, change, null)),
                    doc.cm ? makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter) : updateDoc(doc, change, spans, selAfter)
            }
        }

        function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {
            var doc = cm.doc,
                display = cm.display,
                from = change.from,
                to = change.to,
                recomputeMaxLength = !1,
                checkWidthStart = from.line;
            cm.options.lineWrapping || (checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line))), doc.iter(checkWidthStart, to.line + 1,
                    function (line) {
                        return line == display.maxLine ? (recomputeMaxLength = !0, !0) : void 0
                    })),
                posLess(doc.sel.head, change.from) || posLess(change.to, doc.sel.head) || (cm.curOp.cursorActivity = !0),
                updateDoc(doc, change, spans, selAfter, estimateHeight(cm)),
                cm.options.lineWrapping || (doc.iter(checkWidthStart, from.line + change.text.length,
                    function (line) {
                        var len = lineLength(doc, line);
                        len > display.maxLineLength && (display.maxLine = line, display.maxLineLength = len, display.maxLineChanged = !0, recomputeMaxLength = !1)
                    }), recomputeMaxLength && (cm.curOp.updateMaxLine = !0)),
                doc.frontier = Math.min(doc.frontier, from.line),
                startWorker(cm, 400);
            var lendiff = change.text.length - (to.line - from.line) - 1;
            if (regChange(cm, from.line, to.line + 1, lendiff), hasHandler(cm, "change")) {
                var changeObj = {
                    from: from,
                    to: to,
                    text: change.text,
                    removed: change.removed,
                    origin: change.origin
                };
                if (cm.curOp.textChanged) {
                    for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next);
                    cur.next = changeObj
                } else cm.curOp.textChanged = changeObj
            }
        }

        function replaceRange(doc, code, from, to, origin) {
            if (to || (to = from), posLess(to, from)) {
                var tmp = to;
                to = from,
                    from = tmp
            }
            "string" == typeof code && (code = splitLines(code)),
                makeChange(doc, {
                        from: from,
                        to: to,
                        text: code,
                        origin: origin
                    },
                    null)
        }

        function Pos(line, ch) {
            return this instanceof Pos ? (this.line = line, void(this.ch = ch)) : new Pos(line, ch)
        }

        function posEq(a, b) {
            return a.line == b.line && a.ch == b.ch
        }

        function posLess(a, b) {
            return a.line < b.line || a.line == b.line && a.ch < b.ch
        }

        function copyPos(x) {
            return Pos(x.line, x.ch)
        }

        function clipLine(doc, n) {
            return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))
        }

        function clipPos(doc, pos) {
            if (pos.line < doc.first) return Pos(doc.first, 0);
            var last = doc.first + doc.size - 1;
            return pos.line > last ? Pos(last, getLine(doc, last).text.length) : clipToLen(pos, getLine(doc, pos.line).text.length)
        }

        function clipToLen(pos, linelen) {
            var ch = pos.ch;
            return null == ch || ch > linelen ? Pos(pos.line, linelen) : 0 > ch ? Pos(pos.line, 0) : pos
        }

        function isLine(doc, l) {
            return l >= doc.first && l < doc.first + doc.size
        }

        function extendSelection(doc, pos, other, bias) {
            if (doc.sel.shift || doc.sel.extend) {
                var anchor = doc.sel.anchor;
                if (other) {
                    var posBefore = posLess(pos, anchor);
                    posBefore != posLess(other, anchor) ? (anchor = pos, pos = other) : posBefore != posLess(pos, other) && (pos = other)
                }
                setSelection(doc, anchor, pos, bias)
            } else setSelection(doc, pos, other || pos, bias);
            doc.cm && (doc.cm.curOp.userSelChange = !0)
        }

        function filterSelectionChange(doc, anchor, head) {
            var obj = {
                anchor: anchor,
                head: head
            };
            return signal(doc, "beforeSelectionChange", doc, obj),
                doc.cm && signal(doc.cm, "beforeSelectionChange", doc.cm, obj),
                obj.anchor = clipPos(doc, obj.anchor),
                obj.head = clipPos(doc, obj.head),
                obj
        }

        function setSelection(doc, anchor, head, bias, checkAtomic) {
            if (!checkAtomic && hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
                var filtered = filterSelectionChange(doc, anchor, head);
                head = filtered.head,
                    anchor = filtered.anchor
            }
            var sel = doc.sel;
            if (sel.goalColumn = null, null == bias && (bias = posLess(head, sel.head) ? -1 : 1), (checkAtomic || !posEq(anchor, sel.anchor)) && (anchor = skipAtomic(doc, anchor, bias, "push" != checkAtomic)), (checkAtomic || !posEq(head, sel.head)) && (head = skipAtomic(doc, head, bias, "push" != checkAtomic)), !posEq(sel.anchor, anchor) || !posEq(sel.head, head)) {
                sel.anchor = anchor,
                    sel.head = head;
                var inv = posLess(head, anchor);
                sel.from = inv ? head : anchor,
                    sel.to = inv ? anchor : head,
                    doc.cm && (doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = doc.cm.curOp.cursorActivity = !0),
                    signalLater(doc, "cursorActivity", doc)
            }
        }

        function reCheckSelection(cm) {
            setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, "push")
        }

        function skipAtomic(doc, pos, bias, mayClear) {
            var flipped = !1,
                curPos = pos,
                dir = bias || 1;
            doc.cantEdit = !1;
            search: for (;;) {
                var line = getLine(doc, curPos.line);
                if (line.markedSpans)
                    for (var i = 0; i < line.markedSpans.length; ++i) {
                        var sp = line.markedSpans[i],
                            m = sp.marker;
                        if ((null == sp.from || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) && (null == sp.to || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
                            if (mayClear && (signal(m, "beforeCursorEnter"), m.explicitlyCleared)) {
                                if (line.markedSpans) {
                                    --i;
                                    continue
                                }
                                break
                            }
                            if (!m.atomic) continue;
                            var newPos = m.find()[0 > dir ? "from" : "to"];
                            if (posEq(newPos, curPos) && (newPos.ch += dir, newPos.ch < 0 ? newPos = newPos.line > doc.first ? clipPos(doc, Pos(newPos.line - 1)) : null : newPos.ch > line.text.length && (newPos = newPos.line < doc.first + doc.size - 1 ? Pos(newPos.line + 1, 0) : null), !newPos)) {
                                if (flipped) return mayClear ? (doc.cantEdit = !0, Pos(doc.first, 0)) : skipAtomic(doc, pos, bias, !0);
                                flipped = !0,
                                    newPos = pos,
                                    dir = -dir
                            }
                            curPos = newPos;
                            continue search
                        }
                    }
                return curPos
            }
        }

        function scrollCursorIntoView(cm) {
            var coords = scrollPosIntoView(cm, cm.doc.sel.head, null, cm.options.cursorScrollMargin);
            if (cm.state.focused) {
                var display = cm.display,
                    box = getRect(display.sizer),
                    doScroll = null;
                if (coords.top + box.top < 0 ? doScroll = !0 : coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight) && (doScroll = !1), null != doScroll && !phantom) {
                    var hidden = "none" == display.cursor.style.display;
                    hidden && (display.cursor.style.display = "", display.cursor.style.left = coords.left + "px", display.cursor.style.top = coords.top - display.viewOffset + "px"),
                        display.cursor.scrollIntoView(doScroll),
                        hidden && (display.cursor.style.display = "none")
                }
            }
        }

        function scrollPosIntoView(cm, pos, end, margin) {
            for (null == margin && (margin = 0);;) {
                var changed = !1,
                    coords = cursorCoords(cm, pos),
                    endCoords = end && end != pos ? cursorCoords(cm, end) : coords,
                    scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left), Math.min(coords.top, endCoords.top) - margin, Math.max(coords.left, endCoords.left), Math.max(coords.bottom, endCoords.bottom) + margin),
                    startTop = cm.doc.scrollTop,
                    startLeft = cm.doc.scrollLeft;
                if (null != scrollPos.scrollTop && (setScrollTop(cm, scrollPos.scrollTop), Math.abs(cm.doc.scrollTop - startTop) > 1 && (changed = !0)), null != scrollPos.scrollLeft && (setScrollLeft(cm, scrollPos.scrollLeft), Math.abs(cm.doc.scrollLeft - startLeft) > 1 && (changed = !0)), !changed) return coords
            }
        }

        function scrollIntoView(cm, x1, y1, x2, y2) {
            var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
            null != scrollPos.scrollTop && setScrollTop(cm, scrollPos.scrollTop),
                null != scrollPos.scrollLeft && setScrollLeft(cm, scrollPos.scrollLeft)
        }

        function calculateScrollPos(cm, x1, y1, x2, y2) {
            var display = cm.display,
                snapMargin = textHeight(cm.display);
            0 > y1 && (y1 = 0);
            var screen = display.scroller.clientHeight - scrollerCutOff,
                screentop = display.scroller.scrollTop,
                result = {},
                docBottom = cm.doc.height + paddingVert(display),
                atTop = snapMargin > y1,
                atBottom = y2 > docBottom - snapMargin;
            if (screentop > y1) result.scrollTop = atTop ? 0 : y1;
            else if (y2 > screentop + screen) {
                var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
                newTop != screentop && (result.scrollTop = newTop)
            }
            var screenw = display.scroller.clientWidth - scrollerCutOff,
                screenleft = display.scroller.scrollLeft;
            x1 += display.gutters.offsetWidth,
                x2 += display.gutters.offsetWidth;
            var gutterw = display.gutters.offsetWidth,
                atLeft = gutterw + 10 > x1;
            return screenleft + gutterw > x1 || atLeft ? (atLeft && (x1 = 0), result.scrollLeft = Math.max(0, x1 - 10 - gutterw)) : x2 > screenw + screenleft - 3 && (result.scrollLeft = x2 + 10 - screenw),
                result
        }

        function updateScrollPos(cm, left, top) {
            cm.curOp.updateScrollPos = {
                scrollLeft: null == left ? cm.doc.scrollLeft : left,
                scrollTop: null == top ? cm.doc.scrollTop : top
            }
        }

        function addToScrollPos(cm, left, top) {
            var pos = cm.curOp.updateScrollPos || (cm.curOp.updateScrollPos = {
                    scrollLeft: cm.doc.scrollLeft,
                    scrollTop: cm.doc.scrollTop
                }),
                scroll = cm.display.scroller;
            pos.scrollTop = Math.max(0, Math.min(scroll.scrollHeight - scroll.clientHeight, pos.scrollTop + top)),
                pos.scrollLeft = Math.max(0, Math.min(scroll.scrollWidth - scroll.clientWidth, pos.scrollLeft + left))
        }

        function indentLine(cm, n, how, aggressive) {
            var doc = cm.doc;
            if (null == how && (how = "add"), "smart" == how)
                if (cm.doc.mode.indent) var state = getStateBefore(cm, n);
                else how = "prev";
            var indentation, tabSize = cm.options.tabSize,
                line = getLine(doc, n),
                curSpace = countColumn(line.text, null, tabSize),
                curSpaceString = line.text.match(/^\s*/)[0];
            if ("smart" == how && (indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text), indentation == Pass)) {
                if (!aggressive) return;
                how = "prev"
            }
            "prev" == how ? indentation = n > doc.first ? countColumn(getLine(doc, n - 1).text, null, tabSize) : 0 : "add" == how ? indentation = curSpace + cm.options.indentUnit : "subtract" == how ? indentation = curSpace - cm.options.indentUnit : "number" == typeof how && (indentation = curSpace + how),
                indentation = Math.max(0, indentation);
            var indentString = "",
                pos = 0;
            if (cm.options.indentWithTabs)
                for (var i = Math.floor(indentation / tabSize); i; --i) pos += tabSize,
                    indentString += "	";
            indentation > pos && (indentString += spaceStr(indentation - pos)),
                indentString != curSpaceString && replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input"),
                line.stateAfter = null
        }

        function changeLine(cm, handle, op) {
            var no = handle,
                line = handle,
                doc = cm.doc;
            return "number" == typeof handle ? line = getLine(doc, clipLine(doc, handle)) : no = lineNo(handle),
                null == no ? null : op(line, no) ? (regChange(cm, no, no + 1), line) : null
        }

        function findPosH(doc, pos, dir, unit, visually) {
            function findNextLine() {
                var l = line + dir;
                return l < doc.first || l >= doc.first + doc.size ? possible = !1 : (line = l, lineObj = getLine(doc, l))
            }

            function moveOnce(boundToLine) {
                var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, !0);
                if (null == next) {
                    if (boundToLine || !findNextLine()) return possible = !1;
                    ch = visually ? (0 > dir ? lineRight : lineLeft)(lineObj) : 0 > dir ? lineObj.text.length : 0
                } else ch = next;
                return !0
            }
            var line = pos.line,
                ch = pos.ch,
                origDir = dir,
                lineObj = getLine(doc, line),
                possible = !0;
            if ("char" == unit) moveOnce();
            else if ("column" == unit) moveOnce(!0);
            else if ("word" == unit || "group" == unit)
                for (var sawType = null,
                        group = "group" == unit,
                        first = !0; !(0 > dir) || moveOnce(!first); first = !1) {
                    var cur = lineObj.text.charAt(ch) || "\n",
                        type = isWordChar(cur) ? "w" : group ? /\s/.test(cur) ? null : "p" : null;
                    if (sawType && sawType != type) {
                        0 > dir && (dir = 1, moveOnce());
                        break
                    }
                    if (type && (sawType = type), dir > 0 && !moveOnce(!first)) break
                }
            var result = skipAtomic(doc, Pos(line, ch), origDir, !0);
            return possible || (result.hitSide = !0),
                result
        }

        function findPosV(cm, pos, dir, unit) {
            var y, doc = cm.doc,
                x = pos.left;
            if ("page" == unit) {
                var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
                y = pos.top + dir * (pageSize - (0 > dir ? 1.5 : .5) * textHeight(cm.display))
            } else "line" == unit && (y = dir > 0 ? pos.bottom + 3 : pos.top - 3);
            for (;;) {
                var target = coordsChar(cm, x, y);
                if (!target.outside) break;
                if (0 > dir ? 0 >= y : y >= doc.height) {
                    target.hitSide = !0;
                    break
                }
                y += 5 * dir
            }
            return target
        }

        function findWordAt(line, pos) {
            var start = pos.ch,
                end = pos.ch;
            if (line) {
                (pos.xRel < 0 || end == line.length) && start ? --start : ++end;
                for (var startChar = line.charAt(start), check = isWordChar(startChar) ? isWordChar : /\s/.test(startChar) ?
                        function (ch) {
                            return /\s/.test(ch)
                        } : function (ch) {
                            return !/\s/.test(ch) && !isWordChar(ch)
                        }; start > 0 && check(line.charAt(start - 1));) --start;
                for (; end < line.length && check(line.charAt(end));) ++end
            }
            return {
                from: Pos(pos.line, start),
                to: Pos(pos.line, end)
            }
        }

        function selectLine(cm, line) {
            extendSelection(cm.doc, Pos(line, 0), clipPos(cm.doc, Pos(line + 1, 0)))
        }

        function option(name, deflt, handle, notOnInit) {
            CodeMirror.defaults[name] = deflt,
                handle && (optionHandlers[name] = notOnInit ?
                    function (cm, val, old) {
                        old != Init && handle(cm, val, old)
                    } : handle)
        }

        function copyState(mode, state) {
            if (state === !0) return state;
            if (mode.copyState) return mode.copyState(state);
            var nstate = {};
            for (var n in state) {
                var val = state[n];
                val instanceof Array && (val = val.concat([])),
                    nstate[n] = val
            }
            return nstate
        }

        function startState(mode, a1, a2) {
            return mode.startState ? mode.startState(a1, a2) : !0
        }

        function getKeyMap(val) {
            return "string" == typeof val ? keyMap[val] : val
        }

        function lookupKey(name, maps, handle) {
            function lookup(map) {
                map = getKeyMap(map);
                var found = map[name];
                if (found === !1) return "stop";
                if (null != found && handle(found)) return !0;
                if (map.nofallthrough) return "stop";
                var fallthrough = map.fallthrough;
                if (null == fallthrough) return !1;
                if ("[object Array]" != Object.prototype.toString.call(fallthrough)) return lookup(fallthrough);
                for (var i = 0,
                        e = fallthrough.length; e > i; ++i) {
                    var done = lookup(fallthrough[i]);
                    if (done) return done
                }
                return !1
            }
            for (var i = 0; i < maps.length; ++i) {
                var done = lookup(maps[i]);
                if (done) return "stop" != done
            }
        }

        function isModifierKey(event) {
            var name = keyNames[event.keyCode];
            return "Ctrl" == name || "Alt" == name || "Shift" == name || "Mod" == name
        }

        function keyName(event, noShift) {
            if (opera && 34 == event.keyCode && event["char"]) return !1;
            var name = keyNames[event.keyCode];
            return null == name || event.altGraphKey ? !1 : (event.altKey && (name = "Alt-" + name), (flipCtrlCmd ? event.metaKey : event.ctrlKey) && (name = "Ctrl-" + name), (flipCtrlCmd ? event.ctrlKey : event.metaKey) && (name = "Cmd-" + name), !noShift && event.shiftKey && (name = "Shift-" + name), name)
        }

        function StringStream(string, tabSize) {
            this.pos = this.start = 0,
                this.string = string,
                this.tabSize = tabSize || 8,
                this.lastColumnPos = this.lastColumnValue = 0
        }

        function TextMarker(doc, type) {
            this.lines = [],
                this.type = type,
                this.doc = doc
        }

        function markText(doc, from, to, options, type) {
            if (options && options.shared) return markTextShared(doc, from, to, options, type);
            if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);
            var marker = new TextMarker(doc, type);
            if ("range" == type && !posLess(from, to)) return marker;
            options && copyObj(options, marker),
                marker.replacedWith && (marker.collapsed = !0, marker.replacedWith = elt("span", [marker.replacedWith], "CodeMirror-widget"), options.handleMouseEvents || (marker.replacedWith.ignoreEvents = !0)),
                marker.collapsed && (sawCollapsedSpans = !0),
                marker.addToHistory && addToHistory(doc, {
                        from: from,
                        to: to,
                        origin: "markText"
                    }, {
                        head: doc.sel.head,
                        anchor: doc.sel.anchor
                    },
                    0 / 0);
            var collapsedAtStart, collapsedAtEnd, updateMaxLine, curLine = from.line,
                size = 0,
                cm = doc.cm;
            if (doc.iter(curLine, to.line + 1,
                    function (line) {
                        cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine && (updateMaxLine = !0);
                        var span = {
                            from: null,
                            to: null,
                            marker: marker
                        };
                        size += line.text.length,
                            curLine == from.line && (span.from = from.ch, size -= from.ch),
                            curLine == to.line && (span.to = to.ch, size -= line.text.length - to.ch),
                            marker.collapsed && (curLine == to.line && (collapsedAtEnd = collapsedSpanAt(line, to.ch)), curLine == from.line ? collapsedAtStart = collapsedSpanAt(line, from.ch) : updateLineHeight(line, 0)),
                            addMarkedSpan(line, span),
                            ++curLine
                    }), marker.collapsed && doc.iter(from.line, to.line + 1,
                    function (line) {
                        lineIsHidden(doc, line) && updateLineHeight(line, 0)
                    }), marker.clearOnEnter && on(marker, "beforeCursorEnter",
                    function () {
                        marker.clear()
                    }), marker.readOnly && (sawReadOnlySpans = !0, (doc.history.done.length || doc.history.undone.length) && doc.clearHistory()), marker.collapsed) {
                if (collapsedAtStart != collapsedAtEnd) throw new Error("Inserting collapsed marker overlapping an existing one");
                marker.size = size,
                    marker.atomic = !0
            }
            return cm && (updateMaxLine && (cm.curOp.updateMaxLine = !0), (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.collapsed) && regChange(cm, from.line, to.line + 1), marker.atomic && reCheckSelection(cm)),
                marker
        }

        function SharedTextMarker(markers, primary) {
            this.markers = markers,
                this.primary = primary;
            for (var i = 0,
                    me = this; i < markers.length; ++i) markers[i].parent = this,
                on(markers[i], "clear",
                    function () {
                        me.clear()
                    })
        }

        function markTextShared(doc, from, to, options, type) {
            options = copyObj(options),
                options.shared = !1;
            var markers = [markText(doc, from, to, options, type)],
                primary = markers[0],
                widget = options.replacedWith;
            return linkedDocs(doc,
                    function (doc) {
                        widget && (options.replacedWith = widget.cloneNode(!0)),
                            markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
                        for (var i = 0; i < doc.linked.length; ++i)
                            if (doc.linked[i].isParent) return;
                        primary = lst(markers)
                    }),
                new SharedTextMarker(markers, primary)
        }

        function getMarkedSpanFor(spans, marker) {
            if (spans)
                for (var i = 0; i < spans.length; ++i) {
                    var span = spans[i];
                    if (span.marker == marker) return span
                }
        }

        function removeMarkedSpan(spans, span) {
            for (var r, i = 0; i < spans.length; ++i) spans[i] != span && (r || (r = [])).push(spans[i]);
            return r
        }

        function addMarkedSpan(line, span) {
            line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span],
                span.marker.attachLine(line)
        }

        function markedSpansBefore(old, startCh, isInsert) {
            if (old)
                for (var nw, i = 0; i < old.length; ++i) {
                    var span = old[i],
                        marker = span.marker,
                        startsBefore = null == span.from || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
                    if (startsBefore || "bookmark" == marker.type && span.from == startCh && (!isInsert || !span.marker.insertLeft)) {
                        var endsAfter = null == span.to || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
                        (nw || (nw = [])).push({
                            from: span.from,
                            to: endsAfter ? null : span.to,
                            marker: marker
                        })
                    }
                }
            return nw
        }

        function markedSpansAfter(old, endCh, isInsert) {
            if (old)
                for (var nw, i = 0; i < old.length; ++i) {
                    var span = old[i],
                        marker = span.marker,
                        endsAfter = null == span.to || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
                    if (endsAfter || "bookmark" == marker.type && span.from == endCh && (!isInsert || span.marker.insertLeft)) {
                        var startsBefore = null == span.from || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
                        (nw || (nw = [])).push({
                            from: startsBefore ? null : span.from - endCh,
                            to: null == span.to ? null : span.to - endCh,
                            marker: marker
                        })
                    }
                }
            return nw
        }

        function stretchSpansOverChange(doc, change) {
            var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans,
                oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
            if (!oldFirst && !oldLast) return null;
            var startCh = change.from.ch,
                endCh = change.to.ch,
                isInsert = posEq(change.from, change.to),
                first = markedSpansBefore(oldFirst, startCh, isInsert),
                last = markedSpansAfter(oldLast, endCh, isInsert),
                sameLine = 1 == change.text.length,
                offset = lst(change.text).length + (sameLine ? startCh : 0);
            if (first)
                for (var i = 0; i < first.length; ++i) {
                    var span = first[i];
                    if (null == span.to) {
                        var found = getMarkedSpanFor(last, span.marker);
                        found ? sameLine && (span.to = null == found.to ? null : found.to + offset) : span.to = startCh
                    }
                }
            if (last)
                for (var i = 0; i < last.length; ++i) {
                    var span = last[i];
                    if (null != span.to && (span.to += offset), null == span.from) {
                        var found = getMarkedSpanFor(first, span.marker);
                        found || (span.from = offset, sameLine && (first || (first = [])).push(span))
                    } else span.from += offset,
                        sameLine && (first || (first = [])).push(span)
                }
            if (sameLine && first) {
                for (var i = 0; i < first.length; ++i) null != first[i].from && first[i].from == first[i].to && "bookmark" != first[i].marker.type && first.splice(i--, 1);
                first.length || (first = null)
            }
            var newMarkers = [first];
            if (!sameLine) {
                var gapMarkers, gap = change.text.length - 2;
                if (gap > 0 && first)
                    for (var i = 0; i < first.length; ++i) null == first[i].to && (gapMarkers || (gapMarkers = [])).push({
                        from: null,
                        to: null,
                        marker: first[i].marker
                    });
                for (var i = 0; gap > i; ++i) newMarkers.push(gapMarkers);
                newMarkers.push(last)
            }
            return newMarkers
        }

        function mergeOldSpans(doc, change) {
            var old = getOldSpans(doc, change),
                stretched = stretchSpansOverChange(doc, change);
            if (!old) return stretched;
            if (!stretched) return old;
            for (var i = 0; i < old.length; ++i) {
                var oldCur = old[i],
                    stretchCur = stretched[i];
                if (oldCur && stretchCur) spans: for (var j = 0; j < stretchCur.length; ++j) {
                    for (var span = stretchCur[j], k = 0; k < oldCur.length; ++k)
                        if (oldCur[k].marker == span.marker) continue spans;
                    oldCur.push(span)
                } else stretchCur && (old[i] = stretchCur)
            }
            return old
        }

        function removeReadOnlyRanges(doc, from, to) {
            var markers = null;
            if (doc.iter(from.line, to.line + 1,
                    function (line) {
                        if (line.markedSpans)
                            for (var i = 0; i < line.markedSpans.length; ++i) {
                                var mark = line.markedSpans[i].marker;
                                !mark.readOnly || markers && -1 != indexOf(markers, mark) || (markers || (markers = [])).push(mark)
                            }
                    }), !markers) return null;
            for (var parts = [{
                    from: from,
                    to: to
                }], i = 0; i < markers.length; ++i)
                for (var mk = markers[i], m = mk.find(), j = 0; j < parts.length; ++j) {
                    var p = parts[j];
                    if (!posLess(p.to, m.from) && !posLess(m.to, p.from)) {
                        var newParts = [j, 1];
                        (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from)) && newParts.push({
                                from: p.from,
                                to: m.from
                            }),
                            (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to)) && newParts.push({
                                from: m.to,
                                to: p.to
                            }),
                            parts.splice.apply(parts, newParts),
                            j += newParts.length - 1
                    }
                }
            return parts
        }

        function collapsedSpanAt(line, ch) {
            var found, sps = sawCollapsedSpans && line.markedSpans;
            if (sps)
                for (var sp, i = 0; i < sps.length; ++i) sp = sps[i],
                    sp.marker.collapsed && (null == sp.from || sp.from < ch) && (null == sp.to || sp.to > ch) && (!found || found.width < sp.marker.width) && (found = sp.marker);
            return found
        }

        function collapsedSpanAtStart(line) {
            return collapsedSpanAt(line, -1)
        }

        function collapsedSpanAtEnd(line) {
            return collapsedSpanAt(line, line.text.length + 1)
        }

        function visualLine(doc, line) {
            for (var merged; merged = collapsedSpanAtStart(line);) line = getLine(doc, merged.find().from.line);
            return line
        }

        function lineIsHidden(doc, line) {
            var sps = sawCollapsedSpans && line.markedSpans;
            if (sps)
                for (var sp, i = 0; i < sps.length; ++i)
                    if (sp = sps[i], sp.marker.collapsed) {
                        if (null == sp.from) return !0;
                        if (!sp.marker.replacedWith && 0 == sp.from && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) return !0
                    }
        }

        function lineIsHiddenInner(doc, line, span) {
            if (null == span.to) {
                var end = span.marker.find().to,
                    endLine = getLine(doc, end.line);
                return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker))
            }
            if (span.marker.inclusiveRight && span.to == line.text.length) return !0;
            for (var sp, i = 0; i < line.markedSpans.length; ++i)
                if (sp = line.markedSpans[i], sp.marker.collapsed && !sp.marker.replacedWith && sp.from == span.to && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) return !0
        }

        function detachMarkedSpans(line) {
            var spans = line.markedSpans;
            if (spans) {
                for (var i = 0; i < spans.length; ++i) spans[i].marker.detachLine(line);
                line.markedSpans = null
            }
        }

        function attachMarkedSpans(line, spans) {
            if (spans) {
                for (var i = 0; i < spans.length; ++i) spans[i].marker.attachLine(line);
                line.markedSpans = spans
            }
        }

        function widgetOperation(f) {
            return function () {
                var withOp = !this.cm.curOp;
                withOp && startOperation(this.cm);
                try {
                    var result = f.apply(this, arguments)
                } finally {
                    withOp && endOperation(this.cm)
                }
                return result
            }
        }

        function widgetHeight(widget) {
            return null != widget.height ? widget.height : (widget.node.parentNode && 1 == widget.node.parentNode.nodeType || removeChildrenAndAdd(widget.cm.display.measure, elt("div", [widget.node], null, "position: relative")), widget.height = widget.node.offsetHeight)
        }

        function addLineWidget(cm, handle, node, options) {
            var widget = new LineWidget(cm, node, options);
            return widget.noHScroll && (cm.display.alignWidgets = !0),
                changeLine(cm, handle,
                    function (line) {
                        var widgets = line.widgets || (line.widgets = []);
                        if (null == widget.insertAt ? widgets.push(widget) : widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget), widget.line = line, !lineIsHidden(cm.doc, line) || widget.showIfHidden) {
                            var aboveVisible = heightAtLine(cm, line) < cm.doc.scrollTop;
                            updateLineHeight(line, line.height + widgetHeight(widget)),
                                aboveVisible && addToScrollPos(cm, 0, widget.height)
                        }
                        return !0
                    }),
                widget
        }

        function updateLine(line, text, markedSpans, estimateHeight) {
            line.text = text,
                line.stateAfter && (line.stateAfter = null),
                line.styles && (line.styles = null),
                null != line.order && (line.order = null),
                detachMarkedSpans(line),
                attachMarkedSpans(line, markedSpans);
            var estHeight = estimateHeight ? estimateHeight(line) : 1;
            estHeight != line.height && updateLineHeight(line, estHeight)
        }

        function cleanUpLine(line) {
            line.parent = null,
                detachMarkedSpans(line)
        }

        function runMode(cm, text, mode, state, f) {
            var flattenSpans = mode.flattenSpans;
            null == flattenSpans && (flattenSpans = cm.options.flattenSpans);
            var style, curStart = 0,
                curStyle = null,
                stream = new StringStream(text, cm.options.tabSize);
            for ("" == text && mode.blankLine && mode.blankLine(state); !stream.eol();) stream.pos > cm.options.maxHighlightLength ? (flattenSpans = !1, stream.pos = text.length, style = null) : style = mode.token(stream, state),
                flattenSpans && curStyle == style || (curStart < stream.start && f(stream.start, curStyle), curStart = stream.start, curStyle = style),
                stream.start = stream.pos;
            for (; curStart < stream.pos;) {
                var pos = Math.min(stream.pos, curStart + 5e4);
                f(pos, curStyle),
                    curStart = pos
            }
        }

        function highlightLine(cm, line, state) {
            var st = [cm.state.modeGen];
            runMode(cm, line.text, cm.doc.mode, state,
                function (end, style) {
                    st.push(end, style)
                });
            for (var o = 0; o < cm.state.overlays.length; ++o) {
                var overlay = cm.state.overlays[o],
                    i = 1,
                    at = 0;
                runMode(cm, line.text, overlay.mode, !0,
                    function (end, style) {
                        for (var start = i; end > at;) {
                            var i_end = st[i];
                            i_end > end && st.splice(i, 1, end, st[i + 1], i_end),
                                i += 2,
                                at = Math.min(end, i_end)
                        }
                        if (style)
                            if (overlay.opaque) st.splice(start, i - start, end, style),
                                i = start + 2;
                            else
                                for (; i > start; start += 2) {
                                    var cur = st[start + 1];
                                    st[start + 1] = cur ? cur + " " + style : style
                                }
                    })
            }
            return st
        }

        function getLineStyles(cm, line) {
            return line.styles && line.styles[0] == cm.state.modeGen || (line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)))),
                line.styles
        }

        function processLine(cm, line, state) {
            var mode = cm.doc.mode,
                stream = new StringStream(line.text, cm.options.tabSize);
            for ("" == line.text && mode.blankLine && mode.blankLine(state); !stream.eol() && stream.pos <= cm.options.maxHighlightLength;) mode.token(stream, state),
                stream.start = stream.pos
        }

        function interpretTokenStyle(style, builder) {
            if (!style) return null;
            for (;;) {
                var lineClass = style.match(/(?:^|\s)line-(background-)?(\S+)/);
                if (!lineClass) break;
                style = style.slice(0, lineClass.index) + style.slice(lineClass.index + lineClass[0].length);
                var prop = lineClass[1] ? "bgClass" : "textClass";
                null == builder[prop] ? builder[prop] = lineClass[2] : new RegExp("(?:^|s)" + lineClass[2] + "(?:$|s)").test(builder[prop]) || (builder[prop] += " " + lineClass[2])
            }
            return styleToClassCache[style] || (styleToClassCache[style] = "cm-" + style.replace(/ +/g, " cm-"))
        }

        function buildLineContent(cm, realLine, measure, copyWidgets) {
            for (var merged, line = realLine,
                    empty = !0; merged = collapsedSpanAtStart(line);) line = getLine(cm.doc, merged.find().from.line);
            var builder = {
                pre: elt("pre"),
                col: 0,
                pos: 0,
                measure: null,
                measuredSomething: !1,
                cm: cm,
                copyWidgets: copyWidgets
            };
            do {
                line.text && (empty = !1), builder.measure = line == realLine && measure, builder.pos = 0, builder.addToken = builder.measure ? buildTokenMeasure : buildToken, (ie || webkit) && cm.getOption("lineWrapping") && (builder.addToken = buildTokenSplitSpaces(builder.addToken));
                var next = insertLineContent(line, builder, getLineStyles(cm, line));
                measure && line == realLine && !builder.measuredSomething && (measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure)), builder.measuredSomething = !0), next && (line = getLine(cm.doc, next.to.line))
            } while (next);
            !measure || builder.measuredSomething || measure[0] || (measure[0] = builder.pre.appendChild(empty ? elt("span", " ") : zeroWidthElement(cm.display.measure))),
                builder.pre.firstChild || lineIsHidden(cm.doc, realLine) || builder.pre.appendChild(document.createTextNode(" "));
            var order;
            if (measure && ie && (order = getOrder(line))) {
                var l = order.length - 1;
                order[l].from == order[l].to && --l;
                var last = order[l],
                    prev = order[l - 1];
                if (last.from + 1 == last.to && prev && last.level < prev.level) {
                    var span = measure[builder.pos - 1];
                    span && span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure), span.nextSibling)
                }
            }
            var textClass = builder.textClass ? builder.textClass + " " + (realLine.textClass || "") : realLine.textClass;
            return textClass && (builder.pre.className = textClass),
                signal(cm, "renderLine", cm, realLine, builder.pre),
                builder
        }

        function buildToken(builder, text, style, startStyle, endStyle, title) {
            if (text) {
                if (tokenSpecialChars.test(text))
                    for (var content = document.createDocumentFragment(), pos = 0;;) {
                        tokenSpecialChars.lastIndex = pos;
                        var m = tokenSpecialChars.exec(text),
                            skipped = m ? m.index - pos : text.length - pos;
                        if (skipped && (content.appendChild(document.createTextNode(text.slice(pos, pos + skipped))), builder.col += skipped), !m) break;
                        if (pos += skipped + 1, "	" == m[0]) {
                            var tabSize = builder.cm.options.tabSize,
                                tabWidth = tabSize - builder.col % tabSize;
                            content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab")),
                                builder.col += tabWidth
                        } else {
                            var token = elt("span", "•", "cm-invalidchar");
                            token.title = "\\u" + m[0].charCodeAt(0).toString(16),
                                content.appendChild(token),
                                builder.col += 1
                        }
                    } else {
                        builder.col += text.length;
                        var content = document.createTextNode(text)
                    }
                if (style || startStyle || endStyle || builder.measure) {
                    var fullStyle = style || "";
                    startStyle && (fullStyle += startStyle),
                        endStyle && (fullStyle += endStyle);
                    var token = elt("span", [content], fullStyle);
                    return title && (token.title = title),
                        builder.pre.appendChild(token)
                }
                builder.pre.appendChild(content)
            }
        }

        function buildTokenMeasure(builder, text, style, startStyle, endStyle) {
            for (var wrapping = builder.cm.options.lineWrapping,
                    i = 0; i < text.length; ++i) {
                var ch = text.charAt(i),
                    start = 0 == i;
                ch >= "�" && "�" > ch && i < text.length - 1 ? (ch = text.slice(i, i + 2), ++i) : i && wrapping && spanAffectsWrapping(text, i) && builder.pre.appendChild(elt("wbr"));
                var old = builder.measure[builder.pos],
                    span = builder.measure[builder.pos] = buildToken(builder, ch, style, start && startStyle, i == text.length - 1 && endStyle);
                old && (span.leftSide = old.leftSide || old),
                    ie && wrapping && " " == ch && i && !/\s/.test(text.charAt(i - 1)) && i < text.length - 1 && !/\s/.test(text.charAt(i + 1)) && (span.style.whiteSpace = "normal"),
                    builder.pos += ch.length
            }
            text.length && (builder.measuredSomething = !0)
        }

        function buildTokenSplitSpaces(inner) {
            function split(old) {
                for (var out = " ",
                        i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : " ";
                return out += " "
            }
            return function (builder, text, style, startStyle, endStyle, title) {
                return inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title)
            }
        }

        function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
            var widget = !ignoreWidget && marker.replacedWith;
            if (widget && (builder.copyWidgets && (widget = widget.cloneNode(!0)), builder.pre.appendChild(widget), builder.measure)) {
                if (size) builder.measure[builder.pos] = widget;
                else {
                    var elt = zeroWidthElement(builder.cm.display.measure);
                    if ("bookmark" != marker.type || marker.insertLeft) {
                        if (builder.measure[builder.pos]) return;
                        builder.measure[builder.pos] = builder.pre.insertBefore(elt, widget)
                    } else builder.measure[builder.pos] = builder.pre.appendChild(elt)
                }
                builder.measuredSomething = !0
            }
            builder.pos += size
        }

        function insertLineContent(line, builder, styles) {
            var spans = line.markedSpans,
                allText = line.text,
                at = 0;
            if (spans)
                for (var style, spanStyle, spanEndStyle, spanStartStyle, title, collapsed, len = allText.length,
                        pos = 0,
                        i = 1,
                        text = "",
                        nextChange = 0;;) {
                    if (nextChange == pos) {
                        spanStyle = spanEndStyle = spanStartStyle = title = "",
                            collapsed = null,
                            nextChange = 1 / 0;
                        for (var foundBookmarks = [], j = 0; j < spans.length; ++j) {
                            var sp = spans[j],
                                m = sp.marker;
                            sp.from <= pos && (null == sp.to || sp.to > pos) ? (null != sp.to && nextChange > sp.to && (nextChange = sp.to, spanEndStyle = ""), m.className && (spanStyle += " " + m.className), m.startStyle && sp.from == pos && (spanStartStyle += " " + m.startStyle), m.endStyle && sp.to == nextChange && (spanEndStyle += " " + m.endStyle), m.title && !title && (title = m.title), m.collapsed && (!collapsed || collapsed.marker.size < m.size) && (collapsed = sp)) : sp.from > pos && nextChange > sp.from && (nextChange = sp.from),
                                "bookmark" == m.type && sp.from == pos && m.replacedWith && foundBookmarks.push(m)
                        }
                        if (collapsed && (collapsed.from || 0) == pos && (buildCollapsedSpan(builder, (null == collapsed.to ? len : collapsed.to) - pos, collapsed.marker, null == collapsed.from), null == collapsed.to)) return collapsed.marker.find();
                        if (!collapsed && foundBookmarks.length)
                            for (var j = 0; j < foundBookmarks.length; ++j) buildCollapsedSpan(builder, 0, foundBookmarks[j])
                    }
                    if (pos >= len) break;
                    for (var upto = Math.min(len, nextChange);;) {
                        if (text) {
                            var end = pos + text.length;
                            if (!collapsed) {
                                var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                                builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title)
                            }
                            if (end >= upto) {
                                text = text.slice(upto - pos),
                                    pos = upto;
                                break
                            }
                            pos = end,
                                spanStartStyle = ""
                        }
                        text = allText.slice(at, at = styles[i++]),
                            style = interpretTokenStyle(styles[i++], builder)
                    }
                } else
                    for (var i = 1; i < styles.length; i += 2) builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i + 1], builder))
        }

        function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {
            function spansFor(n) {
                return markedSpans ? markedSpans[n] : null
            }

            function update(line, text, spans) {
                updateLine(line, text, spans, estimateHeight),
                    signalLater(line, "change", line, change)
            }
            var from = change.from,
                to = change.to,
                text = change.text,
                firstLine = getLine(doc, from.line),
                lastLine = getLine(doc, to.line),
                lastText = lst(text),
                lastSpans = spansFor(text.length - 1),
                nlines = to.line - from.line;
            if (0 == from.ch && 0 == to.ch && "" == lastText) {
                for (var i = 0,
                        e = text.length - 1,
                        added = []; e > i; ++i) added.push(new Line(text[i], spansFor(i), estimateHeight));
                update(lastLine, lastLine.text, lastSpans),
                    nlines && doc.remove(from.line, nlines),
                    added.length && doc.insert(from.line, added)
            } else if (firstLine == lastLine)
                if (1 == text.length) update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
                else {
                    for (var added = [], i = 1, e = text.length - 1; e > i; ++i) added.push(new Line(text[i], spansFor(i), estimateHeight));
                    added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight)),
                        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0)),
                        doc.insert(from.line + 1, added)
                }
            else if (1 == text.length) update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0)),
                doc.remove(from.line + 1, nlines);
            else {
                update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0)),
                    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
                for (var i = 1,
                        e = text.length - 1,
                        added = []; e > i; ++i) added.push(new Line(text[i], spansFor(i), estimateHeight));
                nlines > 1 && doc.remove(from.line + 1, nlines - 1),
                    doc.insert(from.line + 1, added)
            }
            signalLater(doc, "change", doc, change),
                setSelection(doc, selAfter.anchor, selAfter.head, null, !0)
        }

        function LeafChunk(lines) {
            this.lines = lines,
                this.parent = null;
            for (var i = 0,
                    e = lines.length,
                    height = 0; e > i; ++i) lines[i].parent = this,
                height += lines[i].height;
            this.height = height
        }

        function BranchChunk(children) {
            this.children = children;
            for (var size = 0,
                    height = 0,
                    i = 0,
                    e = children.length; e > i; ++i) {
                var ch = children[i];
                size += ch.chunkSize(),
                    height += ch.height,
                    ch.parent = this
            }
            this.size = size,
                this.height = height,
                this.parent = null
        }

        function linkedDocs(doc, f, sharedHistOnly) {
            function propagate(doc, skip, sharedHist) {
                if (doc.linked)
                    for (var i = 0; i < doc.linked.length; ++i) {
                        var rel = doc.linked[i];
                        if (rel.doc != skip) {
                            var shared = sharedHist && rel.sharedHist;
                            (!sharedHistOnly || shared) && (f(rel.doc, shared), propagate(rel.doc, doc, shared))
                        }
                    }
            }
            propagate(doc, null, !0)
        }

        function attachDoc(cm, doc) {
            if (doc.cm) throw new Error("This document is already in use.");
            cm.doc = doc,
                doc.cm = cm,
                estimateLineHeights(cm),
                loadMode(cm),
                cm.options.lineWrapping || computeMaxLength(cm),
                cm.options.mode = doc.modeOption,
                regChange(cm)
        }

        function getLine(chunk, n) {
            for (n -= chunk.first; !chunk.lines;)
                for (var i = 0;; ++i) {
                    var child = chunk.children[i],
                        sz = child.chunkSize();
                    if (sz > n) {
                        chunk = child;
                        break
                    }
                    n -= sz
                }
            return chunk.lines[n]
        }

        function getBetween(doc, start, end) {
            var out = [],
                n = start.line;
            return doc.iter(start.line, end.line + 1,
                    function (line) {
                        var text = line.text;
                        n == end.line && (text = text.slice(0, end.ch)),
                            n == start.line && (text = text.slice(start.ch)),
                            out.push(text),
                            ++n
                    }),
                out
        }

        function getLines(doc, from, to) {
            var out = [];
            return doc.iter(from, to,
                    function (line) {
                        out.push(line.text)
                    }),
                out
        }

        function updateLineHeight(line, height) {
            for (var diff = height - line.height,
                    n = line; n; n = n.parent) n.height += diff
        }

        function lineNo(line) {
            if (null == line.parent) return null;
            for (var cur = line.parent,
                    no = indexOf(cur.lines, line), chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent)
                for (var i = 0; chunk.children[i] != cur; ++i) no += chunk.children[i].chunkSize();
            return no + cur.first
        }

        function lineAtHeight(chunk, h) {
            var n = chunk.first;
            outer: do {
                for (var i = 0,
                        e = chunk.children.length; e > i; ++i) {
                    var child = chunk.children[i],
                        ch = child.height;
                    if (ch > h) {
                        chunk = child;
                        continue outer
                    }
                    h -= ch,
                        n += child.chunkSize()
                }
                return n
            } while (!chunk.lines);
            for (var i = 0,
                    e = chunk.lines.length; e > i; ++i) {
                var line = chunk.lines[i],
                    lh = line.height;
                if (lh > h) break;
                h -= lh
            }
            return n + i
        }

        function heightAtLine(cm, lineObj) {
            lineObj = visualLine(cm.doc, lineObj);
            for (var h = 0,
                    chunk = lineObj.parent,
                    i = 0; i < chunk.lines.length; ++i) {
                var line = chunk.lines[i];
                if (line == lineObj) break;
                h += line.height
            }
            for (var p = chunk.parent; p; chunk = p, p = chunk.parent)
                for (var i = 0; i < p.children.length; ++i) {
                    var cur = p.children[i];
                    if (cur == chunk) break;
                    h += cur.height
                }
            return h
        }

        function getOrder(line) {
            var order = line.order;
            return null == order && (order = line.order = bidiOrdering(line.text)),
                order
        }

        function makeHistory(startGen) {
            return {
                done: [],
                undone: [],
                undoDepth: 1 / 0,
                lastTime: 0,
                lastOp: null,
                lastOrigin: null,
                generation: startGen || 1,
                maxGeneration: startGen || 1
            }
        }

        function attachLocalSpans(doc, change, from, to) {
            var existing = change["spans_" + doc.id],
                n = 0;
            doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to),
                function (line) {
                    line.markedSpans && ((existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans),
                        ++n
                })
        }

        function historyChangeFromChange(doc, change) {
            var from = {
                    line: change.from.line,
                    ch: change.from.ch
                },
                histChange = {
                    from: from,
                    to: changeEnd(change),
                    text: getBetween(doc, change.from, change.to)
                };
            return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1),
                linkedDocs(doc,
                    function (doc) {
                        attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1)
                    }, !0),
                histChange
        }

        function addToHistory(doc, change, selAfter, opId) {
            var hist = doc.history;
            hist.undone.length = 0;
            var time = +new Date,
                cur = lst(hist.done);
            if (cur && (hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && ("+" == change.origin.charAt(0) && doc.cm && hist.lastTime > time - doc.cm.options.historyEventDelay || "*" == change.origin.charAt(0)))) {
                var last = lst(cur.changes);
                posEq(change.from, change.to) && posEq(change.from, last.to) ? last.to = changeEnd(change) : cur.changes.push(historyChangeFromChange(doc, change)),
                    cur.anchorAfter = selAfter.anchor,
                    cur.headAfter = selAfter.head
            } else
                for (cur = {
                        changes: [historyChangeFromChange(doc, change)],
                        generation: hist.generation,
                        anchorBefore: doc.sel.anchor,
                        headBefore: doc.sel.head,
                        anchorAfter: selAfter.anchor,
                        headAfter: selAfter.head
                    },
                    hist.done.push(cur), hist.generation = ++hist.maxGeneration; hist.done.length > hist.undoDepth;) hist.done.shift();
            hist.lastTime = time,
                hist.lastOp = opId,
                hist.lastOrigin = change.origin
        }

        function removeClearedSpans(spans) {
            if (!spans) return null;
            for (var out, i = 0; i < spans.length; ++i) spans[i].marker.explicitlyCleared ? out || (out = spans.slice(0, i)) : out && out.push(spans[i]);
            return out ? out.length ? out : null : spans
        }

        function getOldSpans(doc, change) {
            var found = change["spans_" + doc.id];
            if (!found) return null;
            for (var i = 0,
                    nw = []; i < change.text.length; ++i) nw.push(removeClearedSpans(found[i]));
            return nw
        }

        function copyHistoryArray(events, newGroup) {
            for (var i = 0,
                    copy = []; i < events.length; ++i) {
                var event = events[i],
                    changes = event.changes,
                    newChanges = [];
                copy.push({
                    changes: newChanges,
                    anchorBefore: event.anchorBefore,
                    headBefore: event.headBefore,
                    anchorAfter: event.anchorAfter,
                    headAfter: event.headAfter
                });
                for (var j = 0; j < changes.length; ++j) {
                    var m, change = changes[j];
                    if (newChanges.push({
                            from: change.from,
                            to: change.to,
                            text: change.text
                        }), newGroup)
                        for (var prop in change)(m = prop.match(/^spans_(\d+)$/)) && indexOf(newGroup, Number(m[1])) > -1 && (lst(newChanges)[prop] = change[prop], delete change[prop])
                }
            }
            return copy
        }

        function rebaseHistSel(pos, from, to, diff) {
            to < pos.line ? pos.line += diff : from < pos.line && (pos.line = from, pos.ch = 0)
        }

        function rebaseHistArray(array, from, to, diff) {
            for (var i = 0; i < array.length; ++i) {
                for (var sub = array[i], ok = !0, j = 0; j < sub.changes.length; ++j) {
                    var cur = sub.changes[j];
                    if (sub.copied || (cur.from = copyPos(cur.from), cur.to = copyPos(cur.to)), to < cur.from.line) cur.from.line += diff,
                        cur.to.line += diff;
                    else if (from <= cur.to.line) {
                        ok = !1;
                        break
                    }
                }
                sub.copied || (sub.anchorBefore = copyPos(sub.anchorBefore), sub.headBefore = copyPos(sub.headBefore), sub.anchorAfter = copyPos(sub.anchorAfter), sub.readAfter = copyPos(sub.headAfter), sub.copied = !0),
                    ok ? (rebaseHistSel(sub.anchorBefore), rebaseHistSel(sub.headBefore), rebaseHistSel(sub.anchorAfter), rebaseHistSel(sub.headAfter)) : (array.splice(0, i + 1), i = 0)
            }
        }

        function rebaseHist(hist, change) {
            var from = change.from.line,
                to = change.to.line,
                diff = change.text.length - (to - from) - 1;
            rebaseHistArray(hist.done, from, to, diff),
                rebaseHistArray(hist.undone, from, to, diff)
        }

        function stopMethod() {
            e_stop(this)
        }

        function addStop(event) {
            return event.stop || (event.stop = stopMethod),
                event
        }

        function e_preventDefault(e) {
            e.preventDefault ? e.preventDefault() : e.returnValue = !1
        }

        function e_stopPropagation(e) {
            e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0
        }

        function e_defaultPrevented(e) {
            return null != e.defaultPrevented ? e.defaultPrevented : 0 == e.returnValue
        }

        function e_stop(e) {
            e_preventDefault(e),
                e_stopPropagation(e)
        }

        function e_target(e) {
            return e.target || e.srcElement
        }

        function e_button(e) {
            var b = e.which;
            return null == b && (1 & e.button ? b = 1 : 2 & e.button ? b = 3 : 4 & e.button && (b = 2)),
                mac && e.ctrlKey && 1 == b && (b = 3),
                b
        }

        function on(emitter, type, f) {
            if (emitter.addEventListener) emitter.addEventListener(type, f, !1);
            else if (emitter.attachEvent) emitter.attachEvent("on" + type, f);
            else {
                var map = emitter._handlers || (emitter._handlers = {}),
                    arr = map[type] || (map[type] = []);
                arr.push(f)
            }
        }

        function off(emitter, type, f) {
            if (emitter.removeEventListener) emitter.removeEventListener(type, f, !1);
            else if (emitter.detachEvent) emitter.detachEvent("on" + type, f);
            else {
                var arr = emitter._handlers && emitter._handlers[type];
                if (!arr) return;
                for (var i = 0; i < arr.length; ++i)
                    if (arr[i] == f) {
                        arr.splice(i, 1);
                        break
                    }
            }
        }

        function signal(emitter, type) {
            var arr = emitter._handlers && emitter._handlers[type];
            if (arr)
                for (var args = Array.prototype.slice.call(arguments, 2), i = 0; i < arr.length; ++i) arr[i].apply(null, args)
        }

        function signalLater(emitter, type) {
            function bnd(f) {
                return function () {
                    f.apply(null, args)
                }
            }
            var arr = emitter._handlers && emitter._handlers[type];
            if (arr) {
                var args = Array.prototype.slice.call(arguments, 2);
                delayedCallbacks || (++delayedCallbackDepth, delayedCallbacks = [], setTimeout(fireDelayed, 0));
                for (var i = 0; i < arr.length; ++i) delayedCallbacks.push(bnd(arr[i]))
            }
        }

        function signalDOMEvent(cm, e, override) {
            return signal(cm, override || e.type, cm, e),
                e_defaultPrevented(e) || e.codemirrorIgnore
        }

        function fireDelayed() {
            --delayedCallbackDepth;
            var delayed = delayedCallbacks;
            delayedCallbacks = null;
            for (var i = 0; i < delayed.length; ++i) delayed[i]()
        }

        function hasHandler(emitter, type) {
            var arr = emitter._handlers && emitter._handlers[type];
            return arr && arr.length > 0
        }

        function eventMixin(ctor) {
            ctor.prototype.on = function (type, f) {
                    on(this, type, f)
                },
                ctor.prototype.off = function (type, f) {
                    off(this, type, f)
                }
        }

        function Delayed() {
            this.id = null
        }

        function countColumn(string, end, tabSize, startIndex, startValue) {
            null == end && (end = string.search(/[^\s ]/), -1 == end && (end = string.length));
            for (var i = startIndex || 0,
                    n = startValue || 0; end > i; ++i) "	" == string.charAt(i) ? n += tabSize - n % tabSize : ++n;
            return n
        }

        function spaceStr(n) {
            for (; spaceStrs.length <= n;) spaceStrs.push(lst(spaceStrs) + " ");
            return spaceStrs[n]
        }

        function lst(arr) {
            return arr[arr.length - 1]
        }

        function selectInput(node) {
            if (ios) node.selectionStart = 0,
                node.selectionEnd = node.value.length;
            else try {
                node.select()
            } catch (_e) {}
        }

        function indexOf(collection, elt) {
            if (collection.indexOf) return collection.indexOf(elt);
            for (var i = 0,
                    e = collection.length; e > i; ++i)
                if (collection[i] == elt) return i;
            return -1
        }

        function createObj(base, props) {
            function Obj() {}
            Obj.prototype = base;
            var inst = new Obj;
            return props && copyObj(props, inst),
                inst
        }

        function copyObj(obj, target) {
            target || (target = {});
            for (var prop in obj) obj.hasOwnProperty(prop) && (target[prop] = obj[prop]);
            return target
        }

        function emptyArray(size) {
            for (var a = [], i = 0; size > i; ++i) a.push(void 0);
            return a
        }

        function bind(f) {
            var args = Array.prototype.slice.call(arguments, 1);
            return function () {
                return f.apply(null, args)
            }
        }

        function isWordChar(ch) {
            return /\w/.test(ch) || ch > "" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
        }

        function isEmpty(obj) {
            for (var n in obj)
                if (obj.hasOwnProperty(n) && obj[n]) return !1;
            return !0
        }

        function elt(tag, content, className, style) {
            var e = document.createElement(tag);
            if (className && (e.className = className), style && (e.style.cssText = style), "string" == typeof content) setTextContent(e, content);
            else if (content)
                for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
            return e
        }

        function removeChildren(e) {
            for (var count = e.childNodes.length; count > 0; --count) e.removeChild(e.firstChild);
            return e
        }

        function removeChildrenAndAdd(parent, e) {
            return removeChildren(parent).appendChild(e)
        }

        function setTextContent(e, str) {
            ie_lt9 ? (e.innerHTML = "", e.appendChild(document.createTextNode(str))) : e.textContent = str
        }

        function getRect(node) {
            return node.getBoundingClientRect()
        }

        function spanAffectsWrapping() {
            return !1
        }

        function scrollbarWidth(measure) {
            if (null != knownScrollbarWidth) return knownScrollbarWidth;
            var test = elt("div", null, null, "width: 50px; height: 50px; overflow-x: scroll");
            return removeChildrenAndAdd(measure, test),
                test.offsetWidth && (knownScrollbarWidth = test.offsetHeight - test.clientHeight),
                knownScrollbarWidth || 0
        }

        function zeroWidthElement(measure) {
            if (null == zwspSupported) {
                var test = elt("span", "​");
                removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")])),
                    0 != measure.firstChild.offsetHeight && (zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8)
            }
            return zwspSupported ? elt("span", "​") : elt("span", " ", null, "display: inline-block; width: 1px; margin-right: -1px")
        }

        function iterateBidiSections(order, from, to, f) {
            if (!order) return f(from, to, "ltr");
            for (var found = !1,
                    i = 0; i < order.length; ++i) {
                var part = order[i];
                (part.from < to && part.to > from || from == to && part.to == from) && (f(Math.max(part.from, from), Math.min(part.to, to), 1 == part.level ? "rtl" : "ltr"), found = !0)
            }
            found || f(from, to, "ltr")
        }

        function bidiLeft(part) {
            return part.level % 2 ? part.to : part.from
        }

        function bidiRight(part) {
            return part.level % 2 ? part.from : part.to
        }

        function lineLeft(line) {
            var order = getOrder(line);
            return order ? bidiLeft(order[0]) : 0
        }

        function lineRight(line) {
            var order = getOrder(line);
            return order ? bidiRight(lst(order)) : line.text.length
        }

        function lineStart(cm, lineN) {
            var line = getLine(cm.doc, lineN),
                visual = visualLine(cm.doc, line);
            visual != line && (lineN = lineNo(visual));
            var order = getOrder(visual),
                ch = order ? order[0].level % 2 ? lineRight(visual) : lineLeft(visual) : 0;
            return Pos(lineN, ch)
        }

        function lineEnd(cm, lineN) {
            for (var merged, line; merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN));) lineN = merged.find().to.line;
            var order = getOrder(line),
                ch = order ? order[0].level % 2 ? lineLeft(line) : lineRight(line) : line.text.length;
            return Pos(lineN, ch)
        }

        function compareBidiLevel(order, a, b) {
            var linedir = order[0].level;
            return a == linedir ? !0 : b == linedir ? !1 : b > a
        }

        function getBidiPartAt(order, pos) {
            for (var found, i = 0; i < order.length; ++i) {
                var cur = order[i];
                if (cur.from < pos && cur.to > pos) return bidiOther = null,
                    i;
                if (cur.from == pos || cur.to == pos) {
                    if (null != found) return compareBidiLevel(order, cur.level, order[found].level) ? (bidiOther = found, i) : (bidiOther = i, found);
                    found = i
                }
            }
            return bidiOther = null,
                found
        }

        function moveInLine(line, pos, dir, byUnit) {
            if (!byUnit) return pos + dir;
            do pos += dir;
            while (pos > 0 && isExtendingChar.test(line.text.charAt(pos)));
            return pos
        }

        function moveVisually(line, start, dir, byUnit) {
            var bidi = getOrder(line);
            if (!bidi) return moveLogically(line, start, dir, byUnit);
            for (var pos = getBidiPartAt(bidi, start), part = bidi[pos], target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);;) {
                if (target > part.from && target < part.to) return target;
                if (target == part.from || target == part.to) return getBidiPartAt(bidi, target) == pos ? target : (part = bidi[pos += dir], dir > 0 == part.level % 2 ? part.to : part.from);
                if (part = bidi[pos += dir], !part) return null;
                target = dir > 0 == part.level % 2 ? moveInLine(line, part.to, -1, byUnit) : moveInLine(line, part.from, 1, byUnit)
            }
        }

        function moveLogically(line, start, dir, byUnit) {
            var target = start + dir;
            if (byUnit)
                for (; target > 0 && isExtendingChar.test(line.text.charAt(target));) target += dir;
            return 0 > target || target > line.text.length ? null : target
        }
        var gecko = /gecko\/\d/i.test(navigator.userAgent),
            ie = /MSIE \d/.test(navigator.userAgent),
            ie_lt8 = ie && (null == document.documentMode || document.documentMode < 8),
            ie_lt9 = ie && (null == document.documentMode || document.documentMode < 9),
            webkit = /WebKit\//.test(navigator.userAgent),
            qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent),
            chrome = /Chrome\//.test(navigator.userAgent),
            opera = /Opera\//.test(navigator.userAgent),
            safari = /Apple Computer/.test(navigator.vendor),
            khtml = /KHTML\//.test(navigator.userAgent),
            mac_geLion = /Mac OS X 1\d\D([7-9]|\d\d)\D/.test(navigator.userAgent),
            mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent),
            phantom = /PhantomJS/.test(navigator.userAgent),
            ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent),
            mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent),
            mac = ios || /Mac/.test(navigator.platform),
            windows = /win/i.test(navigator.platform),
            opera_version = opera && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
        opera_version && (opera_version = Number(opera_version[1])),
            opera_version && opera_version >= 15 && (opera = !1, webkit = !0);
        var measureText, lastClick, lastDoubleClick, flipCtrlCmd = mac && (qtwebkit || opera && (null == opera_version || 12.11 > opera_version)),
            captureMiddleClick = gecko || ie && !ie_lt9,
            sawReadOnlySpans = !1,
            sawCollapsedSpans = !1,
            nextOpId = 0,
            lastDrop = 0,
            wheelSamples = 0,
            wheelPixelsPerUnit = null;
        ie ? wheelPixelsPerUnit = -.53 : gecko ? wheelPixelsPerUnit = 15 : chrome ? wheelPixelsPerUnit = -.7 : safari && (wheelPixelsPerUnit = -1 / 3);
        var maybeTransition, detectingSelectAll, lastStoppedKey = null,
            changeEnd = CodeMirror.changeEnd = function (change) {
                return change.text ? Pos(change.from.line + change.text.length - 1, lst(change.text).length + (1 == change.text.length ? change.from.ch : 0)) : change.to
            };
        CodeMirror.Pos = Pos,
            CodeMirror.prototype = {
                constructor: CodeMirror,
                focus: function () {
                    window.focus(),
                        focusInput(this),
                        onFocus(this),
                        fastPoll(this)
                },
                setOption: function (option, value) {
                    var options = this.options,
                        old = options[option];
                    (options[option] != value || "mode" == option) && (options[option] = value, optionHandlers.hasOwnProperty(option) && operation(this, optionHandlers[option])(this, value, old))
                },
                getOption: function (option) {
                    return this.options[option]
                },
                getDoc: function () {
                    return this.doc
                },
                addKeyMap: function (map, bottom) {
                    this.state.keyMaps[bottom ? "push" : "unshift"](map)
                },
                removeKeyMap: function (map) {
                    for (var maps = this.state.keyMaps,
                            i = 0; i < maps.length; ++i)
                        if (maps[i] == map || "string" != typeof maps[i] && maps[i].name == map) return maps.splice(i, 1), !0
                },
                addOverlay: operation(null,
                    function (spec, options) {
                        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
                        if (mode.startState) throw new Error("Overlays may not be stateful.");
                        this.state.overlays.push({
                                mode: mode,
                                modeSpec: spec,
                                opaque: options && options.opaque
                            }),
                            this.state.modeGen++,
                            regChange(this)
                    }),
                removeOverlay: operation(null,
                    function (spec) {
                        for (var overlays = this.state.overlays,
                                i = 0; i < overlays.length; ++i) {
                            var cur = overlays[i].modeSpec;
                            if (cur == spec || "string" == typeof spec && cur.name == spec) return overlays.splice(i, 1),
                                this.state.modeGen++,
                                void regChange(this)
                        }
                    }),
                indentLine: operation(null,
                    function (n, dir, aggressive) {
                        "string" != typeof dir && "number" != typeof dir && (dir = null == dir ? this.options.smartIndent ? "smart" : "prev" : dir ? "add" : "subtract"),
                            isLine(this.doc, n) && indentLine(this, n, dir, aggressive)
                    }),
                indentSelection: operation(null,
                    function (how) {
                        var sel = this.doc.sel;
                        if (posEq(sel.from, sel.to)) return indentLine(this, sel.from.line, how);
                        for (var e = sel.to.line - (sel.to.ch ? 0 : 1), i = sel.from.line; e >= i; ++i) indentLine(this, i, how)
                    }),
                getTokenAt: function (pos, precise) {
                    var doc = this.doc;
                    pos = clipPos(doc, pos);
                    for (var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode, line = getLine(doc, pos.line), stream = new StringStream(line.text, this.options.tabSize); stream.pos < pos.ch && !stream.eol();) {
                        stream.start = stream.pos;
                        var style = mode.token(stream, state)
                    }
                    return {
                        start: stream.start,
                        end: stream.pos,
                        string: stream.current(),
                        className: style || null,
                        type: style || null,
                        state: state
                    }
                },
                getTokenTypeAt: function (pos) {
                    pos = clipPos(this.doc, pos);
                    var styles = getLineStyles(this, getLine(this.doc, pos.line)),
                        before = 0,
                        after = (styles.length - 1) / 2,
                        ch = pos.ch;
                    if (0 == ch) return styles[2];
                    for (;;) {
                        var mid = before + after >> 1;
                        if ((mid ? styles[2 * mid - 1] : 0) >= ch) after = mid;
                        else {
                            if (!(styles[2 * mid + 1] < ch)) return styles[2 * mid + 2];
                            before = mid + 1
                        }
                    }
                },
                getModeAt: function (pos) {
                    var mode = this.doc.mode;
                    return mode.innerMode ? CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode : mode
                },
                getHelper: function (pos, type) {
                    if (helpers.hasOwnProperty(type)) {
                        var help = helpers[type],
                            mode = this.getModeAt(pos);
                        return mode[type] && help[mode[type]] || mode.helperType && help[mode.helperType] || help[mode.name]
                    }
                },
                getStateAfter: function (line, precise) {
                    var doc = this.doc;
                    return line = clipLine(doc, null == line ? doc.first + doc.size - 1 : line),
                        getStateBefore(this, line + 1, precise)
                },
                cursorCoords: function (start, mode) {
                    var pos, sel = this.doc.sel;
                    return pos = null == start ? sel.head : "object" == typeof start ? clipPos(this.doc, start) : start ? sel.from : sel.to,
                        cursorCoords(this, pos, mode || "page")
                },
                charCoords: function (pos, mode) {
                    return charCoords(this, clipPos(this.doc, pos), mode || "page")
                },
                coordsChar: function (coords, mode) {
                    return coords = fromCoordSystem(this, coords, mode || "page"),
                        coordsChar(this, coords.left, coords.top)
                },
                lineAtHeight: function (height, mode) {
                    return height = fromCoordSystem(this, {
                                top: height,
                                left: 0
                            },
                            mode || "page").top,
                        lineAtHeight(this.doc, height + this.display.viewOffset)
                },
                heightAtLine: function (line, mode) {
                    var end = !1,
                        last = this.doc.first + this.doc.size - 1;
                    line < this.doc.first ? line = this.doc.first : line > last && (line = last, end = !0);
                    var lineObj = getLine(this.doc, line);
                    return intoCoordSystem(this, getLine(this.doc, line), {
                            top: 0,
                            left: 0
                        },
                        mode || "page").top + (end ? lineObj.height : 0)
                },
                defaultTextHeight: function () {
                    return textHeight(this.display)
                },
                defaultCharWidth: function () {
                    return charWidth(this.display)
                },
                setGutterMarker: operation(null,
                    function (line, gutterID, value) {
                        return changeLine(this, line,
                            function (line) {
                                var markers = line.gutterMarkers || (line.gutterMarkers = {});
                                return markers[gutterID] = value, !value && isEmpty(markers) && (line.gutterMarkers = null), !0
                            })
                    }),
                clearGutter: operation(null,
                    function (gutterID) {
                        var cm = this,
                            doc = cm.doc,
                            i = doc.first;
                        doc.iter(function (line) {
                            line.gutterMarkers && line.gutterMarkers[gutterID] && (line.gutterMarkers[gutterID] = null, regChange(cm, i, i + 1), isEmpty(line.gutterMarkers) && (line.gutterMarkers = null)),
                                ++i
                        })
                    }),
                addLineClass: operation(null,
                    function (handle, where, cls) {
                        return changeLine(this, handle,
                            function (line) {
                                var prop = "text" == where ? "textClass" : "background" == where ? "bgClass" : "wrapClass";
                                if (line[prop]) {
                                    if (new RegExp("(?:^|\\s)" + cls + "(?:$|\\s)").test(line[prop])) return !1;
                                    line[prop] += " " + cls
                                } else line[prop] = cls;
                                return !0
                            })
                    }),
                removeLineClass: operation(null,
                    function (handle, where, cls) {
                        return changeLine(this, handle,
                            function (line) {
                                var prop = "text" == where ? "textClass" : "background" == where ? "bgClass" : "wrapClass",
                                    cur = line[prop];
                                if (!cur) return !1;
                                if (null == cls) line[prop] = null;
                                else {
                                    var found = cur.match(new RegExp("(?:^|\\s+)" + cls + "(?:$|\\s+)"));
                                    if (!found) return !1;
                                    var end = found.index + found[0].length;
                                    line[prop] = cur.slice(0, found.index) + (found.index && end != cur.length ? " " : "") + cur.slice(end) || null
                                }
                                return !0
                            })
                    }),
                addLineWidget: operation(null,
                    function (handle, node, options) {
                        return addLineWidget(this, handle, node, options)
                    }),
                removeLineWidget: function (widget) {
                    widget.clear()
                },
                lineInfo: function (line) {
                    if ("number" == typeof line) {
                        if (!isLine(this.doc, line)) return null;
                        var n = line;
                        if (line = getLine(this.doc, line), !line) return null
                    } else {
                        var n = lineNo(line);
                        if (null == n) return null
                    }
                    return {
                        line: n,
                        handle: line,
                        text: line.text,
                        gutterMarkers: line.gutterMarkers,
                        textClass: line.textClass,
                        bgClass: line.bgClass,
                        wrapClass: line.wrapClass,
                        widgets: line.widgets
                    }
                },
                getViewport: function () {
                    return {
                        from: this.display.showingFrom,
                        to: this.display.showingTo
                    }
                },
                addWidget: function (pos, node, scroll, vert, horiz) {
                    var display = this.display;
                    pos = cursorCoords(this, clipPos(this.doc, pos));
                    var top = pos.bottom,
                        left = pos.left;
                    if (node.style.position = "absolute", display.sizer.appendChild(node), "over" == vert) top = pos.top;
                    else if ("above" == vert || "near" == vert) {
                        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
                            hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
                        ("above" == vert || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight ? top = pos.top - node.offsetHeight : pos.bottom + node.offsetHeight <= vspace && (top = pos.bottom),
                            left + node.offsetWidth > hspace && (left = hspace - node.offsetWidth)
                    }
                    node.style.top = top + "px",
                        node.style.left = node.style.right = "",
                        "right" == horiz ? (left = display.sizer.clientWidth - node.offsetWidth, node.style.right = "0px") : ("left" == horiz ? left = 0 : "middle" == horiz && (left = (display.sizer.clientWidth - node.offsetWidth) / 2), node.style.left = left + "px"),
                        scroll && scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight)
                },
                triggerOnKeyDown: operation(null, onKeyDown),
                execCommand: function (cmd) {
                    return commands[cmd](this)
                },
                findPosH: function (from, amount, unit, visually) {
                    var dir = 1;
                    0 > amount && (dir = -1, amount = -amount);
                    for (var i = 0,
                            cur = clipPos(this.doc, from); amount > i && (cur = findPosH(this.doc, cur, dir, unit, visually), !cur.hitSide); ++i);
                    return cur
                },
                moveH: operation(null,
                    function (dir, unit) {
                        var pos, sel = this.doc.sel;
                        pos = sel.shift || sel.extend || posEq(sel.from, sel.to) ? findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually) : 0 > dir ? sel.from : sel.to,
                            extendSelection(this.doc, pos, pos, dir)
                    }),
                deleteH: operation(null,
                    function (dir, unit) {
                        var sel = this.doc.sel;
                        posEq(sel.from, sel.to) ? replaceRange(this.doc, "", sel.from, findPosH(this.doc, sel.head, dir, unit, !1), "+delete") : replaceRange(this.doc, "", sel.from, sel.to, "+delete"),
                            this.curOp.userSelChange = !0
                    }),
                findPosV: function (from, amount, unit, goalColumn) {
                    var dir = 1,
                        x = goalColumn;
                    0 > amount && (dir = -1, amount = -amount);
                    for (var i = 0,
                            cur = clipPos(this.doc, from); amount > i; ++i) {
                        var coords = cursorCoords(this, cur, "div");
                        if (null == x ? x = coords.left : coords.left = x, cur = findPosV(this, coords, dir, unit), cur.hitSide) break
                    }
                    return cur
                },
                moveV: operation(null,
                    function (dir, unit) {
                        var sel = this.doc.sel,
                            pos = cursorCoords(this, sel.head, "div");
                        null != sel.goalColumn && (pos.left = sel.goalColumn);
                        var target = findPosV(this, pos, dir, unit);
                        "page" == unit && addToScrollPos(this, 0, charCoords(this, target, "div").top - pos.top),
                            extendSelection(this.doc, target, target, dir),
                            sel.goalColumn = pos.left
                    }),
                toggleOverwrite: function (value) {
                    (null == value || value != this.state.overwrite) && ((this.state.overwrite = !this.state.overwrite) ? this.display.cursor.className += " CodeMirror-overwrite" : this.display.cursor.className = this.display.cursor.className.replace(" CodeMirror-overwrite", ""))
                },
                hasFocus: function () {
                    return this.state.focused
                },
                scrollTo: operation(null,
                    function (x, y) {
                        updateScrollPos(this, x, y)
                    }),
                getScrollInfo: function () {
                    var scroller = this.display.scroller,
                        co = scrollerCutOff;
                    return {
                        left: scroller.scrollLeft,
                        top: scroller.scrollTop,
                        height: scroller.scrollHeight - co,
                        width: scroller.scrollWidth - co,
                        clientHeight: scroller.clientHeight - co,
                        clientWidth: scroller.clientWidth - co
                    }
                },
                scrollIntoView: operation(null,
                    function (range, margin) {
                        null == range ? range = {
                                from: this.doc.sel.head,
                                to: null
                            } : "number" == typeof range ? range = {
                                from: Pos(range, 0),
                                to: null
                            } : null == range.from && (range = {
                                from: range,
                                to: null
                            }),
                            range.to || (range.to = range.from),
                            margin || (margin = 0);
                        var coords = range;
                        null != range.from.line && (this.curOp.scrollToPos = {
                                from: range.from,
                                to: range.to,
                                margin: margin
                            },
                            coords = {
                                from: cursorCoords(this, range.from),
                                to: cursorCoords(this, range.to)
                            });
                        var sPos = calculateScrollPos(this, Math.min(coords.from.left, coords.to.left), Math.min(coords.from.top, coords.to.top) - margin, Math.max(coords.from.right, coords.to.right), Math.max(coords.from.bottom, coords.to.bottom) + margin);
                        updateScrollPos(this, sPos.scrollLeft, sPos.scrollTop)
                    }),
                setSize: operation(null,
                    function (width, height) {
                        function interpret(val) {
                            return "number" == typeof val || /^\d+$/.test(String(val)) ? val + "px" : val
                        }
                        null != width && (this.display.wrapper.style.width = interpret(width)),
                            null != height && (this.display.wrapper.style.height = interpret(height)),
                            this.options.lineWrapping && (this.display.measureLineCache.length = this.display.measureLineCachePos = 0),
                            this.curOp.forceUpdate = !0
                    }),
                operation: function (f) {
                    return runInOp(this, f)
                },
                refresh: operation(null,
                    function () {
                        var badHeight = null == this.display.cachedTextHeight;
                        clearCaches(this),
                            updateScrollPos(this, this.doc.scrollLeft, this.doc.scrollTop),
                            regChange(this),
                            badHeight && estimateLineHeights(this)
                    }),
                swapDoc: operation(null,
                    function (doc) {
                        var old = this.doc;
                        return old.cm = null,
                            attachDoc(this, doc),
                            clearCaches(this),
                            resetInput(this, !0),
                            updateScrollPos(this, doc.scrollLeft, doc.scrollTop),
                            signalLater(this, "swapDoc", this, old),
                            old
                    }),
                getInputField: function () {
                    return this.display.input
                },
                getWrapperElement: function () {
                    return this.display.wrapper
                },
                getScrollerElement: function () {
                    return this.display.scroller
                },
                getGutterElement: function () {
                    return this.display.gutters
                }
            },
            eventMixin(CodeMirror);
        var optionHandlers = CodeMirror.optionHandlers = {},
            defaults = CodeMirror.defaults = {},
            Init = CodeMirror.Init = {
                toString: function () {
                    return "CodeMirror.Init"
                }
            };
        option("value", "",
                function (cm, val) {
                    cm.setValue(val)
                }, !0),
            option("mode", null,
                function (cm, val) {
                    cm.doc.modeOption = val,
                        loadMode(cm)
                }, !0),
            option("indentUnit", 2, loadMode, !0),
            option("indentWithTabs", !1),
            option("smartIndent", !0),
            option("tabSize", 4,
                function (cm) {
                    loadMode(cm),
                        clearCaches(cm),
                        regChange(cm)
                }, !0),
            option("electricChars", !0),
            option("rtlMoveVisually", !windows),
            option("theme", "default",
                function (cm) {
                    themeChanged(cm),
                        guttersChanged(cm)
                }, !0),
            option("keyMap", "default", keyMapChanged),
            option("extraKeys", null),
            option("onKeyEvent", null),
            option("onDragEvent", null),
            option("lineWrapping", !1, wrappingChanged, !0),
            option("gutters", [],
                function (cm) {
                    setGuttersForLineNumbers(cm.options),
                        guttersChanged(cm)
                }, !0),
            option("fixedGutter", !0,
                function (cm, val) {
                    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0",
                        cm.refresh()
                }, !0),
            option("coverGutterNextToScrollbar", !1, updateScrollbars, !0),
            option("lineNumbers", !1,
                function (cm) {
                    setGuttersForLineNumbers(cm.options),
                        guttersChanged(cm)
                }, !0),
            option("firstLineNumber", 1, guttersChanged, !0),
            option("lineNumberFormatter",
                function (integer) {
                    return integer
                },
                guttersChanged, !0),
            option("showCursorWhenSelecting", !1, updateSelection, !0),
            option("resetSelectionOnContextMenu", !0),
            option("readOnly", !1,
                function (cm, val) {
                    "nocursor" == val ? (onBlur(cm), cm.display.input.blur()) : val || resetInput(cm, !0)
                }),
            option("dragDrop", !0),
            option("cursorBlinkRate", 530),
            option("cursorScrollMargin", 0),
            option("cursorHeight", 1),
            option("workTime", 100),
            option("workDelay", 100),
            option("flattenSpans", !0),
            option("pollInterval", 100),
            option("undoDepth", 40,
                function (cm, val) {
                    cm.doc.history.undoDepth = val
                }),
            option("historyEventDelay", 500),
            option("viewportMargin", 10,
                function (cm) {
                    cm.refresh()
                }, !0),
            option("maxHighlightLength", 1e4,
                function (cm) {
                    loadMode(cm),
                        cm.refresh()
                }, !0),
            option("crudeMeasuringFrom", 1e4),
            option("moveInputWithCursor", !0,
                function (cm, val) {
                    val || (cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0)
                }),
            option("tabindex", null,
                function (cm, val) {
                    cm.display.input.tabIndex = val || ""
                }),
            option("autofocus", null);
        var modes = CodeMirror.modes = {},
            mimeModes = CodeMirror.mimeModes = {};
        CodeMirror.defineMode = function (name, mode) {
                if (CodeMirror.defaults.mode || "null" == name || (CodeMirror.defaults.mode = name), arguments.length > 2) {
                    mode.dependencies = [];
                    for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i])
                }
                modes[name] = mode
            },
            CodeMirror.defineMIME = function (mime, spec) {
                mimeModes[mime] = spec
            },
            CodeMirror.resolveMode = function (spec) {
                if ("string" == typeof spec && mimeModes.hasOwnProperty(spec)) spec = mimeModes[spec];
                else if (spec && "string" == typeof spec.name && mimeModes.hasOwnProperty(spec.name)) {
                    var found = mimeModes[spec.name];
                    spec = createObj(found, spec),
                        spec.name = found.name
                } else if ("string" == typeof spec && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) return CodeMirror.resolveMode("application/xml");
                return "string" == typeof spec ? {
                    name: spec
                } : spec || {
                    name: "null"
                }
            },
            CodeMirror.getMode = function (options, spec) {
                var spec = CodeMirror.resolveMode(spec),
                    mfactory = modes[spec.name];
                if (!mfactory) return CodeMirror.getMode(options, "text/plain");
                var modeObj = mfactory(options, spec);
                if (modeExtensions.hasOwnProperty(spec.name)) {
                    var exts = modeExtensions[spec.name];
                    for (var prop in exts) exts.hasOwnProperty(prop) && (modeObj.hasOwnProperty(prop) && (modeObj["_" + prop] = modeObj[prop]), modeObj[prop] = exts[prop])
                }
                return modeObj.name = spec.name,
                    modeObj
            },
            CodeMirror.defineMode("null",
                function () {
                    return {
                        token: function (stream) {
                            stream.skipToEnd()
                        }
                    }
                }),
            CodeMirror.defineMIME("text/plain", "null");
        var modeExtensions = CodeMirror.modeExtensions = {};
        CodeMirror.extendMode = function (mode, properties) {
                var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
                copyObj(properties, exts)
            },
            CodeMirror.defineExtension = function (name, func) {
                CodeMirror.prototype[name] = func
            },
            CodeMirror.defineDocExtension = function (name, func) {
                Doc.prototype[name] = func
            },
            CodeMirror.defineOption = option;
        var initHooks = [];
        CodeMirror.defineInitHook = function (f) {
            initHooks.push(f)
        };
        var helpers = CodeMirror.helpers = {};
        CodeMirror.registerHelper = function (type, name, value) {
                helpers.hasOwnProperty(type) || (helpers[type] = CodeMirror[type] = {}),
                    helpers[type][name] = value
            },
            CodeMirror.isWordChar = isWordChar,
            CodeMirror.copyState = copyState,
            CodeMirror.startState = startState,
            CodeMirror.innerMode = function (mode, state) {
                for (; mode.innerMode;) {
                    var info = mode.innerMode(state);
                    if (!info || info.mode == mode) break;
                    state = info.state,
                        mode = info.mode
                }
                return info || {
                    mode: mode,
                    state: state
                }
            };
        var commands = CodeMirror.commands = {
                selectAll: function (cm) {
                    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()))
                },
                killLine: function (cm) {
                    var from = cm.getCursor(!0),
                        to = cm.getCursor(!1),
                        sel = !posEq(from, to);
                    sel || cm.getLine(from.line).length != from.ch ? cm.replaceRange("", from, sel ? to : Pos(from.line), "+delete") : cm.replaceRange("", from, Pos(from.line + 1, 0), "+delete")
                },
                deleteLine: function (cm) {
                    var l = cm.getCursor().line;
                    cm.replaceRange("", Pos(l, 0), Pos(l), "+delete")
                },
                delLineLeft: function (cm) {
                    var cur = cm.getCursor();
                    cm.replaceRange("", Pos(cur.line, 0), cur, "+delete")
                },
                undo: function (cm) {
                    cm.undo()
                },
                redo: function (cm) {
                    cm.redo()
                },
                goDocStart: function (cm) {
                    cm.extendSelection(Pos(cm.firstLine(), 0))
                },
                goDocEnd: function (cm) {
                    cm.extendSelection(Pos(cm.lastLine()))
                },
                goLineStart: function (cm) {
                    cm.extendSelection(lineStart(cm, cm.getCursor().line))
                },
                goLineStartSmart: function (cm) {
                    var cur = cm.getCursor(),
                        start = lineStart(cm, cur.line),
                        line = cm.getLineHandle(start.line),
                        order = getOrder(line);
                    if (order && 0 != order[0].level) cm.extendSelection(start);
                    else {
                        var firstNonWS = Math.max(0, line.text.search(/\S/)),
                            inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;
                        cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS))
                    }
                },
                goLineEnd: function (cm) {
                    cm.extendSelection(lineEnd(cm, cm.getCursor().line))
                },
                goLineRight: function (cm) {
                    var top = cm.charCoords(cm.getCursor(), "div").top + 5;
                    cm.extendSelection(cm.coordsChar({
                            left: cm.display.lineDiv.offsetWidth + 100,
                            top: top
                        },
                        "div"))
                },
                goLineLeft: function (cm) {
                    var top = cm.charCoords(cm.getCursor(), "div").top + 5;
                    cm.extendSelection(cm.coordsChar({
                            left: 0,
                            top: top
                        },
                        "div"))
                },
                goLineUp: function (cm) {
                    cm.moveV(-1, "line")
                },
                goLineDown: function (cm) {
                    cm.moveV(1, "line")
                },
                goPageUp: function (cm) {
                    cm.moveV(-1, "page")
                },
                goPageDown: function (cm) {
                    cm.moveV(1, "page")
                },
                goCharLeft: function (cm) {
                    cm.moveH(-1, "char")
                },
                goCharRight: function (cm) {
                    cm.moveH(1, "char")
                },
                goColumnLeft: function (cm) {
                    cm.moveH(-1, "column")
                },
                goColumnRight: function (cm) {
                    cm.moveH(1, "column")
                },
                goWordLeft: function (cm) {
                    cm.moveH(-1, "word")
                },
                goGroupRight: function (cm) {
                    cm.moveH(1, "group")
                },
                goGroupLeft: function (cm) {
                    cm.moveH(-1, "group")
                },
                goWordRight: function (cm) {
                    cm.moveH(1, "word")
                },
                delCharBefore: function (cm) {
                    cm.deleteH(-1, "char")
                },
                delCharAfter: function (cm) {
                    cm.deleteH(1, "char")
                },
                delWordBefore: function (cm) {
                    cm.deleteH(-1, "word")
                },
                delWordAfter: function (cm) {
                    cm.deleteH(1, "word")
                },
                delGroupBefore: function (cm) {
                    cm.deleteH(-1, "group")
                },
                delGroupAfter: function (cm) {
                    cm.deleteH(1, "group")
                },
                indentAuto: function (cm) {
                    cm.indentSelection("smart")
                },
                indentMore: function (cm) {
                    cm.indentSelection("add")
                },
                indentLess: function (cm) {
                    cm.indentSelection("subtract")
                },
                insertTab: function (cm) {
                    cm.replaceSelection("	", "end", "+input")
                },
                defaultTab: function (cm) {
                    cm.somethingSelected() ? cm.indentSelection("add") : cm.replaceSelection("	", "end", "+input")
                },
                transposeChars: function (cm) {
                    var cur = cm.getCursor(),
                        line = cm.getLine(cur.line);
                    cur.ch > 0 && cur.ch < line.length - 1 && cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1), Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1))
                },
                newlineAndIndent: function (cm) {
                    operation(cm,
                        function () {
                            cm.replaceSelection("\n", "end", "+input"),
                                cm.indentLine(cm.getCursor().line, null, !0)
                        })()
                },
                toggleOverwrite: function (cm) {
                    cm.toggleOverwrite()
                }
            },
            keyMap = CodeMirror.keyMap = {};
        keyMap.basic = {
                Left: "goCharLeft",
                Right: "goCharRight",
                Up: "goLineUp",
                Down: "goLineDown",
                End: "goLineEnd",
                Home: "goLineStartSmart",
                PageUp: "goPageUp",
                PageDown: "goPageDown",
                Delete: "delCharAfter",
                Backspace: "delCharBefore",
                "Shift-Backspace": "delCharBefore",
                Tab: "defaultTab",
                "Shift-Tab": "indentAuto",
                Enter: "newlineAndIndent",
                Insert: "toggleOverwrite"
            },
            keyMap.pcDefault = {
                "Ctrl-A": "selectAll",
                "Ctrl-D": "deleteLine",
                "Ctrl-Z": "undo",
                "Shift-Ctrl-Z": "redo",
                "Ctrl-Y": "redo",
                "Ctrl-Home": "goDocStart",
                "Alt-Up": "goDocStart",
                "Ctrl-End": "goDocEnd",
                "Ctrl-Down": "goDocEnd",
                "Ctrl-Left": "goGroupLeft",
                "Ctrl-Right": "goGroupRight",
                "Alt-Left": "goLineStart",
                "Alt-Right": "goLineEnd",
                "Ctrl-Backspace": "delGroupBefore",
                "Ctrl-Delete": "delGroupAfter",
                "Ctrl-S": "save",
                "Ctrl-F": "find",
                "Ctrl-G": "findNext",
                "Shift-Ctrl-G": "findPrev",
                "Shift-Ctrl-F": "replace",
                "Shift-Ctrl-R": "replaceAll",
                "Ctrl-[": "indentLess",
                "Ctrl-]": "indentMore",
                fallthrough: "basic"
            },
            keyMap.macDefault = {
                "Cmd-A": "selectAll",
                "Cmd-D": "deleteLine",
                "Cmd-Z": "undo",
                "Shift-Cmd-Z": "redo",
                "Cmd-Y": "redo",
                "Cmd-Up": "goDocStart",
                "Cmd-End": "goDocEnd",
                "Cmd-Down": "goDocEnd",
                "Alt-Left": "goGroupLeft",
                "Alt-Right": "goGroupRight",
                "Cmd-Left": "goLineStart",
                "Cmd-Right": "goLineEnd",
                "Alt-Backspace": "delGroupBefore",
                "Ctrl-Alt-Backspace": "delGroupAfter",
                "Alt-Delete": "delGroupAfter",
                "Cmd-S": "save",
                "Cmd-F": "find",
                "Cmd-G": "findNext",
                "Shift-Cmd-G": "findPrev",
                "Cmd-Alt-F": "replace",
                "Shift-Cmd-Alt-F": "replaceAll",
                "Cmd-[": "indentLess",
                "Cmd-]": "indentMore",
                "Cmd-Backspace": "delLineLeft",
                fallthrough: ["basic", "emacsy"]
            },
            keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault,
            keyMap.emacsy = {
                "Ctrl-F": "goCharRight",
                "Ctrl-B": "goCharLeft",
                "Ctrl-P": "goLineUp",
                "Ctrl-N": "goLineDown",
                "Alt-F": "goWordRight",
                "Alt-B": "goWordLeft",
                "Ctrl-A": "goLineStart",
                "Ctrl-E": "goLineEnd",
                "Ctrl-V": "goPageDown",
                "Shift-Ctrl-V": "goPageUp",
                "Ctrl-D": "delCharAfter",
                "Ctrl-H": "delCharBefore",
                "Alt-D": "delWordAfter",
                "Alt-Backspace": "delWordBefore",
                "Ctrl-K": "killLine",
                "Ctrl-T": "transposeChars"
            },
            CodeMirror.lookupKey = lookupKey,
            CodeMirror.isModifierKey = isModifierKey,
            CodeMirror.keyName = keyName,
            CodeMirror.fromTextArea = function (textarea, options) {
                function save() {
                    textarea.value = cm.getValue()
                }
                if (options || (options = {}), options.value = textarea.value, !options.tabindex && textarea.tabindex && (options.tabindex = textarea.tabindex), !options.placeholder && textarea.placeholder && (options.placeholder = textarea.placeholder), null == options.autofocus) {
                    var hasFocus = document.body;
                    try {
                        hasFocus = document.activeElement
                    } catch (e) {}
                    options.autofocus = hasFocus == textarea || null != textarea.getAttribute("autofocus") && hasFocus == document.body
                }
                if (textarea.form && (on(textarea.form, "submit", save), !options.leaveSubmitMethodAlone)) {
                    var form = textarea.form,
                        realSubmit = form.submit;
                    try {
                        var wrappedSubmit = form.submit = function () {
                            save(),
                                form.submit = realSubmit,
                                form.submit(),
                                form.submit = wrappedSubmit
                        }
                    } catch (e) {}
                }
                textarea.style.display = "none";
                var cm = CodeMirror(function (node) {
                        textarea.parentNode.insertBefore(node, textarea.nextSibling)
                    },
                    options);
                return cm.save = save,
                    cm.getTextArea = function () {
                        return textarea
                    },
                    cm.toTextArea = function () {
                        save(),
                            textarea.parentNode.removeChild(cm.getWrapperElement()),
                            textarea.style.display = "",
                            textarea.form && (off(textarea.form, "submit", save), "function" == typeof textarea.form.submit && (textarea.form.submit = realSubmit))
                    },
                    cm
            },
            StringStream.prototype = {
                eol: function () {
                    return this.pos >= this.string.length
                },
                sol: function () {
                    return 0 == this.pos
                },
                peek: function () {
                    return this.string.charAt(this.pos) || void 0
                },
                next: function () {
                    return this.pos < this.string.length ? this.string.charAt(this.pos++) : void 0
                },
                eat: function (match) {
                    var ch = this.string.charAt(this.pos);
                    if ("string" == typeof match) var ok = ch == match;
                    else var ok = ch && (match.test ? match.test(ch) : match(ch));
                    return ok ? (++this.pos, ch) : void 0
                },
                eatWhile: function (match) {
                    for (var start = this.pos; this.eat(match););
                    return this.pos > start
                },
                eatSpace: function () {
                    for (var start = this.pos;
                        /[\s ]/.test(this.string.charAt(this.pos));) ++this.pos;
                    return this.pos > start
                },
                skipToEnd: function () {
                    this.pos = this.string.length
                },
                skipTo: function (ch) {
                    var found = this.string.indexOf(ch, this.pos);
                    return found > -1 ? (this.pos = found, !0) : void 0
                },
                backUp: function (n) {
                    this.pos -= n
                },
                column: function () {
                    return this.lastColumnPos < this.start && (this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start),
                        this.lastColumnValue
                },
                indentation: function () {
                    return countColumn(this.string, null, this.tabSize)
                },
                match: function (pattern, consume, caseInsensitive) {
                    if ("string" != typeof pattern) {
                        var match = this.string.slice(this.pos).match(pattern);
                        return match && match.index > 0 ? null : (match && consume !== !1 && (this.pos += match[0].length), match)
                    }
                    var cased = function (str) {
                            return caseInsensitive ? str.toLowerCase() : str
                        },
                        substr = this.string.substr(this.pos, pattern.length);
                    return cased(substr) == cased(pattern) ? (consume !== !1 && (this.pos += pattern.length), !0) : void 0
                },
                current: function () {
                    return this.string.slice(this.start, this.pos)
                }
            },
            CodeMirror.StringStream = StringStream,
            CodeMirror.TextMarker = TextMarker,
            eventMixin(TextMarker),
            TextMarker.prototype.clear = function () {
                if (!this.explicitlyCleared) {
                    var cm = this.doc.cm,
                        withOp = cm && !cm.curOp;
                    if (withOp && startOperation(cm), hasHandler(this, "clear")) {
                        var found = this.find();
                        found && signalLater(this, "clear", found.from, found.to)
                    }
                    for (var min = null,
                            max = null,
                            i = 0; i < this.lines.length; ++i) {
                        var line = this.lines[i],
                            span = getMarkedSpanFor(line.markedSpans, this);
                        null != span.to && (max = lineNo(line)),
                            line.markedSpans = removeMarkedSpan(line.markedSpans, span),
                            null != span.from ? min = lineNo(line) : this.collapsed && !lineIsHidden(this.doc, line) && cm && updateLineHeight(line, textHeight(cm.display))
                    }
                    if (cm && this.collapsed && !cm.options.lineWrapping)
                        for (var i = 0; i < this.lines.length; ++i) {
                            var visual = visualLine(cm.doc, this.lines[i]),
                                len = lineLength(cm.doc, visual);
                            len > cm.display.maxLineLength && (cm.display.maxLine = visual, cm.display.maxLineLength = len, cm.display.maxLineChanged = !0)
                        }
                    null != min && cm && regChange(cm, min, max + 1),
                        this.lines.length = 0,
                        this.explicitlyCleared = !0,
                        this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, cm && reCheckSelection(cm)),
                        withOp && endOperation(cm)
                }
            },
            TextMarker.prototype.find = function () {
                for (var from, to, i = 0; i < this.lines.length; ++i) {
                    var line = this.lines[i],
                        span = getMarkedSpanFor(line.markedSpans, this);
                    if (null != span.from || null != span.to) {
                        var found = lineNo(line);
                        null != span.from && (from = Pos(found, span.from)),
                            null != span.to && (to = Pos(found, span.to))
                    }
                }
                return "bookmark" == this.type ? from : from && {
                    from: from,
                    to: to
                }
            },
            TextMarker.prototype.changed = function () {
                var pos = this.find(),
                    cm = this.doc.cm;
                if (pos && cm) {
                    "bookmark" != this.type && (pos = pos.from);
                    var line = getLine(this.doc, pos.line);
                    if (clearCachedMeasurement(cm, line), pos.line >= cm.display.showingFrom && pos.line < cm.display.showingTo) {
                        for (var node = cm.display.lineDiv.firstChild; node; node = node.nextSibling)
                            if (node.lineObj == line) {
                                node.offsetHeight != line.height && updateLineHeight(line, node.offsetHeight);
                                break
                            }
                        runInOp(cm,
                            function () {
                                cm.curOp.selectionChanged = cm.curOp.forceUpdate = cm.curOp.updateMaxLine = !0
                            })
                    }
                }
            },
            TextMarker.prototype.attachLine = function (line) {
                if (!this.lines.length && this.doc.cm) {
                    var op = this.doc.cm.curOp;
                    op.maybeHiddenMarkers && -1 != indexOf(op.maybeHiddenMarkers, this) || (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this)
                }
                this.lines.push(line)
            },
            TextMarker.prototype.detachLine = function (line) {
                if (this.lines.splice(indexOf(this.lines, line), 1), !this.lines.length && this.doc.cm) {
                    var op = this.doc.cm.curOp;
                    (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this)
                }
            },
            CodeMirror.SharedTextMarker = SharedTextMarker,
            eventMixin(SharedTextMarker),
            SharedTextMarker.prototype.clear = function () {
                if (!this.explicitlyCleared) {
                    this.explicitlyCleared = !0;
                    for (var i = 0; i < this.markers.length; ++i) this.markers[i].clear();
                    signalLater(this, "clear")
                }
            },
            SharedTextMarker.prototype.find = function () {
                return this.primary.find()
            };
        var LineWidget = CodeMirror.LineWidget = function (cm, node, options) {
            if (options)
                for (var opt in options) options.hasOwnProperty(opt) && (this[opt] = options[opt]);
            this.cm = cm,
                this.node = node
        };
        eventMixin(LineWidget),
            LineWidget.prototype.clear = widgetOperation(function () {
                var ws = this.line.widgets,
                    no = lineNo(this.line);
                if (null != no && ws) {
                    for (var i = 0; i < ws.length; ++i) ws[i] == this && ws.splice(i--, 1);
                    ws.length || (this.line.widgets = null);
                    var aboveVisible = heightAtLine(this.cm, this.line) < this.cm.doc.scrollTop;
                    updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this))),
                        aboveVisible && addToScrollPos(this.cm, 0, -this.height),
                        regChange(this.cm, no, no + 1)
                }
            }),
            LineWidget.prototype.changed = widgetOperation(function () {
                var oldH = this.height;
                this.height = null;
                var diff = widgetHeight(this) - oldH;
                if (diff) {
                    updateLineHeight(this.line, this.line.height + diff);
                    var no = lineNo(this.line);
                    regChange(this.cm, no, no + 1)
                }
            });
        var Line = CodeMirror.Line = function (text, markedSpans, estimateHeight) {
            this.text = text,
                attachMarkedSpans(this, markedSpans),
                this.height = estimateHeight ? estimateHeight(this) : 1
        };
        eventMixin(Line);
        var styleToClassCache = {},
            tokenSpecialChars = /[\t-­​\u2028\u2029\uFEFF]/g;
        LeafChunk.prototype = {
                chunkSize: function () {
                    return this.lines.length
                },
                removeInner: function (at, n) {
                    for (var i = at,
                            e = at + n; e > i; ++i) {
                        var line = this.lines[i];
                        this.height -= line.height,
                            cleanUpLine(line),
                            signalLater(line, "delete")
                    }
                    this.lines.splice(at, n)
                },
                collapse: function (lines) {
                    lines.splice.apply(lines, [lines.length, 0].concat(this.lines))
                },
                insertInner: function (at, lines, height) {
                    this.height += height,
                        this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
                    for (var i = 0,
                            e = lines.length; e > i; ++i) lines[i].parent = this
                },
                iterN: function (at, n, op) {
                    for (var e = at + n; e > at; ++at)
                        if (op(this.lines[at])) return !0
                }
            },
            BranchChunk.prototype = {
                chunkSize: function () {
                    return this.size
                },
                removeInner: function (at, n) {
                    this.size -= n;
                    for (var i = 0; i < this.children.length; ++i) {
                        var child = this.children[i],
                            sz = child.chunkSize();
                        if (sz > at) {
                            var rm = Math.min(n, sz - at),
                                oldHeight = child.height;
                            if (child.removeInner(at, rm), this.height -= oldHeight - child.height, sz == rm && (this.children.splice(i--, 1), child.parent = null), 0 == (n -= rm)) break;
                            at = 0
                        } else at -= sz
                    }
                    if (this.size - n < 25) {
                        var lines = [];
                        this.collapse(lines),
                            this.children = [new LeafChunk(lines)],
                            this.children[0].parent = this
                    }
                },
                collapse: function (lines) {
                    for (var i = 0,
                            e = this.children.length; e > i; ++i) this.children[i].collapse(lines)
                },
                insertInner: function (at, lines, height) {
                    this.size += lines.length,
                        this.height += height;
                    for (var i = 0,
                            e = this.children.length; e > i; ++i) {
                        var child = this.children[i],
                            sz = child.chunkSize();
                        if (sz >= at) {
                            if (child.insertInner(at, lines, height), child.lines && child.lines.length > 50) {
                                for (; child.lines.length > 50;) {
                                    var spilled = child.lines.splice(child.lines.length - 25, 25),
                                        newleaf = new LeafChunk(spilled);
                                    child.height -= newleaf.height,
                                        this.children.splice(i + 1, 0, newleaf),
                                        newleaf.parent = this
                                }
                                this.maybeSpill()
                            }
                            break
                        }
                        at -= sz
                    }
                },
                maybeSpill: function () {
                    if (!(this.children.length <= 10)) {
                        var me = this;
                        do {
                            var spilled = me.children.splice(me.children.length - 5, 5),
                                sibling = new BranchChunk(spilled);
                            if (me.parent) {
                                me.size -= sibling.size,
                                    me.height -= sibling.height;
                                var myIndex = indexOf(me.parent.children, me);
                                me.parent.children.splice(myIndex + 1, 0, sibling)
                            } else {
                                var copy = new BranchChunk(me.children);
                                copy.parent = me,
                                    me.children = [copy, sibling],
                                    me = copy
                            }
                            sibling.parent = me.parent
                        } while (me.children.length > 10);
                        me.parent.maybeSpill()
                    }
                },
                iterN: function (at, n, op) {
                    for (var i = 0,
                            e = this.children.length; e > i; ++i) {
                        var child = this.children[i],
                            sz = child.chunkSize();
                        if (sz > at) {
                            var used = Math.min(n, sz - at);
                            if (child.iterN(at, used, op)) return !0;
                            if (0 == (n -= used)) break;
                            at = 0
                        } else at -= sz
                    }
                }
            };
        var nextDocId = 0,
            Doc = CodeMirror.Doc = function (text, mode, firstLine) {
                if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);
                null == firstLine && (firstLine = 0),
                    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]),
                    this.first = firstLine,
                    this.scrollTop = this.scrollLeft = 0,
                    this.cantEdit = !1,
                    this.history = makeHistory(),
                    this.cleanGeneration = 1,
                    this.frontier = firstLine;
                var start = Pos(firstLine, 0);
                this.sel = {
                        from: start,
                        to: start,
                        head: start,
                        anchor: start,
                        shift: !1,
                        extend: !1,
                        goalColumn: null
                    },
                    this.id = ++nextDocId,
                    this.modeOption = mode,
                    "string" == typeof text && (text = splitLines(text)),
                    updateDoc(this, {
                            from: start,
                            to: start,
                            text: text
                        },
                        null, {
                            head: start,
                            anchor: start
                        })
            };
        Doc.prototype = createObj(BranchChunk.prototype, {
                constructor: Doc,
                iter: function (from, to, op) {
                    op ? this.iterN(from - this.first, to - from, op) : this.iterN(this.first, this.first + this.size, from)
                },
                insert: function (at, lines) {
                    for (var height = 0,
                            i = 0,
                            e = lines.length; e > i; ++i) height += lines[i].height;
                    this.insertInner(at - this.first, lines, height)
                },
                remove: function (at, n) {
                    this.removeInner(at - this.first, n)
                },
                getValue: function (lineSep) {
                    var lines = getLines(this, this.first, this.first + this.size);
                    return lineSep === !1 ? lines : lines.join(lineSep || "\n")
                },
                setValue: function (code) {
                    var top = Pos(this.first, 0),
                        last = this.first + this.size - 1;
                    makeChange(this, {
                        from: top,
                        to: Pos(last, getLine(this, last).text.length),
                        text: splitLines(code),
                        origin: "setValue"
                    }, {
                        head: top,
                        anchor: top
                    }, !0)
                },
                replaceRange: function (code, from, to, origin) {
                    from = clipPos(this, from),
                        to = to ? clipPos(this, to) : from,
                        replaceRange(this, code, from, to, origin)
                },
                getRange: function (from, to, lineSep) {
                    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
                    return lineSep === !1 ? lines : lines.join(lineSep || "\n")
                },
                getLine: function (line) {
                    var l = this.getLineHandle(line);
                    return l && l.text
                },
                setLine: function (line, text) {
                    isLine(this, line) && replaceRange(this, text, Pos(line, 0), clipPos(this, Pos(line)))
                },
                removeLine: function (line) {
                    line ? replaceRange(this, "", clipPos(this, Pos(line - 1)), clipPos(this, Pos(line))) : replaceRange(this, "", Pos(0, 0), clipPos(this, Pos(1, 0)))
                },
                getLineHandle: function (line) {
                    return isLine(this, line) ? getLine(this, line) : void 0
                },
                getLineNumber: function (line) {
                    return lineNo(line)
                },
                getLineHandleVisualStart: function (line) {
                    return "number" == typeof line && (line = getLine(this, line)),
                        visualLine(this, line)
                },
                lineCount: function () {
                    return this.size
                },
                firstLine: function () {
                    return this.first
                },
                lastLine: function () {
                    return this.first + this.size - 1
                },
                clipPos: function (pos) {
                    return clipPos(this, pos)
                },
                getCursor: function (start) {
                    var pos, sel = this.sel;
                    return pos = null == start || "head" == start ? sel.head : "anchor" == start ? sel.anchor : "end" == start || start === !1 ? sel.to : sel.from,
                        copyPos(pos)
                },
                somethingSelected: function () {
                    return !posEq(this.sel.head, this.sel.anchor)
                },
                setCursor: docOperation(function (line, ch, extend) {
                    var pos = clipPos(this, "number" == typeof line ? Pos(line, ch || 0) : line);
                    extend ? extendSelection(this, pos) : setSelection(this, pos, pos)
                }),
                setSelection: docOperation(function (anchor, head, bias) {
                    setSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), bias)
                }),
                extendSelection: docOperation(function (from, to, bias) {
                    extendSelection(this, clipPos(this, from), to && clipPos(this, to), bias)
                }),
                getSelection: function (lineSep) {
                    return this.getRange(this.sel.from, this.sel.to, lineSep)
                },
                replaceSelection: function (code, collapse, origin) {
                    makeChange(this, {
                            from: this.sel.from,
                            to: this.sel.to,
                            text: splitLines(code),
                            origin: origin
                        },
                        collapse || "around")
                },
                undo: docOperation(function () {
                    makeChangeFromHistory(this, "undo")
                }),
                redo: docOperation(function () {
                    makeChangeFromHistory(this, "redo")
                }),
                setExtending: function (val) {
                    this.sel.extend = val
                },
                historySize: function () {
                    var hist = this.history;
                    return {
                        undo: hist.done.length,
                        redo: hist.undone.length
                    }
                },
                clearHistory: function () {
                    this.history = makeHistory(this.history.maxGeneration)
                },
                markClean: function () {
                    this.cleanGeneration = this.changeGeneration()
                },
                changeGeneration: function () {
                    return this.history.lastOp = this.history.lastOrigin = null,
                        this.history.generation
                },
                isClean: function (gen) {
                    return this.history.generation == (gen || this.cleanGeneration)
                },
                getHistory: function () {
                    return {
                        done: copyHistoryArray(this.history.done),
                        undone: copyHistoryArray(this.history.undone)
                    }
                },
                setHistory: function (histData) {
                    var hist = this.history = makeHistory(this.history.maxGeneration);
                    hist.done = histData.done.slice(0),
                        hist.undone = histData.undone.slice(0)
                },
                markText: function (from, to, options) {
                    return markText(this, clipPos(this, from), clipPos(this, to), options, "range")
                },
                setBookmark: function (pos, options) {
                    var realOpts = {
                        replacedWith: options && (null == options.nodeType ? options.widget : options),
                        insertLeft: options && options.insertLeft
                    };
                    return pos = clipPos(this, pos),
                        markText(this, pos, pos, realOpts, "bookmark")
                },
                findMarksAt: function (pos) {
                    pos = clipPos(this, pos);
                    var markers = [],
                        spans = getLine(this, pos.line).markedSpans;
                    if (spans)
                        for (var i = 0; i < spans.length; ++i) {
                            var span = spans[i];
                            (null == span.from || span.from <= pos.ch) && (null == span.to || span.to >= pos.ch) && markers.push(span.marker.parent || span.marker)
                        }
                    return markers
                },
                getAllMarks: function () {
                    var markers = [];
                    return this.iter(function (line) {
                            var sps = line.markedSpans;
                            if (sps)
                                for (var i = 0; i < sps.length; ++i) null != sps[i].from && markers.push(sps[i].marker)
                        }),
                        markers
                },
                posFromIndex: function (off) {
                    var ch, lineNo = this.first;
                    return this.iter(function (line) {
                            var sz = line.text.length + 1;
                            return sz > off ? (ch = off, !0) : (off -= sz, void++lineNo)
                        }),
                        clipPos(this, Pos(lineNo, ch))
                },
                indexFromPos: function (coords) {
                    coords = clipPos(this, coords);
                    var index = coords.ch;
                    return coords.line < this.first || coords.ch < 0 ? 0 : (this.iter(this.first, coords.line,
                        function (line) {
                            index += line.text.length + 1
                        }), index)
                },
                copy: function (copyHistory) {
                    var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
                    return doc.scrollTop = this.scrollTop,
                        doc.scrollLeft = this.scrollLeft,
                        doc.sel = {
                            from: this.sel.from,
                            to: this.sel.to,
                            head: this.sel.head,
                            anchor: this.sel.anchor,
                            shift: this.sel.shift,
                            extend: !1,
                            goalColumn: this.sel.goalColumn
                        },
                        copyHistory && (doc.history.undoDepth = this.history.undoDepth, doc.setHistory(this.getHistory())),
                        doc
                },
                linkedDoc: function (options) {
                    options || (options = {});
                    var from = this.first,
                        to = this.first + this.size;
                    null != options.from && options.from > from && (from = options.from),
                        null != options.to && options.to < to && (to = options.to);
                    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
                    return options.sharedHist && (copy.history = this.history),
                        (this.linked || (this.linked = [])).push({
                            doc: copy,
                            sharedHist: options.sharedHist
                        }),
                        copy.linked = [{
                            doc: this,
                            isParent: !0,
                            sharedHist: options.sharedHist
                        }],
                        copy
                },
                unlinkDoc: function (other) {
                    if (other instanceof CodeMirror && (other = other.doc), this.linked)
                        for (var i = 0; i < this.linked.length; ++i) {
                            var link = this.linked[i];
                            if (link.doc == other) {
                                this.linked.splice(i, 1),
                                    other.unlinkDoc(this);
                                break
                            }
                        }
                    if (other.history == this.history) {
                        var splitIds = [other.id];
                        linkedDocs(other,
                                function (doc) {
                                    splitIds.push(doc.id)
                                }, !0),
                            other.history = makeHistory(),
                            other.history.done = copyHistoryArray(this.history.done, splitIds),
                            other.history.undone = copyHistoryArray(this.history.undone, splitIds)
                    }
                },
                iterLinkedDocs: function (f) {
                    linkedDocs(this, f)
                },
                getMode: function () {
                    return this.mode
                },
                getEditor: function () {
                    return this.cm
                }
            }),
            Doc.prototype.eachLine = Doc.prototype.iter;
        var dontDelegate = "iter insert remove copy getEditor".split(" ");
        for (var prop in Doc.prototype) Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0 && (CodeMirror.prototype[prop] = function (method) {
            return function () {
                return method.apply(this.doc, arguments)
            }
        }(Doc.prototype[prop]));
        eventMixin(Doc),
            CodeMirror.e_stop = e_stop,
            CodeMirror.e_preventDefault = e_preventDefault,
            CodeMirror.e_stopPropagation = e_stopPropagation;
        var delayedCallbacks, delayedCallbackDepth = 0;
        CodeMirror.on = on,
            CodeMirror.off = off,
            CodeMirror.signal = signal;
        var scrollerCutOff = 30,
            Pass = CodeMirror.Pass = {
                toString: function () {
                    return "CodeMirror.Pass"
                }
            };
        Delayed.prototype = {
                set: function (ms, f) {
                    clearTimeout(this.id),
                        this.id = setTimeout(f, ms)
                }
            },
            CodeMirror.countColumn = countColumn;
        var spaceStrs = [""],
            nonASCIISingleCaseWordChar = /[぀-ゟ゠-ヿ㐀-䶵一-鿌가-힯]/,
            isExtendingChar = /[̀-ͯ҃-҇҈-҉֑-ֽֿׁ-ׂׄ-ׇׅؐ-ًؚ-ٰٟۖ-ۜ۟-ۤۧ-۪ۨ-ۭ꙯꙰-꙲ꙴ-꙽ꚟ�-�]/;
        CodeMirror.replaceGetRect = function (f) {
            getRect = f
        };
        var dragAndDrop = function () {
            if (ie_lt9) return !1;
            var div = elt("div");
            return "draggable" in div || "dragDrop" in div
        }();
        gecko ? spanAffectsWrapping = function (str, i) {
            return 36 == str.charCodeAt(i - 1) && 39 == str.charCodeAt(i)
        } : safari && !/Version\/([6-9]|\d\d)\b/.test(navigator.userAgent) ? spanAffectsWrapping = function (str, i) {
            return /\-[^ \-?]|\?[^ !\'\"\),.\-\/:;\?\]\}]/.test(str.slice(i - 1, i + 1))
        } : webkit && /Chrome\/(?:29|[3-9]\d|\d\d\d)\./.test(navigator.userAgent) ? spanAffectsWrapping = function (str, i) {
            var code = str.charCodeAt(i - 1);
            return code >= 8208 && 8212 >= code
        } : webkit && (spanAffectsWrapping = function (str, i) {
            if (i > 1 && 45 == str.charCodeAt(i - 1)) {
                if (/\w/.test(str.charAt(i - 2)) && /[^\-?\.]/.test(str.charAt(i))) return !0;
                if (i > 2 && /[\d\.,]/.test(str.charAt(i - 2)) && /[\d\.,]/.test(str.charAt(i))) return !1
            }
            return /[~!#%&*)=+}\]\\|\"\.>,:;][({[<]|-[^\-?\.‐-‟…]|\?[\w~`@#$%\^&*(_=+{[|><]|…[\w~`@#$%\^&*(_=+{[><]/.test(str.slice(i - 1, i + 1))
        });
        var knownScrollbarWidth, zwspSupported, splitLines = 3 != "\n\nb".split(/\n/).length ?
            function (string) {
                for (var pos = 0,
                        result = [], l = string.length; l >= pos;) {
                    var nl = string.indexOf("\n", pos); - 1 == nl && (nl = string.length);
                    var line = string.slice(pos, "\r" == string.charAt(nl - 1) ? nl - 1 : nl),
                        rt = line.indexOf("\r"); - 1 != rt ? (result.push(line.slice(0, rt)), pos += rt + 1) : (result.push(line), pos = nl + 1)
                }
                return result
            } : function (string) {
                return string.split(/\r\n?|\n/)
            };
        CodeMirror.splitLines = splitLines;
        var hasSelection = window.getSelection ?
            function (te) {
                try {
                    return te.selectionStart != te.selectionEnd
                } catch (e) {
                    return !1
                }
            } : function (te) {
                try {
                    var range = te.ownerDocument.selection.createRange()
                } catch (e) {}
                return range && range.parentElement() == te ? 0 != range.compareEndPoints("StartToEnd", range) : !1
            },
            hasCopyEvent = function () {
                var e = elt("div");
                return "oncopy" in e ? !0 : (e.setAttribute("oncopy", "return;"), "function" == typeof e.oncopy)
            }(),
            keyNames = {
                3: "Enter",
                8: "Backspace",
                9: "Tab",
                13: "Enter",
                16: "Shift",
                17: "Ctrl",
                18: "Alt",
                19: "Pause",
                20: "CapsLock",
                27: "Esc",
                32: "Space",
                33: "PageUp",
                34: "PageDown",
                35: "End",
                36: "Home",
                37: "Left",
                38: "Up",
                39: "Right",
                40: "Down",
                44: "PrintScrn",
                45: "Insert",
                46: "Delete",
                59: ";",
                91: "Mod",
                92: "Mod",
                93: "Mod",
                109: "-",
                107: "=",
                127: "Delete",
                186: ";",
                187: "=",
                188: ",",
                189: "-",
                190: ".",
                191: "/",
                192: "`",
                219: "[",
                220: "\\",
                221: "]",
                222: "'",
                63276: "PageUp",
                63277: "PageDown",
                63275: "End",
                63273: "Home",
                63234: "Left",
                63232: "Up",
                63235: "Right",
                63233: "Down",
                63302: "Insert",
                63272: "Delete"
            };
        CodeMirror.keyNames = keyNames,
            function () {
                for (var i = 0; 10 > i; i++) keyNames[i + 48] = String(i);
                for (var i = 65; 90 >= i; i++) keyNames[i] = String.fromCharCode(i);
                for (var i = 1; 12 >= i; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i
            }();
        var bidiOther, bidiOrdering = function () {
            function charType(code) {
                return 255 >= code ? lowTypes.charAt(code) : code >= 1424 && 1524 >= code ? "R" : code >= 1536 && 1791 >= code ? arabicTypes.charAt(code - 1536) : code >= 1792 && 2220 >= code ? "r" : "L"
            }
            var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL",
                arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr",
                bidiRE = /[֐-״؀-ۿ܀-ࢬ]/,
                isNeutral = /[stwN]/,
                isStrong = /[LRr]/,
                countsAsLeft = /[Lb1n]/,
                countsAsNum = /[1n]/,
                outerType = "L";
            return function (str) {
                if (!bidiRE.test(str)) return !1;
                for (var type, len = str.length,
                        types = [], i = 0; len > i; ++i) types.push(type = charType(str.charCodeAt(i)));
                for (var i = 0,
                        prev = outerType; len > i; ++i) {
                    var type = types[i];
                    "m" == type ? types[i] = prev : prev = type
                }
                for (var i = 0,
                        cur = outerType; len > i; ++i) {
                    var type = types[i];
                    "1" == type && "r" == cur ? types[i] = "n" : isStrong.test(type) && (cur = type, "r" == type && (types[i] = "R"))
                }
                for (var i = 1,
                        prev = types[0]; len - 1 > i; ++i) {
                    var type = types[i];
                    "+" == type && "1" == prev && "1" == types[i + 1] ? types[i] = "1" : "," != type || prev != types[i + 1] || "1" != prev && "n" != prev || (types[i] = prev),
                        prev = type
                }
                for (var i = 0; len > i; ++i) {
                    var type = types[i];
                    if ("," == type) types[i] = "N";
                    else if ("%" == type) {
                        for (var end = i + 1; len > end && "%" == types[end]; ++end);
                        for (var replace = i && "!" == types[i - 1] || len - 1 > end && "1" == types[end] ? "1" : "N", j = i; end > j; ++j) types[j] = replace;
                        i = end - 1
                    }
                }
                for (var i = 0,
                        cur = outerType; len > i; ++i) {
                    var type = types[i];
                    "L" == cur && "1" == type ? types[i] = "L" : isStrong.test(type) && (cur = type)
                }
                for (var i = 0; len > i; ++i)
                    if (isNeutral.test(types[i])) {
                        for (var end = i + 1; len > end && isNeutral.test(types[end]); ++end);
                        for (var before = "L" == (i ? types[i - 1] : outerType), after = "L" == (len - 1 > end ? types[end] : outerType), replace = before || after ? "L" : "R", j = i; end > j; ++j) types[j] = replace;
                        i = end - 1
                    }
                for (var m, order = [], i = 0; len > i;)
                    if (countsAsLeft.test(types[i])) {
                        var start = i;
                        for (++i; len > i && countsAsLeft.test(types[i]); ++i);
                        order.push({
                            from: start,
                            to: i,
                            level: 0
                        })
                    } else {
                        var pos = i,
                            at = order.length;
                        for (++i; len > i && "L" != types[i]; ++i);
                        for (var j = pos; i > j;)
                            if (countsAsNum.test(types[j])) {
                                j > pos && order.splice(at, 0, {
                                    from: pos,
                                    to: j,
                                    level: 1
                                });
                                var nstart = j;
                                for (++j; i > j && countsAsNum.test(types[j]); ++j);
                                order.splice(at, 0, {
                                        from: nstart,
                                        to: j,
                                        level: 2
                                    }),
                                    pos = j
                            } else ++j;
                        i > pos && order.splice(at, 0, {
                            from: pos,
                            to: i,
                            level: 1
                        })
                    }
                return 1 == order[0].level && (m = str.match(/^\s+/)) && (order[0].from = m[0].length, order.unshift({
                        from: 0,
                        to: m[0].length,
                        level: 0
                    })),
                    1 == lst(order).level && (m = str.match(/\s+$/)) && (lst(order).to -= m[0].length, order.push({
                        from: len - m[0].length,
                        to: len,
                        level: 0
                    })),
                    order[0].level != lst(order).level && order.push({
                        from: len,
                        to: len,
                        level: order[0].level
                    }),
                    order
            }
        }();
        return CodeMirror.version = "3.19.0",
            CodeMirror
    }(), CodeMirror.defineMode("css",
        function (config, parserConfig) {
            "use strict";

            function ret(style, tp) {
                return type = tp,
                    style
            }

            function tokenBase(stream, state) {
                var ch = stream.next();
                if (hooks[ch]) {
                    var result = hooks[ch](stream, state);
                    if (result !== !1) return result
                }
                if ("@" == ch) return stream.eatWhile(/[\w\\\-]/),
                    ret("def", stream.current());
                if ("=" == ch) ret(null, "compare");
                else {
                    if (("~" == ch || "|" == ch) && stream.eat("=")) return ret(null, "compare");
                    if ('"' == ch || "'" == ch) return state.tokenize = tokenString(ch),
                        state.tokenize(stream, state);
                    if ("#" == ch) return stream.eatWhile(/[\w\\\-]/),
                        ret("atom", "hash");
                    if ("!" == ch) return stream.match(/^\s*\w*/),
                        ret("keyword", "important");
                    if (/\d/.test(ch) || "." == ch && stream.eat(/\d/)) return stream.eatWhile(/[\w.%]/),
                        ret("number", "unit");
                    if ("-" !== ch) return /[,+>*\/]/.test(ch) ? ret(null, "select-op") : "." == ch && stream.match(/^-?[_a-z][_a-z0-9-]*/i) ? ret("qualifier", "qualifier") : ":" == ch ? ret("operator", ch) : /[;{}\[\]\(\)]/.test(ch) ? ret(null, ch) : "u" == ch && stream.match("rl(") ? (stream.backUp(1), state.tokenize = tokenParenthesized, ret("property", "variable")) : (stream.eatWhile(/[\w\\\-]/), ret("property", "variable"));
                    if (/\d/.test(stream.peek())) return stream.eatWhile(/[\w.%]/),
                        ret("number", "unit");
                    if (stream.match(/^[^-]+-/)) return ret("meta", "meta")
                }
            }

            function tokenString(quote, nonInclusive) {
                return function (stream, state) {
                    for (var ch, escaped = !1; null != (ch = stream.next()) && (ch != quote || escaped);) escaped = !escaped && "\\" == ch;
                    return escaped || (nonInclusive && stream.backUp(1), state.tokenize = tokenBase),
                        ret("string", "string")
                }
            }

            function tokenParenthesized(stream, state) {
                return stream.next(),
                    state.tokenize = stream.match(/\s*[\"\']/, !1) ? tokenBase : tokenString(")", !0),
                    ret(null, "(")
            }
            parserConfig.propertyKeywords || (parserConfig = CodeMirror.resolveMode("text/css"));
            var indentUnit = config.indentUnit || config.tabSize || 2,
                hooks = parserConfig.hooks || {},
                atMediaTypes = parserConfig.atMediaTypes || {},
                atMediaFeatures = parserConfig.atMediaFeatures || {},
                propertyKeywords = parserConfig.propertyKeywords || {},
                colorKeywords = parserConfig.colorKeywords || {},
                valueKeywords = parserConfig.valueKeywords || {},
                allowNested = !!parserConfig.allowNested,
                type = null;
            return {
                startState: function (base) {
                    return {
                        tokenize: tokenBase,
                        baseIndent: base || 0,
                        stack: [],
                        lastToken: null
                    }
                },
                token: function (stream, state) {
                    if (state.tokenize = state.tokenize || tokenBase, state.tokenize == tokenBase && stream.eatSpace()) return null;
                    var style = state.tokenize(stream, state);
                    style && "string" != typeof style && (style = ret(style[0], style[1]));
                    var context = state.stack[state.stack.length - 1];
                    if ("variable" == style) return "variable-definition" == type && state.stack.push("propertyValue"),
                        state.lastToken = "variable-2";
                    if ("property" == style) {
                        var word = stream.current().toLowerCase();
                        "propertyValue" == context ? style = valueKeywords.hasOwnProperty(word) ? "string-2" : colorKeywords.hasOwnProperty(word) ? "keyword" : "variable-2" : "rule" == context ? propertyKeywords.hasOwnProperty(word) || (style += " error") : "block" == context ? style = propertyKeywords.hasOwnProperty(word) ? "property" : colorKeywords.hasOwnProperty(word) ? "keyword" : valueKeywords.hasOwnProperty(word) ? "string-2" : "tag" : context && "@media{" != context ? "@media" == context ? style = atMediaTypes[stream.current()] ? "attribute" : /^(only|not)$/.test(word) ? "keyword" : "and" == word ? "error" : atMediaFeatures.hasOwnProperty(word) ? "error" : "attribute error" : "@mediaType" == context ? style = atMediaTypes.hasOwnProperty(word) ? "attribute" : "and" == word ? "operator" : /^(only|not)$/.test(word) ? "error" : "error" : "@mediaType(" == context ? propertyKeywords.hasOwnProperty(word) || (atMediaTypes.hasOwnProperty(word) ? style = "error" : "and" == word ? style = "operator" : /^(only|not)$/.test(word) ? style = "error" : style += " error") : style = "@import" == context ? "tag" : "error" : style = "tag"
                    } else "atom" == style ? context && "@media{" != context && "block" != context ? "propertyValue" == context ? /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current()) || (style += " error") : style = "error" : style = "builtin" : "@media" == context && "{" == type && (style = "error");
                    if ("{" == type)
                        if ("@media" == context || "@mediaType" == context) state.stack[state.stack.length - 1] = "@media{";
                        else {
                            var newContext = allowNested ? "block" : "rule";
                            state.stack.push(newContext)
                        }
                    else if ("}" == type)
                        for ("interpolation" == context && (style = "operator"); state.stack.length;) {
                            var removed = state.stack.pop();
                            if (removed.indexOf("{") > -1) break
                        } else if ("interpolation" == type) state.stack.push("interpolation");
                        else if ("@media" == type) state.stack.push("@media");
                    else if ("@import" == type) state.stack.push("@import");
                    else if ("@media" == context && /\b(keyword|attribute)\b/.test(style)) state.stack[state.stack.length - 1] = "@mediaType";
                    else if ("@mediaType" == context && "," == stream.current()) state.stack[state.stack.length - 1] = "@media";
                    else if ("(" == type) "@media" == context || "@mediaType" == context ? (state.stack[state.stack.length - 1] = "@mediaType", state.stack.push("@mediaType(")) : state.stack.push("(");
                    else if (")" == type)
                        for (; state.stack.length;) {
                            var removed = state.stack.pop();
                            if (removed.indexOf("(") > -1) break
                        } else ":" == type && "property" == state.lastToken ? state.stack.push("propertyValue") : "propertyValue" == context && ";" == type ? state.stack.pop() : "@import" == context && ";" == type && state.stack.pop();
                    return state.lastToken = style
                },
                indent: function (state, textAfter) {
                    var n = state.stack.length;
                    return /^\}/.test(textAfter) && (n -= "propertyValue" == state.stack[n - 1] ? 2 : 1),
                        state.baseIndent + n * indentUnit
                },
                electricChars: "}",
                blockCommentStart: "/*",
                blockCommentEnd: "*/",
                fold: "brace"
            }
        }),
    function () {
        function keySet(array) {
            for (var keys = {},
                    i = 0; i < array.length; ++i) keys[array[i]] = !0;
            return keys
        }

        function tokenCComment(stream, state) {
            for (var ch, maybeEnd = !1; null != (ch = stream.next());) {
                if (maybeEnd && "/" == ch) {
                    state.tokenize = null;
                    break
                }
                maybeEnd = "*" == ch
            }
            return ["comment", "comment"]
        }
        var atMediaTypes = keySet(["all", "aural", "braille", "handheld", "print", "projection", "screen", "tty", "tv", "embossed"]),
            atMediaFeatures = keySet(["width", "min-width", "max-width", "height", "min-height", "max-height", "device-width", "min-device-width", "max-device-width", "device-height", "min-device-height", "max-device-height", "aspect-ratio", "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio", "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color", "max-color", "color-index", "min-color-index", "max-color-index", "monochrome", "min-monochrome", "max-monochrome", "resolution", "min-resolution", "max-resolution", "scan", "grid"]),
            propertyKeywords = keySet(["align-content", "align-items", "align-self", "alignment-adjust", "alignment-baseline", "anchor-point", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "appearance", "azimuth", "backface-visibility", "background", "background-attachment", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "baseline-shift", "binding", "bleed", "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target", "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "clear", "clip", "color", "color-profile", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "dominant-baseline", "drop-initial-after-adjust", "drop-initial-after-align", "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size", "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings", "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-weight", "grid-cell", "grid-column", "grid-column-align", "grid-column-sizing", "grid-column-span", "grid-columns", "grid-flow", "grid-row", "grid-row-align", "grid-row-sizing", "grid-row-span", "grid-rows", "grid-template", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "inline-box-align", "justify-content", "left", "letter-spacing", "line-break", "line-height", "line-stacking", "line-stacking-ruby", "line-stacking-shift", "line-stacking-strategy", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marker-offset", "marks", "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed", "marquee-style", "max-height", "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "page-policy", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pitch", "pitch-range", "play-during", "position", "presentation-level", "punctuation-trim", "quotes", "region-break-after", "region-break-before", "region-break-inside", "region-fragment", "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness", "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span", "shape-inside", "shape-outside", "size", "speak", "speak-as", "speak-header", "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size", "table-layout", "target", "target-name", "target-new", "target-position", "text-align", "text-align-last", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-skip", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-height", "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow", "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position", "text-wrap", "top", "transform", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "volume", "white-space", "widows", "width", "word-break", "word-spacing", "word-wrap", "z-index", "zoom", "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color", "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering", "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering", "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal", "glyph-orientation-vertical", "kerning", "text-anchor", "writing-mode"]),
            colorKeywords = keySet(["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]),
            valueKeywords = keySet(["above", "absolute", "activeborder", "activecaption", "afar", "after-white-space", "ahead", "alias", "all", "all-scroll", "alternate", "always", "amharic", "amharic-abegede", "antialiased", "appworkspace", "arabic-indic", "armenian", "asterisks", "auto", "avoid", "avoid-column", "avoid-page", "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary", "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "cambodian", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-earthly-branch", "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote", "col-resize", "collapse", "column", "compact", "condensed", "contain", "content", "content-box", "context-menu", "continuous", "copy", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "destination-atop", "destination-in", "destination-out", "destination-over", "devanagari", "disc", "discard", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede", "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er", "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er", "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et", "ethiopic-halehame-gez", "ethiopic-halehame-om-et", "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et", "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig", "ew-resize", "expanded", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "footnotes", "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove", "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer", "landscape", "lao", "large", "larger", "left", "level", "lighter", "line-through", "linear", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian", "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lower-roman", "lowercase", "ltr", "malayalam", "match", "media-controls-background", "media-current-time-display", "media-fullscreen-button", "media-mute-button", "media-play-button", "media-return-to-realtime-button", "media-rewind-button", "media-seek-back-button", "media-seek-forward-button", "media-slider", "media-sliderthumb", "media-time-remaining-display", "media-volume-slider", "media-volume-slider-container", "media-volume-sliderthumb", "medium", "menu", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic", "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote", "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "persian", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "round", "row-resize", "rtl", "run-in", "running", "s-resize", "sans-serif", "scroll", "scrollbar", "se-resize", "searchfield", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama", "single", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "solid", "somali", "source-atop", "source-in", "source-out", "source-over", "space", "square", "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub", "subpixel-antialiased", "super", "sw-resize", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er", "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top", "transparent", "ultra-condensed", "ultra-expanded", "underline", "up", "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal", "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "x-large", "x-small", "xor", "xx-large", "xx-small"]);
        CodeMirror.defineMIME("text/css", {
                atMediaTypes: atMediaTypes,
                atMediaFeatures: atMediaFeatures,
                propertyKeywords: propertyKeywords,
                colorKeywords: colorKeywords,
                valueKeywords: valueKeywords,
                hooks: {
                    "<": function (stream, state) {
                        function tokenSGMLComment(stream, state) {
                            for (var ch, dashes = 0; null != (ch = stream.next());) {
                                if (dashes >= 2 && ">" == ch) {
                                    state.tokenize = null;
                                    break
                                }
                                dashes = "-" == ch ? dashes + 1 : 0
                            }
                            return ["comment", "comment"]
                        }
                        return stream.eat("!") ? (state.tokenize = tokenSGMLComment, tokenSGMLComment(stream, state)) : void 0
                    },
                    "/": function (stream, state) {
                        return stream.eat("*") ? (state.tokenize = tokenCComment, tokenCComment(stream, state)) : !1
                    }
                },
                name: "css"
            }),
            CodeMirror.defineMIME("text/x-scss", {
                atMediaTypes: atMediaTypes,
                atMediaFeatures: atMediaFeatures,
                propertyKeywords: propertyKeywords,
                colorKeywords: colorKeywords,
                valueKeywords: valueKeywords,
                allowNested: !0,
                hooks: {
                    ":": function (stream) {
                        return stream.match(/\s*{/) ? [null, "{"] : !1
                    },
                    $: function (stream) {
                        return stream.match(/^[\w-]+/),
                            ":" == stream.peek() ? ["variable", "variable-definition"] : ["variable", "variable"]
                    },
                    ",": function (_stream, state) {
                        return "propertyValue" == state.stack[state.stack.length - 1] ? ["operator", ";"] : void 0
                    },
                    "/": function (stream, state) {
                        return stream.eat("/") ? (stream.skipToEnd(), ["comment", "comment"]) : stream.eat("*") ? (state.tokenize = tokenCComment, tokenCComment(stream, state)) : ["operator", "operator"]
                    },
                    "#": function (stream) {
                        return stream.eat("{") ? ["operator", "interpolation"] : (stream.eatWhile(/[\w\\\-]/), ["atom", "hash"])
                    }
                },
                name: "css"
            })
    }(),
    function () {
        function clearPlaceholder(cm) {
            cm.state.placeholder && (cm.state.placeholder.parentNode.removeChild(cm.state.placeholder), cm.state.placeholder = null)
        }

        function setPlaceholder(cm) {
            clearPlaceholder(cm);
            var elt = cm.state.placeholder = document.createElement("pre");
            elt.style.cssText = "height: 0; overflow: visible",
                elt.className = "CodeMirror-placeholder",
                elt.appendChild(document.createTextNode(cm.getOption("placeholder"))),
                cm.display.lineSpace.insertBefore(elt, cm.display.lineSpace.firstChild)
        }

        function onFocus(cm) {
            clearPlaceholder(cm)
        }

        function onBlur(cm) {
            isEmpty(cm) && setPlaceholder(cm)
        }

        function onChange(cm) {
            var wrapper = cm.getWrapperElement(),
                empty = isEmpty(cm);
            wrapper.className = wrapper.className.replace(" CodeMirror-empty", "") + (empty ? " CodeMirror-empty" : ""),
                cm.hasFocus() || (empty ? setPlaceholder(cm) : clearPlaceholder(cm))
        }

        function isEmpty(cm) {
            return 1 === cm.lineCount() && "" === cm.getLine(0)
        }
        CodeMirror.defineOption("placeholder", "",
            function (cm, val, old) {
                var prev = old && old != CodeMirror.Init;
                if (val && !prev) cm.on("focus", onFocus),
                    cm.on("blur", onBlur),
                    cm.on("change", onChange),
                    onChange(cm);
                else if (!val && prev) {
                    cm.off("focus", onFocus),
                        cm.off("blur", onBlur),
                        cm.off("change", onChange),
                        clearPlaceholder(cm);
                    var wrapper = cm.getWrapperElement();
                    wrapper.className = wrapper.className.replace(" CodeMirror-empty", "")
                }
                val && !cm.hasFocus() && onBlur(cm)
            })
    }(), CodeMirror.defineMode("css",
        function (config) {
            return CodeMirror.getMode(config, "text/css")
        }), CodeMirror.defineMode("css-base",
        function (config, parserConfig) {
            "use strict";

            function ret(style, tp) {
                return type = tp,
                    style
            }

            function tokenBase(stream, state) {
                var ch = stream.next();
                if (hooks[ch]) {
                    var result = hooks[ch](stream, state);
                    if (result !== !1) return result
                }
                if ("@" == ch) return stream.eatWhile(/[\w\\\-]/),
                    ret("def", stream.current());
                if ("=" == ch) ret(null, "compare");
                else {
                    if (("~" == ch || "|" == ch) && stream.eat("=")) return ret(null, "compare");
                    if ('"' == ch || "'" == ch) return state.tokenize = tokenString(ch),
                        state.tokenize(stream, state);
                    if ("#" == ch) return stream.eatWhile(/[\w\\\-]/),
                        ret("atom", "hash");
                    if ("!" == ch) return stream.match(/^\s*\w*/),
                        ret("keyword", "important");
                    if (/\d/.test(ch)) return stream.eatWhile(/[\w.%]/),
                        ret("number", "unit");
                    if ("-" !== ch) return /[,+>*\/]/.test(ch) ? ret(null, "select-op") : "." == ch && stream.match(/^-?[_a-z][_a-z0-9-]*/i) ? ret("qualifier", "qualifier") : ":" == ch ? ret("operator", ch) : /[;{}\[\]\(\)]/.test(ch) ? ret(null, ch) : "u" == ch && stream.match("rl(") ? (stream.backUp(1), state.tokenize = tokenParenthesized, ret("property", "variable")) : (stream.eatWhile(/[\w\\\-]/), ret("property", "variable"));
                    if (/\d/.test(stream.peek())) return stream.eatWhile(/[\w.%]/),
                        ret("number", "unit");
                    if (stream.match(/^[^-]+-/)) return ret("meta", "meta")
                }
            }

            function tokenString(quote, nonInclusive) {
                return function (stream, state) {
                    for (var ch, escaped = !1; null != (ch = stream.next()) && (ch != quote || escaped);) escaped = !escaped && "\\" == ch;
                    return escaped || (nonInclusive && stream.backUp(1), state.tokenize = tokenBase),
                        ret("string", "string")
                }
            }

            function tokenParenthesized(stream, state) {
                return stream.next(),
                    state.tokenize = stream.match(/\s*[\"\']/, !1) ? tokenBase : tokenString(")", !0),
                    ret(null, "(")
            }
            var indentUnit = config.indentUnit,
                hooks = parserConfig.hooks || {},
                atMediaTypes = parserConfig.atMediaTypes || {},
                atMediaFeatures = parserConfig.atMediaFeatures || {},
                propertyKeywords = parserConfig.propertyKeywords || {},
                colorKeywords = parserConfig.colorKeywords || {},
                valueKeywords = parserConfig.valueKeywords || {},
                allowNested = !!parserConfig.allowNested,
                type = null;
            return {
                startState: function (base) {
                    return {
                        tokenize: tokenBase,
                        baseIndent: base || 0,
                        stack: [],
                        lastToken: null
                    }
                },
                token: function (stream, state) {
                    if (state.tokenize = state.tokenize || tokenBase, state.tokenize == tokenBase && stream.eatSpace()) return null;
                    var style = state.tokenize(stream, state);
                    style && "string" != typeof style && (style = ret(style[0], style[1]));
                    var context = state.stack[state.stack.length - 1];
                    if ("variable" == style) return "variable-definition" == type && state.stack.push("propertyValue"),
                        state.lastToken = "variable-2";
                    if ("property" == style) {
                        var word = stream.current().toLowerCase();
                        "propertyValue" == context ? style = valueKeywords.hasOwnProperty(word) ? "string-2" : colorKeywords.hasOwnProperty(word) ? "keyword" : "variable-2" : "rule" == context ? propertyKeywords.hasOwnProperty(word) || (style += " error") : "block" == context ? style = propertyKeywords.hasOwnProperty(word) ? "property" : colorKeywords.hasOwnProperty(word) ? "keyword" : valueKeywords.hasOwnProperty(word) ? "string-2" : "tag" : context && "@media{" != context ? "@media" == context ? style = atMediaTypes[stream.current()] ? "attribute" : /^(only|not)$/.test(word) ? "keyword" : "and" == word ? "error" : atMediaFeatures.hasOwnProperty(word) ? "error" : "attribute error" : "@mediaType" == context ? style = atMediaTypes.hasOwnProperty(word) ? "attribute" : "and" == word ? "operator" : /^(only|not)$/.test(word) ? "error" : "error" : "@mediaType(" == context ? propertyKeywords.hasOwnProperty(word) || (atMediaTypes.hasOwnProperty(word) ? style = "error" : "and" == word ? style = "operator" : /^(only|not)$/.test(word) ? style = "error" : style += " error") : style = "@import" == context ? "tag" : "error" : style = "tag"
                    } else "atom" == style ? context && "@media{" != context && "block" != context ? "propertyValue" == context ? /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current()) || (style += " error") : style = "error" : style = "builtin" : "@media" == context && "{" == type && (style = "error");
                    if ("{" == type)
                        if ("@media" == context || "@mediaType" == context) state.stack[state.stack.length - 1] = "@media{";
                        else {
                            var newContext = allowNested ? "block" : "rule";
                            state.stack.push(newContext)
                        }
                    else "}" == type ? ("interpolation" == context && (style = "operator"), state.stack.pop(), "propertyValue" == context && state.stack.pop()) : "interpolation" == type ? state.stack.push("interpolation") : "@media" == type ? state.stack.push("@media") : "@import" == type ? state.stack.push("@import") : "@media" == context && /\b(keyword|attribute)\b/.test(style) ? state.stack[state.stack.length - 1] = "@mediaType" : "@mediaType" == context && "," == stream.current() ? state.stack[state.stack.length - 1] = "@media" : "(" == type ? "@media" == context || "@mediaType" == context ? (state.stack[state.stack.length - 1] = "@mediaType", state.stack.push("@mediaType(")) : state.stack.push("(") : ")" == type ? ("propertyValue" == context && state.stack.pop(), state.stack.pop()) : ":" == type && "property" == state.lastToken ? state.stack.push("propertyValue") : "propertyValue" == context && ";" == type ? state.stack.pop() : "@import" == context && ";" == type && state.stack.pop();
                    return state.lastToken = style
                },
                indent: function (state, textAfter) {
                    var n = state.stack.length;
                    return /^\}/.test(textAfter) && (n -= "propertyValue" == state.stack[n - 1] ? 2 : 1),
                        state.baseIndent + n * indentUnit
                },
                electricChars: "}",
                blockCommentStart: "/*",
                blockCommentEnd: "*/",
                fold: "brace"
            }
        }),
    function () {
        function keySet(array) {
            for (var keys = {},
                    i = 0; i < array.length; ++i) keys[array[i]] = !0;
            return keys
        }

        function tokenCComment(stream, state) {
            for (var ch, maybeEnd = !1; null != (ch = stream.next());) {
                if (maybeEnd && "/" == ch) {
                    state.tokenize = null;
                    break
                }
                maybeEnd = "*" == ch
            }
            return ["comment", "comment"]
        }
        var atMediaTypes = keySet(["all", "aural", "braille", "handheld", "print", "projection", "screen", "tty", "tv", "embossed"]),
            atMediaFeatures = keySet(["width", "min-width", "max-width", "height", "min-height", "max-height", "device-width", "min-device-width", "max-device-width", "device-height", "min-device-height", "max-device-height", "aspect-ratio", "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio", "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color", "max-color", "color-index", "min-color-index", "max-color-index", "monochrome", "min-monochrome", "max-monochrome", "resolution", "min-resolution", "max-resolution", "scan", "grid"]),
            propertyKeywords = keySet(["align-content", "align-items", "align-self", "alignment-adjust", "alignment-baseline", "anchor-point", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "appearance", "azimuth", "backface-visibility", "background", "background-attachment", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "baseline-shift", "binding", "bleed", "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target", "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "clear", "clip", "color", "color-profile", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "dominant-baseline", "drop-initial-after-adjust", "drop-initial-after-align", "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size", "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings", "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-weight", "grid-cell", "grid-column", "grid-column-align", "grid-column-sizing", "grid-column-span", "grid-columns", "grid-flow", "grid-row", "grid-row-align", "grid-row-sizing", "grid-row-span", "grid-rows", "grid-template", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "inline-box-align", "justify-content", "left", "letter-spacing", "line-break", "line-height", "line-stacking", "line-stacking-ruby", "line-stacking-shift", "line-stacking-strategy", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marker-offset", "marks", "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed", "marquee-style", "max-height", "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "page-policy", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pitch", "pitch-range", "play-during", "position", "presentation-level", "punctuation-trim", "quotes", "region-break-after", "region-break-before", "region-break-inside", "region-fragment", "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness", "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span", "shape-inside", "shape-outside", "size", "speak", "speak-as", "speak-header", "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size", "table-layout", "target", "target-name", "target-new", "target-position", "text-align", "text-align-last", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-skip", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-height", "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow", "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position", "text-wrap", "top", "transform", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "volume", "white-space", "widows", "width", "word-break", "word-spacing", "word-wrap", "z-index", "zoom", "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color", "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering", "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering", "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal", "glyph-orientation-vertical", "kerning", "text-anchor", "writing-mode"]),
            colorKeywords = keySet(["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]),
            valueKeywords = keySet(["above", "absolute", "activeborder", "activecaption", "afar", "after-white-space", "ahead", "alias", "all", "all-scroll", "alternate", "always", "amharic", "amharic-abegede", "antialiased", "appworkspace", "arabic-indic", "armenian", "asterisks", "auto", "avoid", "avoid-column", "avoid-page", "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary", "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "cambodian", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-earthly-branch", "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote", "col-resize", "collapse", "column", "compact", "condensed", "contain", "content", "content-box", "context-menu", "continuous", "copy", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "destination-atop", "destination-in", "destination-out", "destination-over", "devanagari", "disc", "discard", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede", "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er", "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er", "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et", "ethiopic-halehame-gez", "ethiopic-halehame-om-et", "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et", "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig", "ew-resize", "expanded", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "footnotes", "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove", "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer", "landscape", "lao", "large", "larger", "left", "level", "lighter", "line-through", "linear", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian", "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lower-roman", "lowercase", "ltr", "malayalam", "match", "media-controls-background", "media-current-time-display", "media-fullscreen-button", "media-mute-button", "media-play-button", "media-return-to-realtime-button", "media-rewind-button", "media-seek-back-button", "media-seek-forward-button", "media-slider", "media-sliderthumb", "media-time-remaining-display", "media-volume-slider", "media-volume-slider-container", "media-volume-sliderthumb", "medium", "menu", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic", "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote", "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "persian", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "round", "row-resize", "rtl", "run-in", "running", "s-resize", "sans-serif", "scroll", "scrollbar", "se-resize", "searchfield", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama", "single", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "solid", "somali", "source-atop", "source-in", "source-out", "source-over", "space", "square", "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub", "subpixel-antialiased", "super", "sw-resize", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er", "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top", "transparent", "ultra-condensed", "ultra-expanded", "underline", "up", "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal", "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "x-large", "x-small", "xor", "xx-large", "xx-small"]);
        CodeMirror.defineMIME("text/css", {
                atMediaTypes: atMediaTypes,
                atMediaFeatures: atMediaFeatures,
                propertyKeywords: propertyKeywords,
                colorKeywords: colorKeywords,
                valueKeywords: valueKeywords,
                hooks: {
                    "<": function (stream, state) {
                        function tokenSGMLComment(stream, state) {
                            for (var ch, dashes = 0; null != (ch = stream.next());) {
                                if (dashes >= 2 && ">" == ch) {
                                    state.tokenize = null;
                                    break
                                }
                                dashes = "-" == ch ? dashes + 1 : 0
                            }
                            return ["comment", "comment"]
                        }
                        return stream.eat("!") ? (state.tokenize = tokenSGMLComment, tokenSGMLComment(stream, state)) : void 0
                    },
                    "/": function (stream, state) {
                        return stream.eat("*") ? (state.tokenize = tokenCComment, tokenCComment(stream, state)) : !1
                    }
                },
                name: "css-base"
            }),
            CodeMirror.defineMIME("text/x-scss", {
                atMediaTypes: atMediaTypes,
                atMediaFeatures: atMediaFeatures,
                propertyKeywords: propertyKeywords,
                colorKeywords: colorKeywords,
                valueKeywords: valueKeywords,
                allowNested: !0,
                hooks: {
                    ":": function (stream) {
                        return stream.match(/\s*{/) ? [null, "{"] : !1
                    },
                    $: function (stream) {
                        return stream.match(/^[\w-]+/),
                            ":" == stream.peek() ? ["variable", "variable-definition"] : ["variable", "variable"]
                    },
                    "/": function (stream, state) {
                        return stream.eat("/") ? (stream.skipToEnd(), ["comment", "comment"]) : stream.eat("*") ? (state.tokenize = tokenCComment, tokenCComment(stream, state)) : ["operator", "operator"]
                    },
                    "#": function (stream) {
                        return stream.eat("{") ? ["operator", "interpolation"] : (stream.eatWhile(/[\w\\\-]/), ["atom", "hash"])
                    }
                },
                name: "css-base"
            })
    }(), angular.module("ui.codemirror", []).constant("uiCodemirrorConfig", {}).directive("uiCodemirror", ["uiCodemirrorConfig",
        function (uiCodemirrorConfig) {
            "use strict";
            return {
                restrict: "EA",
                require: "?ngModel",
                priority: 1,
                compile: function (tElement) {
                    if (angular.isUndefined(window.CodeMirror)) throw new Error("ui-codemirror need CodeMirror to work... (o rly?)");
                    var value = tElement.text(),
                        codeMirror = new CodeMirror(function (cm_el) {
                            angular.forEach(tElement.prop("attributes"),
                                    function (a) {
                                        "ui-codemirror" === a.name ? cm_el.setAttribute("ui-codemirror-opts", a.textContent) : cm_el.setAttribute(a.name, a.textContent)
                                    }),
                                tElement.parent().length <= 0 && tElement.wrap("<div>"),
                                tElement.replaceWith(cm_el)
                        }, {
                            value: value
                        });
                    return function (scope, iElement, iAttrs, ngModel) {
                        function updateOptions(newValues) {
                            for (var key in newValues) newValues.hasOwnProperty(key) && codeMirror.setOption(key, newValues[key])
                        }
                        var options, opts;
                        options = uiCodemirrorConfig.codemirror || {},
                            opts = angular.extend({},
                                options, scope.$eval(iAttrs.uiCodemirror), scope.$eval(iAttrs.uiCodemirrorOpts)),
                            updateOptions(opts),
                            angular.isDefined(scope[iAttrs.uiCodemirror]) && scope.$watch(iAttrs.uiCodemirror, updateOptions, !0),
                            codeMirror.on("change",
                                function (instance) {
                                    var newValue = instance.getValue();
                                    ngModel && newValue !== ngModel.$viewValue && ngModel.$setViewValue(newValue),
                                        scope.$$phase || scope.$apply()
                                }),
                            ngModel && (ngModel.$formatters.push(function (value) {
                                if (angular.isUndefined(value) || null === value) return "";
                                if (angular.isObject(value) || angular.isArray(value)) throw new Error("ui-codemirror cannot use an object or an array as a model");
                                return value
                            }), ngModel.$render = function () {
                                var safeViewValue = ngModel.$viewValue || "";
                                codeMirror.setValue(safeViewValue)
                            }),
                            iAttrs.uiRefresh && scope.$watch(iAttrs.uiRefresh,
                                function (newVal, oldVal) {
                                    newVal !== oldVal && codeMirror.refresh()
                                }),
                            angular.isFunction(opts.onLoad) && opts.onLoad(codeMirror)
                    }
                }
            }
        }
    ]), d3 = function () {
        function d3_number(x) {
            return null != x && !isNaN(x)
        }

        function d3_zipLength(d) {
            return d.length
        }

        function d3_range_integerScale(x) {
            for (var k = 1; x * k % 1;) k *= 10;
            return k
        }

        function d3_class(ctor, properties) {
            try {
                for (var key in properties) Object.defineProperty(ctor.prototype, key, {
                    value: properties[key],
                    enumerable: !1
                })
            } catch (e) {
                ctor.prototype = properties
            }
        }

        function d3_Map() {}

        function d3_Set() {}

        function d3_rebind(target, source, method) {
            return function () {
                var value = method.apply(source, arguments);
                return value === source ? target : value
            }
        }

        function d3_vendorSymbol(object, name) {
            if (name in object) return name;
            name = name.charAt(0).toUpperCase() + name.substring(1);
            for (var i = 0,
                    n = d3_vendorPrefixes.length; n > i; ++i) {
                var prefixName = d3_vendorPrefixes[i] + name;
                if (prefixName in object) return prefixName
            }
        }

        function d3_arrayCopy(pseudoarray) {
            for (var i = pseudoarray.length,
                    array = new Array(i); i--;) array[i] = pseudoarray[i];
            return array
        }

        function d3_arraySlice(pseudoarray) {
            return Array.prototype.slice.call(pseudoarray)
        }

        function d3_noop() {}

        function d3_dispatch() {}

        function d3_dispatch_event(dispatch) {
            function event() {
                for (var l, z = listeners,
                        i = -1,
                        n = z.length; ++i < n;)(l = z[i].on) && l.apply(this, arguments);
                return dispatch
            }
            var listeners = [],
                listenerByName = new d3_Map;
            return event.on = function (name, listener) {
                    var i, l = listenerByName.get(name);
                    return arguments.length < 2 ? l && l.on : (l && (l.on = null, listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1)), listenerByName.remove(name)), listener && listeners.push(listenerByName.set(name, {
                        on: listener
                    })), dispatch)
                },
                event
        }

        function d3_eventPreventDefault() {
            d3.event.preventDefault()
        }

        function d3_eventSource() {
            for (var s, e = d3.event; s = e.sourceEvent;) e = s;
            return e
        }

        function d3_eventDispatch(target) {
            for (var dispatch = new d3_dispatch,
                    i = 0,
                    n = arguments.length; ++i < n;) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
            return dispatch.of = function (thiz, argumentz) {
                    return function (e1) {
                        try {
                            var e0 = e1.sourceEvent = d3.event;
                            e1.target = target,
                                d3.event = e1,
                                dispatch[e1.type].apply(thiz, argumentz)
                        } finally {
                            d3.event = e0
                        }
                    }
                },
                dispatch
        }

        function d3_selection(groups) {
            return d3_subclass(groups, d3_selectionPrototype),
                groups
        }

        function d3_selection_selector(selector) {
            return "function" == typeof selector ? selector : function () {
                return d3_select(selector, this)
            }
        }

        function d3_selection_selectorAll(selector) {
            return "function" == typeof selector ? selector : function () {
                return d3_selectAll(selector, this)
            }
        }

        function d3_selection_attr(name, value) {
            function attrNull() {
                this.removeAttribute(name)
            }

            function attrNullNS() {
                this.removeAttributeNS(name.space, name.local)
            }

            function attrConstant() {
                this.setAttribute(name, value)
            }

            function attrConstantNS() {
                this.setAttributeNS(name.space, name.local, value)
            }

            function attrFunction() {
                var x = value.apply(this, arguments);
                null == x ? this.removeAttribute(name) : this.setAttribute(name, x)
            }

            function attrFunctionNS() {
                var x = value.apply(this, arguments);
                null == x ? this.removeAttributeNS(name.space, name.local) : this.setAttributeNS(name.space, name.local, x)
            }
            return name = d3.ns.qualify(name),
                null == value ? name.local ? attrNullNS : attrNull : "function" == typeof value ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant
        }

        function d3_collapse(s) {
            return s.trim().replace(/\s+/g, " ")
        }

        function d3_selection_classedRe(name) {
            return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g")
        }

        function d3_selection_classed(name, value) {
            function classedConstant() {
                for (var i = -1; ++i < n;) name[i](this, value)
            }

            function classedFunction() {
                for (var i = -1,
                        x = value.apply(this, arguments); ++i < n;) name[i](this, x)
            }
            name = name.trim().split(/\s+/).map(d3_selection_classedName);
            var n = name.length;
            return "function" == typeof value ? classedFunction : classedConstant
        }

        function d3_selection_classedName(name) {
            var re = d3_selection_classedRe(name);
            return function (node, value) {
                if (c = node.classList) return value ? c.add(name) : c.remove(name);
                var c = node.getAttribute("class") || "";
                value ? (re.lastIndex = 0, re.test(c) || node.setAttribute("class", d3_collapse(c + " " + name))) : node.setAttribute("class", d3_collapse(c.replace(re, " ")))
            }
        }

        function d3_selection_style(name, value, priority) {
            function styleNull() {
                this.style.removeProperty(name)
            }

            function styleConstant() {
                this.style.setProperty(name, value, priority)
            }

            function styleFunction() {
                var x = value.apply(this, arguments);
                null == x ? this.style.removeProperty(name) : this.style.setProperty(name, x, priority)
            }
            return null == value ? styleNull : "function" == typeof value ? styleFunction : styleConstant
        }

        function d3_selection_property(name, value) {
            function propertyNull() {
                delete this[name]
            }

            function propertyConstant() {
                this[name] = value
            }

            function propertyFunction() {
                var x = value.apply(this, arguments);
                null == x ? delete this[name] : this[name] = x
            }
            return null == value ? propertyNull : "function" == typeof value ? propertyFunction : propertyConstant
        }

        function d3_selection_creator(name) {
            return "function" == typeof name ? name : (name = d3.ns.qualify(name)).local ?
                function () {
                    return d3_document.createElementNS(name.space, name.local)
                } : function () {
                    return d3_document.createElementNS(this.namespaceURI, name)
                }
        }

        function d3_selection_dataNode(data) {
            return {
                __data__: data
            }
        }

        function d3_selection_filter(selector) {
            return function () {
                return d3_selectMatches(this, selector)
            }
        }

        function d3_selection_sortComparator(comparator) {
            return arguments.length || (comparator = d3.ascending),
                function (a, b) {
                    return a && b ? comparator(a.__data__, b.__data__) : !a - !b
                }
        }

        function d3_selection_each(groups, callback) {
            for (var j = 0,
                    m = groups.length; m > j; j++)
                for (var node, group = groups[j], i = 0, n = group.length; n > i; i++)(node = group[i]) && callback(node, i, j);
            return groups
        }

        function d3_selection_enter(selection) {
            return d3_subclass(selection, d3_selection_enterPrototype),
                selection
        }

        function d3_selection_enterInsertBefore(enter) {
            var i0, j0;
            return function (d, i, j) {
                var node, group = enter[j].update,
                    n = group.length;
                for (j != j0 && (j0 = j, i0 = 0), i >= i0 && (i0 = i + 1); !(node = group[i0]) && ++i0 < n;);
                return node
            }
        }

        function d3_selection_on(type, listener, capture) {
            function onRemove() {
                var l = this[name];
                l && (this.removeEventListener(type, l, l.$), delete this[name])
            }

            function onAdd() {
                var l = wrap(listener, d3_array(arguments));
                onRemove.call(this),
                    this.addEventListener(type, this[name] = l, l.$ = capture),
                    l._ = listener
            }

            function removeAll() {
                var match, re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$");
                for (var name in this)
                    if (match = name.match(re)) {
                        var l = this[name];
                        this.removeEventListener(match[1], l, l.$),
                            delete this[name]
                    }
            }
            var name = "__on" + type,
                i = type.indexOf("."),
                wrap = d3_selection_onListener;
            i > 0 && (type = type.substring(0, i));
            var filter = d3_selection_onFilters.get(type);
            return filter && (type = filter, wrap = d3_selection_onFilter),
                i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll
        }

        function d3_selection_onListener(listener, argumentz) {
            return function (e) {
                var o = d3.event;
                d3.event = e,
                    argumentz[0] = this.__data__;
                try {
                    listener.apply(this, argumentz)
                } finally {
                    d3.event = o
                }
            }
        }

        function d3_selection_onFilter(listener, argumentz) {
            var l = d3_selection_onListener(listener, argumentz);
            return function (e) {
                var target = this,
                    related = e.relatedTarget;
                related && (related === target || 8 & related.compareDocumentPosition(target)) || l.call(target, e)
            }
        }

        function d3_event_dragSuppress() {
            var name = ".dragsuppress-" + ++d3_event_dragId,
                touchmove = "touchmove" + name,
                selectstart = "selectstart" + name,
                dragstart = "dragstart" + name,
                click = "click" + name,
                w = d3.select(d3_window).on(touchmove, d3_eventPreventDefault).on(selectstart, d3_eventPreventDefault).on(dragstart, d3_eventPreventDefault),
                style = d3_documentElement.style,
                select = style[d3_event_dragSelect];
            return style[d3_event_dragSelect] = "none",
                function (suppressClick) {
                    function off() {
                        w.on(click, null)
                    }
                    w.on(name, null),
                        style[d3_event_dragSelect] = select,
                        suppressClick && (w.on(click,
                            function () {
                                d3_eventPreventDefault(),
                                    off()
                            }, !0), setTimeout(off, 0))
                }
        }

        function d3_mousePoint(container, e) {
            var svg = container.ownerSVGElement || container;
            if (svg.createSVGPoint) {
                var point = svg.createSVGPoint();
                if (0 > d3_mouse_bug44083 && (d3_window.scrollX || d3_window.scrollY)) {
                    svg = d3.select("body").append("svg").style({
                            position: "absolute",
                            top: 0,
                            left: 0,
                            margin: 0,
                            padding: 0,
                            border: "none"
                        },
                        "important");
                    var ctm = svg[0][0].getScreenCTM();
                    d3_mouse_bug44083 = !(ctm.f || ctm.e),
                        svg.remove()
                }
                return d3_mouse_bug44083 ? (point.x = e.pageX, point.y = e.pageY) : (point.x = e.clientX, point.y = e.clientY),
                    point = point.matrixTransform(container.getScreenCTM().inverse()), [point.x, point.y]
            }
            var rect = container.getBoundingClientRect();
            return [e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop]
        }

        function d3_Color() {}

        function d3_hsl(h, s, l) {
            return new d3_Hsl(h, s, l)
        }

        function d3_Hsl(h, s, l) {
            this.h = h,
                this.s = s,
                this.l = l
        }

        function d3_hsl_rgb(h, s, l) {
            function v(h) {
                return h > 360 ? h -= 360 : 0 > h && (h += 360),
                    60 > h ? m1 + (m2 - m1) * h / 60 : 180 > h ? m2 : 240 > h ? m1 + (m2 - m1) * (240 - h) / 60 : m1
            }

            function vv(h) {
                return Math.round(255 * v(h))
            }
            var m1, m2;
            return h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h,
                s = isNaN(s) ? 0 : 0 > s ? 0 : s > 1 ? 1 : s,
                l = 0 > l ? 0 : l > 1 ? 1 : l,
                m2 = .5 >= l ? l * (1 + s) : l + s - l * s,
                m1 = 2 * l - m2,
                d3_rgb(vv(h + 120), vv(h), vv(h - 120))
        }

        function d3_sgn(x) {
            return x > 0 ? 1 : 0 > x ? -1 : 0
        }

        function d3_acos(x) {
            return x > 1 ? 0 : -1 > x ? π : Math.acos(x)
        }

        function d3_asin(x) {
            return x > 1 ? π / 2 : -1 > x ? -π / 2 : Math.asin(x)
        }

        function d3_sinh(x) {
            return (Math.exp(x) - Math.exp(-x)) / 2
        }

        function d3_cosh(x) {
            return (Math.exp(x) + Math.exp(-x)) / 2
        }

        function d3_haversin(x) {
            return (x = Math.sin(x / 2)) * x
        }

        function d3_hcl(h, c, l) {
            return new d3_Hcl(h, c, l)
        }

        function d3_Hcl(h, c, l) {
            this.h = h,
                this.c = c,
                this.l = l
        }

        function d3_hcl_lab(h, c, l) {
            return isNaN(h) && (h = 0),
                isNaN(c) && (c = 0),
                d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c)
        }

        function d3_lab(l, a, b) {
            return new d3_Lab(l, a, b)
        }

        function d3_Lab(l, a, b) {
            this.l = l,
                this.a = a,
                this.b = b
        }

        function d3_lab_rgb(l, a, b) {
            var y = (l + 16) / 116,
                x = y + a / 500,
                z = y - b / 200;
            return x = d3_lab_xyz(x) * d3_lab_X,
                y = d3_lab_xyz(y) * d3_lab_Y,
                z = d3_lab_xyz(z) * d3_lab_Z,
                d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z))
        }

        function d3_lab_hcl(l, a, b) {
            return l > 0 ? d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : d3_hcl(0 / 0, 0 / 0, l)
        }

        function d3_lab_xyz(x) {
            return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037
        }

        function d3_xyz_lab(x) {
            return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29
        }

        function d3_xyz_rgb(r) {
            return Math.round(255 * (.00304 >= r ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055))
        }

        function d3_rgbNumber(value) {
            return d3_rgb(value >> 16, value >> 8 & 255, 255 & value)
        }

        function d3_rgbString(value) {
            return d3_rgbNumber(value) + ""
        }

        function d3_rgb(r, g, b) {
            return new d3_Rgb(r, g, b)
        }

        function d3_Rgb(r, g, b) {
            this.r = r,
                this.g = g,
                this.b = b
        }

        function d3_rgb_hex(v) {
            return 16 > v ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16)
        }

        function d3_rgb_parse(format, rgb, hsl) {
            var m1, m2, name, r = 0,
                g = 0,
                b = 0;
            if (m1 = /([a-z]+)\((.*)\)/i.exec(format)) switch (m2 = m1[2].split(","), m1[1]) {
                case "hsl":
                    return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
                case "rgb":
                    return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]))
            }
            return (name = d3_rgb_names.get(format)) ? rgb(name.r, name.g, name.b) : (null != format && "#" === format.charAt(0) && (4 === format.length ? (r = format.charAt(1), r += r, g = format.charAt(2), g += g, b = format.charAt(3), b += b) : 7 === format.length && (r = format.substring(1, 3), g = format.substring(3, 5), b = format.substring(5, 7)), r = parseInt(r, 16), g = parseInt(g, 16), b = parseInt(b, 16)), rgb(r, g, b))
        }

        function d3_rgb_hsl(r, g, b) {
            var h, s, min = Math.min(r /= 255, g /= 255, b /= 255),
                max = Math.max(r, g, b),
                d = max - min,
                l = (max + min) / 2;
            return d ? (s = .5 > l ? d / (max + min) : d / (2 - max - min), h = r == max ? (g - b) / d + (b > g ? 6 : 0) : g == max ? (b - r) / d + 2 : (r - g) / d + 4, h *= 60) : (h = 0 / 0, s = l > 0 && 1 > l ? 0 : h),
                d3_hsl(h, s, l)
        }

        function d3_rgb_lab(r, g, b) {
            r = d3_rgb_xyz(r),
                g = d3_rgb_xyz(g),
                b = d3_rgb_xyz(b);
            var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X),
                y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y),
                z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
            return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z))
        }

        function d3_rgb_xyz(r) {
            return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4)
        }

        function d3_rgb_parseNumber(c) {
            var f = parseFloat(c);
            return "%" === c.charAt(c.length - 1) ? Math.round(2.55 * f) : f
        }

        function d3_functor(v) {
            return "function" == typeof v ? v : function () {
                return v
            }
        }

        function d3_identity(d) {
            return d
        }

        function d3_xhrType(response) {
            return function (url, mimeType, callback) {
                return 2 === arguments.length && "function" == typeof mimeType && (callback = mimeType, mimeType = null),
                    d3_xhr(url, mimeType, response, callback)
            }
        }

        function d3_xhr(url, mimeType, response, callback) {
            function respond() {
                var result, status = request.status;
                if (!status && request.responseText || status >= 200 && 300 > status || 304 === status) {
                    try {
                        result = response.call(xhr, request)
                    } catch (e) {
                        return void dispatch.error.call(xhr, e)
                    }
                    dispatch.load.call(xhr, result)
                } else dispatch.error.call(xhr, request)
            }
            var xhr = {},
                dispatch = d3.dispatch("progress", "load", "error"),
                headers = {},
                request = new XMLHttpRequest,
                responseType = null;
            return !d3_window.XDomainRequest || "withCredentials" in request || !/^(http(s)?:)?\/\//.test(url) || (request = new XDomainRequest),
                "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function () {
                    request.readyState > 3 && respond()
                },
                request.onprogress = function (event) {
                    var o = d3.event;
                    d3.event = event;
                    try {
                        dispatch.progress.call(xhr, request)
                    } finally {
                        d3.event = o
                    }
                },
                xhr.header = function (name, value) {
                    return name = (name + "").toLowerCase(),
                        arguments.length < 2 ? headers[name] : (null == value ? delete headers[name] : headers[name] = value + "", xhr)
                },
                xhr.mimeType = function (value) {
                    return arguments.length ? (mimeType = null == value ? null : value + "", xhr) : mimeType
                },
                xhr.responseType = function (value) {
                    return arguments.length ? (responseType = value, xhr) : responseType
                },
                xhr.response = function (value) {
                    return response = value,
                        xhr
                }, ["get", "post"].forEach(function (method) {
                    xhr[method] = function () {
                        return xhr.send.apply(xhr, [method].concat(d3_array(arguments)))
                    }
                }),
                xhr.send = function (method, data, callback) {
                    if (2 === arguments.length && "function" == typeof data && (callback = data, data = null), request.open(method, url, !0), null == mimeType || "accept" in headers || (headers.accept = mimeType + ",*/*"), request.setRequestHeader)
                        for (var name in headers) request.setRequestHeader(name, headers[name]);
                    return null != mimeType && request.overrideMimeType && request.overrideMimeType(mimeType),
                        null != responseType && (request.responseType = responseType),
                        null != callback && xhr.on("error", callback).on("load",
                            function (request) {
                                callback(null, request)
                            }),
                        request.send(null == data ? null : data),
                        xhr
                },
                xhr.abort = function () {
                    return request.abort(),
                        xhr
                },
                d3.rebind(xhr, dispatch, "on"),
                null == callback ? xhr : xhr.get(d3_xhr_fixCallback(callback))
        }

        function d3_xhr_fixCallback(callback) {
            return 1 === callback.length ?
                function (error, request) {
                    callback(null == error ? request : null)
                } : callback
        }

        function d3_timer_step() {
            var now = d3_timer_mark(),
                delay = d3_timer_sweep() - now;
            delay > 24 ? (isFinite(delay) && (clearTimeout(d3_timer_timeout), d3_timer_timeout = setTimeout(d3_timer_step, delay)), d3_timer_interval = 0) : (d3_timer_interval = 1, d3_timer_frame(d3_timer_step))
        }

        function d3_timer_replace(callback, delay, then) {
            var n = arguments.length;
            2 > n && (delay = 0),
                3 > n && (then = Date.now()),
                d3_timer_active.callback = callback,
                d3_timer_active.time = then + delay
        }

        function d3_timer_mark() {
            var now = Date.now();
            for (d3_timer_active = d3_timer_queueHead; d3_timer_active;) now >= d3_timer_active.time && (d3_timer_active.flush = d3_timer_active.callback(now - d3_timer_active.time)),
                d3_timer_active = d3_timer_active.next;
            return now
        }

        function d3_timer_sweep() {
            for (var t0, t1 = d3_timer_queueHead,
                    time = 1 / 0; t1;) t1.flush ? t1 = t0 ? t0.next = t1.next : d3_timer_queueHead = t1.next : (t1.time < time && (time = t1.time), t1 = (t0 = t1).next);
            return d3_timer_queueTail = t0,
                time
        }

        function d3_formatPrefix(d, i) {
            var k = Math.pow(10, 3 * Math.abs(8 - i));
            return {
                scale: i > 8 ?
                    function (d) {
                        return d / k
                    } : function (d) {
                        return d * k
                    },
                symbol: d
            }
        }

        function d3_format_precision(x, p) {
            return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1)
        }

        function d3_format_typeDefault(x) {
            return x + ""
        }

        function d3_adder() {}

        function d3_adderSum(a, b, o) {
            var x = o.s = a + b,
                bv = x - a,
                av = x - bv;
            o.t = a - av + (b - bv)
        }

        function d3_geo_streamGeometry(geometry, listener) {
            geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type) && d3_geo_streamGeometryType[geometry.type](geometry, listener)
        }

        function d3_geo_streamLine(coordinates, listener, closed) {
            var coordinate, i = -1,
                n = coordinates.length - closed;
            for (listener.lineStart(); ++i < n;) coordinate = coordinates[i],
                listener.point(coordinate[0], coordinate[1]);
            listener.lineEnd()
        }

        function d3_geo_streamPolygon(coordinates, listener) {
            var i = -1,
                n = coordinates.length;
            for (listener.polygonStart(); ++i < n;) d3_geo_streamLine(coordinates[i], listener, 1);
            listener.polygonEnd()
        }

        function d3_geo_areaRingStart() {
            function nextPoint(λ, φ) {
                λ *= d3_radians,
                    φ = φ * d3_radians / 2 + π / 4;
                var dλ = λ - λ0,
                    cosφ = Math.cos(φ),
                    sinφ = Math.sin(φ),
                    k = sinφ0 * sinφ,
                    u = cosφ0 * cosφ + k * Math.cos(dλ),
                    v = k * Math.sin(dλ);
                d3_geo_areaRingSum.add(Math.atan2(v, u)),
                    λ0 = λ,
                    cosφ0 = cosφ,
                    sinφ0 = sinφ
            }
            varλ00, φ00, λ0, cosφ0, sinφ0;
            d3_geo_area.point = function (λ, φ) {
                    d3_geo_area.point = nextPoint,
                        λ0 = (λ00 = λ) * d3_radians,
                        cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4),
                        sinφ0 = Math.sin(φ)
                },
                d3_geo_area.lineEnd = function () {
                    nextPoint(λ00, φ00)
                }
        }

        function d3_geo_cartesian(spherical) {
            varλ = spherical[0],
                φ = spherical[1],
                cosφ = Math.cos(φ);
            return [cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ)]
        }

        function d3_geo_cartesianDot(a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
        }

        function d3_geo_cartesianCross(a, b) {
            return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]]
        }

        function d3_geo_cartesianAdd(a, b) {
            a[0] += b[0],
                a[1] += b[1],
                a[2] += b[2]
        }

        function d3_geo_cartesianScale(vector, k) {
            return [vector[0] * k, vector[1] * k, vector[2] * k]
        }

        function d3_geo_cartesianNormalize(d) {
            var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
            d[0] /= l,
                d[1] /= l,
                d[2] /= l
        }

        function d3_geo_spherical(cartesian) {
            return [Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2])]
        }

        function d3_geo_sphericalEqual(a, b) {
            return Math.abs(a[0] - b[0]) < ε && Math.abs(a[1] - b[1]) < ε
        }

        function d3_geo_centroidPoint(λ, φ) {
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians);
            d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ))
        }

        function d3_geo_centroidPointXYZ(x, y, z) {
            ++d3_geo_centroidW0,
            d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0,
                d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0,
                d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0
        }

        function d3_geo_centroidLineStart() {
            function nextPoint(λ, φ) {
                λ *= d3_radians;
                var cosφ = Math.cos(φ *= d3_radians),
                    x = cosφ * Math.cos(λ),
                    y = cosφ * Math.sin(λ),
                    z = Math.sin(φ),
                    w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
                d3_geo_centroidW1 += w,
                    d3_geo_centroidX1 += w * (x0 + (x0 = x)),
                    d3_geo_centroidY1 += w * (y0 + (y0 = y)),
                    d3_geo_centroidZ1 += w * (z0 + (z0 = z)),
                    d3_geo_centroidPointXYZ(x0, y0, z0)
            }
            var x0, y0, z0;
            d3_geo_centroid.point = function (λ, φ) {
                λ *= d3_radians;
                var cosφ = Math.cos(φ *= d3_radians);
                x0 = cosφ * Math.cos(λ),
                    y0 = cosφ * Math.sin(λ),
                    z0 = Math.sin(φ),
                    d3_geo_centroid.point = nextPoint,
                    d3_geo_centroidPointXYZ(x0, y0, z0)
            }
        }

        function d3_geo_centroidLineEnd() {
            d3_geo_centroid.point = d3_geo_centroidPoint
        }

        function d3_geo_centroidRingStart() {
            function nextPoint(λ, φ) {
                λ *= d3_radians;
                var cosφ = Math.cos(φ *= d3_radians),
                    x = cosφ * Math.cos(λ),
                    y = cosφ * Math.sin(λ),
                    z = Math.sin(φ),
                    cx = y0 * z - z0 * y,
                    cy = z0 * x - x0 * z,
                    cz = x0 * y - y0 * x,
                    m = Math.sqrt(cx * cx + cy * cy + cz * cz),
                    u = x0 * x + y0 * y + z0 * z,
                    v = m && -d3_acos(u) / m,
                    w = Math.atan2(m, u);
                d3_geo_centroidX2 += v * cx,
                    d3_geo_centroidY2 += v * cy,
                    d3_geo_centroidZ2 += v * cz,
                    d3_geo_centroidW1 += w,
                    d3_geo_centroidX1 += w * (x0 + (x0 = x)),
                    d3_geo_centroidY1 += w * (y0 + (y0 = y)),
                    d3_geo_centroidZ1 += w * (z0 + (z0 = z)),
                    d3_geo_centroidPointXYZ(x0, y0, z0)
            }
            varλ00, φ00, x0, y0, z0;
            d3_geo_centroid.point = function (λ, φ) {
                    λ00 = λ,
                        φ00 = φ,
                        d3_geo_centroid.point = nextPoint,
                        λ *= d3_radians;
                    var cosφ = Math.cos(φ *= d3_radians);
                    x0 = cosφ * Math.cos(λ),
                        y0 = cosφ * Math.sin(λ),
                        z0 = Math.sin(φ),
                        d3_geo_centroidPointXYZ(x0, y0, z0)
                },
                d3_geo_centroid.lineEnd = function () {
                    nextPoint(λ00, φ00),
                        d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd,
                        d3_geo_centroid.point = d3_geo_centroidPoint
                }
        }

        function d3_true() {
            return !0
        }

        function d3_geo_clipPolygon(segments, compare, inside, interpolate, listener) {
            var subject = [],
                clip = [];
            if (segments.forEach(function (segment) {
                    if (!((n = segment.length - 1) <= 0)) {
                        var n, p0 = segment[0],
                            p1 = segment[n];
                        if (d3_geo_sphericalEqual(p0, p1)) {
                            listener.lineStart();
                            for (var i = 0; n > i; ++i) listener.point((p0 = segment[i])[0], p0[1]);
                            return void listener.lineEnd()
                        }
                        var a = {
                                point: p0,
                                points: segment,
                                other: null,
                                visited: !1,
                                entry: !0,
                                subject: !0
                            },
                            b = {
                                point: p0,
                                points: [p0],
                                other: a,
                                visited: !1,
                                entry: !1,
                                subject: !1
                            };
                        a.other = b,
                            subject.push(a),
                            clip.push(b),
                            a = {
                                point: p1,
                                points: [p1],
                                other: null,
                                visited: !1,
                                entry: !1,
                                subject: !0
                            },
                            b = {
                                point: p1,
                                points: [p1],
                                other: a,
                                visited: !1,
                                entry: !0,
                                subject: !1
                            },
                            a.other = b,
                            subject.push(a),
                            clip.push(b)
                    }
                }), clip.sort(compare), d3_geo_clipPolygonLinkCircular(subject), d3_geo_clipPolygonLinkCircular(clip), subject.length) {
                if (inside)
                    for (var i = 1,
                            e = !inside(clip[0].point), n = clip.length; n > i; ++i) clip[i].entry = e = !e;
                for (var current, points, point, start = subject[0];;) {
                    for (current = start; current.visited;)
                        if ((current = current.next) === start) return;
                    points = current.points,
                        listener.lineStart();
                    do {
                        if (current.visited = current.other.visited = !0, current.entry) {
                            if (current.subject)
                                for (var i = 0; i < points.length; i++) listener.point((point = points[i])[0], point[1]);
                            else interpolate(current.point, current.next.point, 1, listener);
                            current = current.next
                        } else {
                            if (current.subject) {
                                points = current.prev.points;
                                for (var i = points.length; --i >= 0;) listener.point((point = points[i])[0], point[1])
                            } else interpolate(current.point, current.prev.point, -1, listener);
                            current = current.prev
                        }
                        current = current.other, points = current.points
                    } while (!current.visited);
                    listener.lineEnd()
                }
            }
        }

        function d3_geo_clipPolygonLinkCircular(array) {
            if (n = array.length) {
                for (var n, b, i = 0,
                        a = array[0]; ++i < n;) a.next = b = array[i],
                    b.prev = a,
                    a = b;
                a.next = b = array[0],
                    b.prev = a
            }
        }

        function d3_geo_clip(pointVisible, clipLine, interpolate, polygonContains) {
            return function (listener) {
                function point(λ, φ) {
                    pointVisible(λ, φ) && listener.point(λ, φ)
                }

                function pointLine(λ, φ) {
                    line.point(λ, φ)
                }

                function lineStart() {
                    clip.point = pointLine,
                        line.lineStart()
                }

                function lineEnd() {
                    clip.point = point,
                        line.lineEnd()
                }

                function pointRing(λ, φ) {
                    ringListener.point(λ, φ),
                        ring.push([λ, φ])
                }

                function ringStart() {
                    ringListener.lineStart(),
                        ring = []
                }

                function ringEnd() {
                    pointRing(ring[0][0], ring[0][1]),
                        ringListener.lineEnd();
                    var segment, clean = ringListener.clean(),
                        ringSegments = buffer.buffer(),
                        n = ringSegments.length;
                    if (ring.pop(), polygon.push(ring), ring = null, n) {
                        if (1 & clean) {
                            segment = ringSegments[0];
                            var point, n = segment.length - 1,
                                i = -1;
                            for (listener.lineStart(); ++i < n;) listener.point((point = segment[i])[0], point[1]);
                            return void listener.lineEnd()
                        }
                        n > 1 && 2 & clean && ringSegments.push(ringSegments.pop().concat(ringSegments.shift())),
                            segments.push(ringSegments.filter(d3_geo_clipSegmentLength1))
                    }
                }
                var segments, polygon, ring, line = clipLine(listener),
                    clip = {
                        point: point,
                        lineStart: lineStart,
                        lineEnd: lineEnd,
                        polygonStart: function () {
                            clip.point = pointRing,
                                clip.lineStart = ringStart,
                                clip.lineEnd = ringEnd,
                                segments = [],
                                polygon = [],
                                listener.polygonStart()
                        },
                        polygonEnd: function () {
                            clip.point = point,
                                clip.lineStart = lineStart,
                                clip.lineEnd = lineEnd,
                                segments = d3.merge(segments),
                                segments.length ? d3_geo_clipPolygon(segments, d3_geo_clipSort, null, interpolate, listener) : polygonContains(polygon) && (listener.lineStart(), interpolate(null, null, 1, listener), listener.lineEnd()),
                                listener.polygonEnd(),
                                segments = polygon = null
                        },
                        sphere: function () {
                            listener.polygonStart(),
                                listener.lineStart(),
                                interpolate(null, null, 1, listener),
                                listener.lineEnd(),
                                listener.polygonEnd()
                        }
                    },
                    buffer = d3_geo_clipBufferListener(),
                    ringListener = clipLine(buffer);
                return clip
            }
        }

        function d3_geo_clipSegmentLength1(segment) {
            return segment.length > 1
        }

        function d3_geo_clipBufferListener() {
            var line, lines = [];
            return {
                lineStart: function () {
                    lines.push(line = [])
                },
                point: function (λ, φ) {
                    line.push([λ, φ])
                },
                lineEnd: d3_noop,
                buffer: function () {
                    var buffer = lines;
                    return lines = [],
                        line = null,
                        buffer
                },
                rejoin: function () {
                    lines.length > 1 && lines.push(lines.pop().concat(lines.shift()))
                }
            }
        }

        function d3_geo_clipSort(a, b) {
            return ((a = a.point)[0] < 0 ? a[1] - π / 2 - ε : π / 2 - a[1]) - ((b = b.point)[0] < 0 ? b[1] - π / 2 - ε : π / 2 - b[1])
        }

        function d3_geo_pointInPolygon(point, polygon) {
            var meridian = point[0],
                parallel = point[1],
                meridianNormal = [Math.sin(meridian), -Math.cos(meridian), 0],
                polarAngle = 0,
                polar = !1,
                southPole = !1,
                winding = 0;
            d3_geo_areaRingSum.reset();
            for (var i = 0,
                    n = polygon.length; n > i; ++i) {
                var ring = polygon[i],
                    m = ring.length;
                if (m) {
                    for (var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;;) {
                        j === m && (j = 0),
                            point = ring[j];
                        varλ = point[0],
                            φ = point[1] / 2 + π / 4,
                            sinφ = Math.sin(φ),
                            cosφ = Math.cos(φ),
                            dλ = λ - λ0,
                            antimeridian = Math.abs(dλ) > π,
                            k = sinφ0 * sinφ;
                        if (d3_geo_areaRingSum.add(Math.atan2(k * Math.sin(dλ), cosφ0 * cosφ + k * Math.cos(dλ))), Math.abs(φ) < ε && (southPole = !0), polarAngle += antimeridian ? dλ + (dλ >= 0 ? 2 : -2) * π : dλ, antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
                            var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
                            d3_geo_cartesianNormalize(arc);
                            var intersection = d3_geo_cartesianCross(meridianNormal, arc);
                            d3_geo_cartesianNormalize(intersection);
                            varφarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
                            parallel > φarc && (winding += antimeridian ^ dλ >= 0 ? 1 : -1)
                        }
                        if (!j++) break;
                        λ0 = λ,
                            sinφ0 = sinφ,
                            cosφ0 = cosφ,
                            point0 = point
                    }
                    Math.abs(polarAngle) > ε && (polar = !0)
                }
            }
            return (!southPole && !polar && 0 > d3_geo_areaRingSum || -ε > polarAngle) ^ 1 & winding
        }

        function d3_geo_clipAntimeridianLine(listener) {
            var clean, λ0 = 0 / 0,
                φ0 = 0 / 0,
                sλ0 = 0 / 0;
            return {
                lineStart: function () {
                    listener.lineStart(),
                        clean = 1
                },
                point: function (λ1, φ1) {
                    var sλ1 = λ1 > 0 ? π : -π,
                        dλ = Math.abs(λ1 - λ0);
                    Math.abs(dλ - π) < ε ? (listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? π / 2 : -π / 2), listener.point(sλ0, φ0), listener.lineEnd(), listener.lineStart(), listener.point(sλ1, φ0), listener.point(λ1, φ0), clean = 0) : sλ0 !== sλ1 && dλ >= π && (Math.abs(λ0 - sλ0) < ε && (λ0 -= sλ0 * ε), Math.abs(λ1 - sλ1) < ε && (λ1 -= sλ1 * ε), φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1), listener.point(sλ0, φ0), listener.lineEnd(), listener.lineStart(), listener.point(sλ1, φ0), clean = 0),
                        listener.point(λ0 = λ1, φ0 = φ1),
                        sλ0 = sλ1
                },
                lineEnd: function () {
                    listener.lineEnd(),
                        λ0 = φ0 = 0 / 0
                },
                clean: function () {
                    return 2 - clean
                }
            }
        }

        function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
            var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
            return Math.abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2
        }

        function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
            varφ;
            if (null == from) φ = direction * π / 2,
                listener.point(-π, φ),
                listener.point(0, φ),
                listener.point(π, φ),
                listener.point(π, 0),
                listener.point(π, -φ),
                listener.point(0, -φ),
                listener.point(-π, -φ),
                listener.point(-π, 0),
                listener.point(-π, φ);
            else if (Math.abs(from[0] - to[0]) > ε) {
                var s = (from[0] < to[0] ? 1 : -1) * π;
                φ = direction * s / 2,
                    listener.point(-s, φ),
                    listener.point(0, φ),
                    listener.point(s, φ)
            } else listener.point(to[0], to[1])
        }

        function d3_geo_clipAntimeridianPolygonContains(polygon) {
            return d3_geo_pointInPolygon(d3_geo_clipAntimeridianPoint, polygon)
        }

        function d3_geo_clipCircle(radius) {
            function visible(λ, φ) {
                return Math.cos(λ) * Math.cos(φ) > cr
            }

            function clipLine(listener) {
                var point0, c0, v0, v00, clean;
                return {
                    lineStart: function () {
                        v00 = v0 = !1,
                            clean = 1
                    },
                    point: function (λ, φ) {
                        var point2, point1 = [λ, φ],
                            v = visible(λ, φ),
                            c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (0 > λ ? π : -π), φ) : 0;
                        if (!point0 && (v00 = v0 = v) && listener.lineStart(), v !== v0 && (point2 = intersect(point0, point1), (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) && (point1[0] += ε, point1[1] += ε, v = visible(point1[0], point1[1]))), v !== v0) clean = 0,
                            v ? (listener.lineStart(), point2 = intersect(point1, point0), listener.point(point2[0], point2[1])) : (point2 = intersect(point0, point1), listener.point(point2[0], point2[1]), listener.lineEnd()),
                            point0 = point2;
                        else if (notHemisphere && point0 && smallRadius ^ v) {
                            var t;
                            c & c0 || !(t = intersect(point1, point0, !0)) || (clean = 0, smallRadius ? (listener.lineStart(), listener.point(t[0][0], t[0][1]), listener.point(t[1][0], t[1][1]), listener.lineEnd()) : (listener.point(t[1][0], t[1][1]), listener.lineEnd(), listener.lineStart(), listener.point(t[0][0], t[0][1])))
                        }!v || point0 && d3_geo_sphericalEqual(point0, point1) || listener.point(point1[0], point1[1]),
                            point0 = point1,
                            v0 = v,
                            c0 = c
                    },
                    lineEnd: function () {
                        v0 && listener.lineEnd(),
                            point0 = null
                    },
                    clean: function () {
                        return clean | (v00 && v0) << 1
                    }
                }
            }

            function intersect(a, b, two) {
                var pa = d3_geo_cartesian(a),
                    pb = d3_geo_cartesian(b),
                    n1 = [1, 0, 0],
                    n2 = d3_geo_cartesianCross(pa, pb),
                    n2n2 = d3_geo_cartesianDot(n2, n2),
                    n1n2 = n2[0],
                    determinant = n2n2 - n1n2 * n1n2;
                if (!determinant) return !two && a;
                var c1 = cr * n2n2 / determinant,
                    c2 = -cr * n1n2 / determinant,
                    n1xn2 = d3_geo_cartesianCross(n1, n2),
                    A = d3_geo_cartesianScale(n1, c1),
                    B = d3_geo_cartesianScale(n2, c2);
                d3_geo_cartesianAdd(A, B);
                var u = n1xn2,
                    w = d3_geo_cartesianDot(A, u),
                    uu = d3_geo_cartesianDot(u, u),
                    t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
                if (!(0 > t2)) {
                    var t = Math.sqrt(t2),
                        q = d3_geo_cartesianScale(u, (-w - t) / uu);
                    if (d3_geo_cartesianAdd(q, A), q = d3_geo_spherical(q), !two) return q;
                    var z, λ0 = a[0],
                        λ1 = b[0],
                        φ0 = a[1],
                        φ1 = b[1];
                    λ0 > λ1 && (z = λ0, λ0 = λ1, λ1 = z);
                    varδλ = λ1 - λ0,
                        polar = Math.abs(δλ - π) < ε,
                        meridian = polar || ε > δλ;
                    if (!polar && φ0 > φ1 && (z = φ0, φ0 = φ1, φ1 = z), meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (Math.abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
                        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
                        return d3_geo_cartesianAdd(q1, A), [q, d3_geo_spherical(q1)]
                    }
                }
            }

            function code(λ, φ) {
                var r = smallRadius ? radius : π - radius,
                    code = 0;
                return -r > λ ? code |= 1 : λ > r && (code |= 2), -r > φ ? code |= 4 : φ > r && (code |= 8),
                    code
            }

            function polygonContains(polygon) {
                return d3_geo_pointInPolygon(point, polygon)
            }
            var cr = Math.cos(radius),
                smallRadius = cr > 0,
                point = [radius, 0],
                notHemisphere = Math.abs(cr) > ε,
                interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
            return d3_geo_clip(visible, clipLine, interpolate, polygonContains)
        }

        function d3_geo_clipView(x0, y0, x1, y1) {
            function corner(p, direction) {
                return Math.abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : Math.abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : Math.abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2
            }

            function compare(a, b) {
                return comparePoints(a.point, b.point)
            }

            function comparePoints(a, b) {
                var ca = corner(a, 1),
                    cb = corner(b, 1);
                return ca !== cb ? ca - cb : 0 === ca ? b[1] - a[1] : 1 === ca ? a[0] - b[0] : 2 === ca ? a[1] - b[1] : b[0] - a[0]
            }

            function clipLine(a, b) {
                var dx = b[0] - a[0],
                    dy = b[1] - a[1],
                    t = [0, 1];
                return Math.abs(dx) < ε && Math.abs(dy) < ε ? x0 <= a[0] && a[0] <= x1 && y0 <= a[1] && a[1] <= y1 : d3_geo_clipViewT(x0 - a[0], dx, t) && d3_geo_clipViewT(a[0] - x1, -dx, t) && d3_geo_clipViewT(y0 - a[1], dy, t) && d3_geo_clipViewT(a[1] - y1, -dy, t) ? (t[1] < 1 && (b[0] = a[0] + t[1] * dx, b[1] = a[1] + t[1] * dy), t[0] > 0 && (a[0] += t[0] * dx, a[1] += t[0] * dy), !0) : !1
            }
            return function (listener) {
                function inside(point) {
                    var a = corner(point, -1),
                        i = insidePolygon([0 === a || 3 === a ? x0 : x1, a > 1 ? y1 : y0]);
                    return i
                }

                function insidePolygon(p) {
                    for (var wn = 0,
                            n = polygon.length,
                            y = p[1], i = 0; n > i; ++i)
                        for (var b, j = 1,
                                v = polygon[i], m = v.length, a = v[0]; m > j; ++j) b = v[j],
                            a[1] <= y ? b[1] > y && isLeft(a, b, p) > 0 && ++wn : b[1] <= y && isLeft(a, b, p) < 0 && --wn,
                            a = b;
                    return 0 !== wn
                }

                function isLeft(a, b, c) {
                    return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1])
                }

                function interpolate(from, to, direction, listener) {
                    var a = 0,
                        a1 = 0;
                    if (null == from || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
                        do listener.point(0 === a || 3 === a ? x0 : x1, a > 1 ? y1 : y0);
                        while ((a = (a + direction + 4) % 4) !== a1)
                    } else listener.point(to[0], to[1])
                }

                function visible(x, y) {
                    return x >= x0 && x1 >= x && y >= y0 && y1 >= y
                }

                function point(x, y) {
                    visible(x, y) && listener.point(x, y)
                }

                function lineStart() {
                    clip.point = linePoint,
                        polygon && polygon.push(ring = []),
                        first = !0,
                        v_ = !1,
                        x_ = y_ = 0 / 0
                }

                function lineEnd() {
                    segments && (linePoint(x__, y__), v__ && v_ && bufferListener.rejoin(), segments.push(bufferListener.buffer())),
                        clip.point = point,
                        v_ && listener.lineEnd()
                }

                function linePoint(x, y) {
                    x = Math.max(-d3_geo_clipViewMAX, Math.min(d3_geo_clipViewMAX, x)),
                        y = Math.max(-d3_geo_clipViewMAX, Math.min(d3_geo_clipViewMAX, y));
                    var v = visible(x, y);
                    if (polygon && ring.push([x, y]), first) x__ = x,
                        y__ = y,
                        v__ = v,
                        first = !1,
                        v && (listener.lineStart(), listener.point(x, y));
                    else if (v && v_) listener.point(x, y);
                    else {
                        var a = [x_, y_],
                            b = [x, y];
                        clipLine(a, b) ? (v_ || (listener.lineStart(), listener.point(a[0], a[1])), listener.point(b[0], b[1]), v || listener.lineEnd()) : v && (listener.lineStart(), listener.point(x, y))
                    }
                    x_ = x,
                        y_ = y,
                        v_ = v
                }
                var segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, listener_ = listener,
                    bufferListener = d3_geo_clipBufferListener(),
                    clip = {
                        point: point,
                        lineStart: lineStart,
                        lineEnd: lineEnd,
                        polygonStart: function () {
                            listener = bufferListener,
                                segments = [],
                                polygon = []
                        },
                        polygonEnd: function () {
                            listener = listener_,
                                (segments = d3.merge(segments)).length ? (listener.polygonStart(), d3_geo_clipPolygon(segments, compare, inside, interpolate, listener), listener.polygonEnd()) : insidePolygon([x0, y0]) && (listener.polygonStart(), listener.lineStart(), interpolate(null, null, 1, listener), listener.lineEnd(), listener.polygonEnd()),
                                segments = polygon = ring = null
                        }
                    };
                return clip
            }
        }

        function d3_geo_clipViewT(num, denominator, t) {
            if (Math.abs(denominator) < ε) return 0 >= num;
            var u = num / denominator;
            if (denominator > 0) {
                if (u > t[1]) return !1;
                u > t[0] && (t[0] = u)
            } else {
                if (u < t[0]) return !1;
                u < t[1] && (t[1] = u)
            }
            return !0
        }

        function d3_geo_compose(a, b) {
            function compose(x, y) {
                return x = a(x, y),
                    b(x[0], x[1])
            }
            return a.invert && b.invert && (compose.invert = function (x, y) {
                    return x = b.invert(x, y),
                        x && a.invert(x[0], x[1])
                }),
                compose
        }

        function d3_geo_conic(projectAt) {
            varφ0 = 0,
                φ1 = π / 3,
                m = d3_geo_projectionMutator(projectAt),
                p = m(φ0, φ1);
            return p.parallels = function (_) {
                    return arguments.length ? m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180) : [φ0 / π * 180, φ1 / π * 180]
                },
                p
        }

        function d3_geo_conicEqualArea(φ0, φ1) {
            function forward(λ, φ) {
                varρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
                return [ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ)]
            }
            var sinφ0 = Math.sin(φ0),
                n = (sinφ0 + Math.sin(φ1)) / 2,
                C = 1 + sinφ0 * (2 * n - sinφ0),
                ρ0 = Math.sqrt(C) / n;
            return forward.invert = function (x, y) {
                    varρ0_y = ρ0 - y;
                    return [Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n))]
                },
                forward
        }

        function d3_geo_pathAreaRingStart() {
            function nextPoint(x, y) {
                d3_geo_pathAreaPolygon += y0 * x - x0 * y,
                    x0 = x,
                    y0 = y
            }
            var x00, y00, x0, y0;
            d3_geo_pathArea.point = function (x, y) {
                    d3_geo_pathArea.point = nextPoint,
                        x00 = x0 = x,
                        y00 = y0 = y
                },
                d3_geo_pathArea.lineEnd = function () {
                    nextPoint(x00, y00)
                }
        }

        function d3_geo_pathBoundsPoint(x, y) {
            d3_geo_pathBoundsX0 > x && (d3_geo_pathBoundsX0 = x),
                x > d3_geo_pathBoundsX1 && (d3_geo_pathBoundsX1 = x),
                d3_geo_pathBoundsY0 > y && (d3_geo_pathBoundsY0 = y),
                y > d3_geo_pathBoundsY1 && (d3_geo_pathBoundsY1 = y)
        }

        function d3_geo_pathBuffer() {
            function point(x, y) {
                buffer.push("M", x, ",", y, pointCircle)
            }

            function pointLineStart(x, y) {
                buffer.push("M", x, ",", y),
                    stream.point = pointLine
            }

            function pointLine(x, y) {
                buffer.push("L", x, ",", y)
            }

            function lineEnd() {
                stream.point = point
            }

            function lineEndPolygon() {
                buffer.push("Z")
            }
            var pointCircle = d3_geo_pathBufferCircle(4.5),
                buffer = [],
                stream = {
                    point: point,
                    lineStart: function () {
                        stream.point = pointLineStart
                    },
                    lineEnd: lineEnd,
                    polygonStart: function () {
                        stream.lineEnd = lineEndPolygon
                    },
                    polygonEnd: function () {
                        stream.lineEnd = lineEnd,
                            stream.point = point
                    },
                    pointRadius: function (_) {
                        return pointCircle = d3_geo_pathBufferCircle(_),
                            stream
                    },
                    result: function () {
                        if (buffer.length) {
                            var result = buffer.join("");
                            return buffer = [],
                                result
                        }
                    }
                };
            return stream
        }

        function d3_geo_pathBufferCircle(radius) {
            return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z"
        }

        function d3_geo_pathCentroidPoint(x, y) {
            d3_geo_centroidX0 += x,
                d3_geo_centroidY0 += y,
                ++d3_geo_centroidZ0
        }

        function d3_geo_pathCentroidLineStart() {
            function nextPoint(x, y) {
                var dx = x - x0,
                    dy = y - y0,
                    z = Math.sqrt(dx * dx + dy * dy);
                d3_geo_centroidX1 += z * (x0 + x) / 2,
                    d3_geo_centroidY1 += z * (y0 + y) / 2,
                    d3_geo_centroidZ1 += z,
                    d3_geo_pathCentroidPoint(x0 = x, y0 = y)
            }
            var x0, y0;
            d3_geo_pathCentroid.point = function (x, y) {
                d3_geo_pathCentroid.point = nextPoint,
                    d3_geo_pathCentroidPoint(x0 = x, y0 = y)
            }
        }

        function d3_geo_pathCentroidLineEnd() {
            d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint
        }

        function d3_geo_pathCentroidRingStart() {
            function nextPoint(x, y) {
                var dx = x - x0,
                    dy = y - y0,
                    z = Math.sqrt(dx * dx + dy * dy);
                d3_geo_centroidX1 += z * (x0 + x) / 2,
                    d3_geo_centroidY1 += z * (y0 + y) / 2,
                    d3_geo_centroidZ1 += z,
                    z = y0 * x - x0 * y,
                    d3_geo_centroidX2 += z * (x0 + x),
                    d3_geo_centroidY2 += z * (y0 + y),
                    d3_geo_centroidZ2 += 3 * z,
                    d3_geo_pathCentroidPoint(x0 = x, y0 = y)
            }
            var x00, y00, x0, y0;
            d3_geo_pathCentroid.point = function (x, y) {
                    d3_geo_pathCentroid.point = nextPoint,
                        d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y)
                },
                d3_geo_pathCentroid.lineEnd = function () {
                    nextPoint(x00, y00)
                }
        }

        function d3_geo_pathContext(context) {
            function point(x, y) {
                context.moveTo(x, y),
                    context.arc(x, y, pointRadius, 0, 2 * π)
            }

            function pointLineStart(x, y) {
                context.moveTo(x, y),
                    stream.point = pointLine
            }

            function pointLine(x, y) {
                context.lineTo(x, y)
            }

            function lineEnd() {
                stream.point = point
            }

            function lineEndPolygon() {
                context.closePath()
            }
            var pointRadius = 4.5,
                stream = {
                    point: point,
                    lineStart: function () {
                        stream.point = pointLineStart
                    },
                    lineEnd: lineEnd,
                    polygonStart: function () {
                        stream.lineEnd = lineEndPolygon
                    },
                    polygonEnd: function () {
                        stream.lineEnd = lineEnd,
                            stream.point = point
                    },
                    pointRadius: function (_) {
                        return pointRadius = _,
                            stream
                    },
                    result: d3_noop
                };
            return stream
        }

        function d3_geo_resample(project) {
            function resample(stream) {
                function point(x, y) {
                    x = project(x, y),
                        stream.point(x[0], x[1])
                }

                function lineStart() {
                    x0 = 0 / 0,
                        resample.point = linePoint,
                        stream.lineStart()
                }

                function linePoint(λ, φ) {
                    var c = d3_geo_cartesian([λ, φ]),
                        p = project(λ, φ);
                    resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream),
                        stream.point(x0, y0)
                }

                function lineEnd() {
                    resample.point = point,
                        stream.lineEnd()
                }

                function ringStart() {
                    lineStart(),
                        resample.point = ringPoint,
                        resample.lineEnd = ringEnd
                }

                function ringPoint(λ, φ) {
                    linePoint(λ00 = λ, φ00 = φ),
                        x00 = x0,
                        y00 = y0,
                        a00 = a0,
                        b00 = b0,
                        c00 = c0,
                        resample.point = linePoint
                }

                function ringEnd() {
                    resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream),
                        resample.lineEnd = lineEnd,
                        lineEnd()
                }
                varλ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0, resample = {
                    point: point,
                    lineStart: lineStart,
                    lineEnd: lineEnd,
                    polygonStart: function () {
                        stream.polygonStart(),
                            resample.lineStart = ringStart
                    },
                    polygonEnd: function () {
                        stream.polygonEnd(),
                            resample.lineStart = lineStart
                    }
                };
                return resample
            }

            function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
                var dx = x1 - x0,
                    dy = y1 - y0,
                    d2 = dx * dx + dy * dy;
                if (d2 > 4 * δ2 && depth--) {
                    var a = a0 + a1,
                        b = b0 + b1,
                        c = c0 + c1,
                        m = Math.sqrt(a * a + b * b + c * c),
                        φ2 = Math.asin(c /= m),
                        λ2 = Math.abs(Math.abs(c) - 1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a),
                        p = project(λ2, φ2),
                        x2 = p[0],
                        y2 = p[1],
                        dx2 = x2 - x0,
                        dy2 = y2 - y0,
                        dz = dy * dx2 - dx * dy2;
                    (dz * dz / d2 > δ2 || Math.abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || cosMinDistance > a0 * a1 + b0 * b1 + c0 * c1) && (resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream), stream.point(x2, y2), resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream))
                }
            }
            varδ2 = .5,
                cosMinDistance = Math.cos(30 * d3_radians),
                maxDepth = 16;
            return resample.precision = function (_) {
                    return arguments.length ? (maxDepth = (δ2 = _ * _) > 0 && 16, resample) : Math.sqrt(δ2)
                },
                resample
        }

        function d3_geo_pathProjectStream(project) {
            var resample = d3_geo_resample(function (λ, φ) {
                return project([λ * d3_degrees, φ * d3_degrees])
            });
            return function (stream) {
                return stream = resample(stream), {
                    point: function (λ, φ) {
                        stream.point(λ * d3_radians, φ * d3_radians)
                    },
                    sphere: function () {
                        stream.sphere()
                    },
                    lineStart: function () {
                        stream.lineStart()
                    },
                    lineEnd: function () {
                        stream.lineEnd()
                    },
                    polygonStart: function () {
                        stream.polygonStart()
                    },
                    polygonEnd: function () {
                        stream.polygonEnd()
                    }
                }
            }
        }

        function d3_geo_projection(project) {
            return d3_geo_projectionMutator(function () {
                return project
            })()
        }

        function d3_geo_projectionMutator(projectAt) {
            function projection(point) {
                return point = projectRotate(point[0] * d3_radians, point[1] * d3_radians), [point[0] * k + δx, δy - point[1] * k]
            }

            function invert(point) {
                return point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k),
                    point && [point[0] * d3_degrees, point[1] * d3_degrees]
            }

            function reset() {
                projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
                var center = project(λ, φ);
                returnδx = x - center[0] * k,
                    δy = y + center[1] * k,
                    invalidate()
            }

            function invalidate() {
                return stream && (stream.valid = !1, stream = null),
                    projection
            }
            var project, rotate, projectRotate, δx, δy, stream, projectResample = d3_geo_resample(function (x, y) {
                    return x = project(x, y), [x[0] * k + δx, δy - x[1] * k]
                }),
                k = 150,
                x = 480,
                y = 250,
                λ = 0,
                φ = 0,
                δλ = 0,
                δφ = 0,
                δγ = 0,
                preclip = d3_geo_clipAntimeridian,
                postclip = d3_identity,
                clipAngle = null,
                clipExtent = null;
            return projection.stream = function (output) {
                    return stream && (stream.valid = !1),
                        stream = d3_geo_projectionRadiansRotate(rotate, preclip(projectResample(postclip(output)))),
                        stream.valid = !0,
                        stream
                },
                projection.clipAngle = function (_) {
                    return arguments.length ? (preclip = null == _ ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians), invalidate()) : clipAngle
                },
                projection.clipExtent = function (_) {
                    return arguments.length ? (clipExtent = _, postclip = null == _ ? d3_identity : d3_geo_clipView(_[0][0], _[0][1], _[1][0], _[1][1]), invalidate()) : clipExtent
                },
                projection.scale = function (_) {
                    return arguments.length ? (k = +_, reset()) : k
                },
                projection.translate = function (_) {
                    return arguments.length ? (x = +_[0], y = +_[1], reset()) : [x, y]
                },
                projection.center = function (_) {
                    return arguments.length ? (λ = _[0] % 360 * d3_radians, φ = _[1] % 360 * d3_radians, reset()) : [λ * d3_degrees, φ * d3_degrees]
                },
                projection.rotate = function (_) {
                    return arguments.length ? (δλ = _[0] % 360 * d3_radians, δφ = _[1] % 360 * d3_radians, δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0, reset()) : [δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees]
                },
                d3.rebind(projection, projectResample, "precision"),
                function () {
                    return project = projectAt.apply(this, arguments),
                        projection.invert = project.invert && invert,
                        reset()
                }
        }

        function d3_geo_projectionRadiansRotate(rotate, stream) {
            return {
                point: function (x, y) {
                    y = rotate(x * d3_radians, y * d3_radians),
                        x = y[0],
                        stream.point(x > π ? x - 2 * π : -π > x ? x + 2 * π : x, y[1])
                },
                sphere: function () {
                    stream.sphere()
                },
                lineStart: function () {
                    stream.lineStart()
                },
                lineEnd: function () {
                    stream.lineEnd()
                },
                polygonStart: function () {
                    stream.polygonStart()
                },
                polygonEnd: function () {
                    stream.polygonEnd()
                }
            }
        }

        function d3_geo_equirectangular(λ, φ) {
            return [λ, φ]
        }

        function d3_geo_rotation(δλ, δφ, δγ) {
            returnδλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_equirectangular
        }

        function d3_geo_forwardRotationλ(δλ) {
            return function (λ, φ) {
                returnλ += δλ, [λ > π ? λ - 2 * π : -π > λ ? λ + 2 * π : λ, φ]
            }
        }

        function d3_geo_rotationλ(δλ) {
            var rotation = d3_geo_forwardRotationλ(δλ);
            return rotation.invert = d3_geo_forwardRotationλ(-δλ),
                rotation
        }

        function d3_geo_rotationφγ(δφ, δγ) {
            function rotation(λ, φ) {
                var cosφ = Math.cos(φ),
                    x = Math.cos(λ) * cosφ,
                    y = Math.sin(λ) * cosφ,
                    z = Math.sin(φ),
                    k = z * cosδφ + x * sinδφ;
                return [Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ)]
            }
            var cosδφ = Math.cos(δφ),
                sinδφ = Math.sin(δφ),
                cosδγ = Math.cos(δγ),
                sinδγ = Math.sin(δγ);
            return rotation.invert = function (λ, φ) {
                    var cosφ = Math.cos(φ),
                        x = Math.cos(λ) * cosφ,
                        y = Math.sin(λ) * cosφ,
                        z = Math.sin(φ),
                        k = z * cosδγ - y * sinδγ;
                    return [Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ)]
                },
                rotation
        }

        function d3_geo_circleInterpolate(radius, precision) {
            var cr = Math.cos(radius),
                sr = Math.sin(radius);
            return function (from, to, direction, listener) {
                null != from ? (from = d3_geo_circleAngle(cr, from), to = d3_geo_circleAngle(cr, to), (direction > 0 ? to > from : from > to) && (from += 2 * direction * π)) : (from = radius + 2 * direction * π, to = radius);
                for (var point, step = direction * precision,
                        t = from; direction > 0 ? t > to : to > t; t -= step) listener.point((point = d3_geo_spherical([cr, -sr * Math.cos(t), -sr * Math.sin(t)]))[0], point[1])
            }
        }

        function d3_geo_circleAngle(cr, point) {
            var a = d3_geo_cartesian(point);
            a[0] -= cr,
                d3_geo_cartesianNormalize(a);
            var angle = d3_acos(-a[1]);
            return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI)
        }

        function d3_geo_graticuleX(y0, y1, dy) {
            var y = d3.range(y0, y1 - ε, dy).concat(y1);
            return function (x) {
                return y.map(function (y) {
                    return [x, y]
                })
            }
        }

        function d3_geo_graticuleY(x0, x1, dx) {
            var x = d3.range(x0, x1 - ε, dx).concat(x1);
            return function (y) {
                return x.map(function (x) {
                    return [x, y]
                })
            }
        }

        function d3_source(d) {
            return d.source
        }

        function d3_target(d) {
            return d.target
        }

        function d3_geo_interpolate(x0, y0, x1, y1) {
            var cy0 = Math.cos(y0),
                sy0 = Math.sin(y0),
                cy1 = Math.cos(y1),
                sy1 = Math.sin(y1),
                kx0 = cy0 * Math.cos(x0),
                ky0 = cy0 * Math.sin(x0),
                kx1 = cy1 * Math.cos(x1),
                ky1 = cy1 * Math.sin(x1),
                d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))),
                k = 1 / Math.sin(d),
                interpolate = d ?
                function (t) {
                    var B = Math.sin(t *= d) * k,
                        A = Math.sin(d - t) * k,
                        x = A * kx0 + B * kx1,
                        y = A * ky0 + B * ky1,
                        z = A * sy0 + B * sy1;
                    return [Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees]
                } : function () {
                    return [x0 * d3_degrees, y0 * d3_degrees]
                };
            return interpolate.distance = d,
                interpolate
        }

        function d3_geo_lengthLineStart() {
            function nextPoint(λ, φ) {
                var sinφ = Math.sin(φ *= d3_radians),
                    cosφ = Math.cos(φ),
                    t = Math.abs((λ *= d3_radians) - λ0),
                    cosΔλ = Math.cos(t);
                d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ),
                    λ0 = λ,
                    sinφ0 = sinφ,
                    cosφ0 = cosφ
            }
            varλ0, sinφ0, cosφ0;
            d3_geo_length.point = function (λ, φ) {
                    λ0 = λ * d3_radians,
                        sinφ0 = Math.sin(φ *= d3_radians),
                        cosφ0 = Math.cos(φ),
                        d3_geo_length.point = nextPoint
                },
                d3_geo_length.lineEnd = function () {
                    d3_geo_length.point = d3_geo_length.lineEnd = d3_noop
                }
        }

        function d3_geo_azimuthal(scale, angle) {
            function azimuthal(λ, φ) {
                var cosλ = Math.cos(λ),
                    cosφ = Math.cos(φ),
                    k = scale(cosλ * cosφ);
                return [k * cosφ * Math.sin(λ), k * Math.sin(φ)]
            }
            return azimuthal.invert = function (x, y) {
                    varρ = Math.sqrt(x * x + y * y),
                        c = angle(ρ),
                        sinc = Math.sin(c),
                        cosc = Math.cos(c);
                    return [Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ)]
                },
                azimuthal
        }

        function d3_geo_conicConformal(φ0, φ1) {
            function forward(λ, φ) {
                varρ = Math.abs(Math.abs(φ) - π / 2) < ε ? 0 : F / Math.pow(t(φ), n);
                return [ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ)]
            }
            var cosφ0 = Math.cos(φ0),
                t = function (φ) {
                    return Math.tan(π / 4 + φ / 2)
                },
                n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)),
                F = cosφ0 * Math.pow(t(φ0), n) / n;
            return n ? (forward.invert = function (x, y) {
                    varρ0_y = F - y,
                        ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
                    return [Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - π / 2]
                },
                forward) : d3_geo_mercator
        }

        function d3_geo_conicEquidistant(φ0, φ1) {
            function forward(λ, φ) {
                varρ = G - φ;
                return [ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ)]
            }
            var cosφ0 = Math.cos(φ0),
                n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0),
                G = cosφ0 / n + φ0;
            return Math.abs(n) < ε ? d3_geo_equirectangular : (forward.invert = function (x, y) {
                    varρ0_y = G - y;
                    return [Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y)]
                },
                forward)
        }

        function d3_geo_mercator(λ, φ) {
            return [λ, Math.log(Math.tan(π / 4 + φ / 2))]
        }

        function d3_geo_mercatorProjection(project) {
            var clipAuto, m = d3_geo_projection(project),
                scale = m.scale,
                translate = m.translate,
                clipExtent = m.clipExtent;
            return m.scale = function () {
                    var v = scale.apply(m, arguments);
                    return v === m ? clipAuto ? m.clipExtent(null) : m : v
                },
                m.translate = function () {
                    var v = translate.apply(m, arguments);
                    return v === m ? clipAuto ? m.clipExtent(null) : m : v
                },
                m.clipExtent = function (_) {
                    var v = clipExtent.apply(m, arguments);
                    if (v === m) {
                        if (clipAuto = null == _) {
                            var k = π * scale(),
                                t = translate();
                            clipExtent([
                                [t[0] - k, t[1] - k],
                                [t[0] + k, t[1] + k]
                            ])
                        }
                    } else clipAuto && (v = null);
                    return v
                },
                m.clipExtent(null)
        }

        function d3_geo_transverseMercator(λ, φ) {
            var B = Math.cos(φ) * Math.sin(λ);
            return [Math.log((1 + B) / (1 - B)) / 2, Math.atan2(Math.tan(φ), Math.cos(λ))]
        }

        function d3_svg_line(projection) {
            function line(data) {
                function segment() {
                    segments.push("M", interpolate(projection(points), tension))
                }
                for (var d, segments = [], points = [], i = -1, n = data.length, fx = d3_functor(x), fy = d3_functor(y); ++i < n;) defined.call(this, d = data[i], i) ? points.push([+fx.call(this, d, i), +fy.call(this, d, i)]) : points.length && (segment(), points = []);
                return points.length && segment(),
                    segments.length ? segments.join("") : null
            }
            var x = d3_svg_lineX,
                y = d3_svg_lineY,
                defined = d3_true,
                interpolate = d3_svg_lineLinear,
                interpolateKey = interpolate.key,
                tension = .7;
            return line.x = function (_) {
                    return arguments.length ? (x = _, line) : x
                },
                line.y = function (_) {
                    return arguments.length ? (y = _, line) : y
                },
                line.defined = function (_) {
                    return arguments.length ? (defined = _, line) : defined
                },
                line.interpolate = function (_) {
                    return arguments.length ? (interpolateKey = "function" == typeof _ ? interpolate = _ : (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key, line) : interpolateKey
                },
                line.tension = function (_) {
                    return arguments.length ? (tension = _, line) : tension
                },
                line
        }

        function d3_svg_lineX(d) {
            return d[0]
        }

        function d3_svg_lineY(d) {
            return d[1]
        }

        function d3_svg_lineLinear(points) {
            return points.join("L")
        }

        function d3_svg_lineLinearClosed(points) {
            return d3_svg_lineLinear(points) + "Z"
        }

        function d3_svg_lineStep(points) {
            for (var i = 0,
                    n = points.length,
                    p = points[0], path = [p[0], ",", p[1]]; ++i < n;) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
            return n > 1 && path.push("H", p[0]),
                path.join("")
        }

        function d3_svg_lineStepBefore(points) {
            for (var i = 0,
                    n = points.length,
                    p = points[0], path = [p[0], ",", p[1]]; ++i < n;) path.push("V", (p = points[i])[1], "H", p[0]);
            return path.join("")
        }

        function d3_svg_lineStepAfter(points) {
            for (var i = 0,
                    n = points.length,
                    p = points[0], path = [p[0], ",", p[1]]; ++i < n;) path.push("H", (p = points[i])[0], "V", p[1]);
            return path.join("")
        }

        function d3_svg_lineCardinalOpen(points, tension) {
            return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1), d3_svg_lineCardinalTangents(points, tension))
        }

        function d3_svg_lineCardinalClosed(points, tension) {
            return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), points), d3_svg_lineCardinalTangents([points[points.length - 2]].concat(points, [points[1]]), tension))
        }

        function d3_svg_lineCardinal(points, tension) {
            return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension))
        }

        function d3_svg_lineHermite(points, tangents) {
            if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) return d3_svg_lineLinear(points);
            var quad = points.length != tangents.length,
                path = "",
                p0 = points[0],
                p = points[1],
                t0 = tangents[0],
                t = t0,
                pi = 1;
            if (quad && (path += "Q" + (p[0] - 2 * t0[0] / 3) + "," + (p[1] - 2 * t0[1] / 3) + "," + p[0] + "," + p[1], p0 = points[1], pi = 2), tangents.length > 1) {
                t = tangents[1],
                    p = points[pi],
                    pi++,
                    path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
                for (var i = 2; i < tangents.length; i++, pi++) p = points[pi],
                    t = tangents[i],
                    path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1]
            }
            if (quad) {
                var lp = points[pi];
                path += "Q" + (p[0] + 2 * t[0] / 3) + "," + (p[1] + 2 * t[1] / 3) + "," + lp[0] + "," + lp[1]
            }
            return path
        }

        function d3_svg_lineCardinalTangents(points, tension) {
            for (var p0, tangents = [], a = (1 - tension) / 2, p1 = points[0], p2 = points[1], i = 1, n = points.length; ++i < n;) p0 = p1,
                p1 = p2,
                p2 = points[i],
                tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);
            return tangents
        }

        function d3_svg_lineBasis(points) {
            if (points.length < 3) return d3_svg_lineLinear(points);
            var i = 1,
                n = points.length,
                pi = points[0],
                x0 = pi[0],
                y0 = pi[1],
                px = [x0, x0, x0, (pi = points[1])[0]],
                py = [y0, y0, y0, pi[1]],
                path = [x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
            for (points.push(points[n - 1]); ++i <= n;) pi = points[i],
                px.shift(),
                px.push(pi[0]),
                py.shift(),
                py.push(pi[1]),
                d3_svg_lineBasisBezier(path, px, py);
            return points.pop(),
                path.push("L", pi),
                path.join("")
        }

        function d3_svg_lineBasisOpen(points) {
            if (points.length < 4) return d3_svg_lineLinear(points);
            for (var pi, path = [], i = -1, n = points.length, px = [0], py = [0]; ++i < 3;) pi = points[i],
                px.push(pi[0]),
                py.push(pi[1]);
            for (path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)), --i; ++i < n;) pi = points[i],
                px.shift(),
                px.push(pi[0]),
                py.shift(),
                py.push(pi[1]),
                d3_svg_lineBasisBezier(path, px, py);
            return path.join("")
        }

        function d3_svg_lineBasisClosed(points) {
            for (var path, pi, i = -1,
                    n = points.length,
                    m = n + 4,
                    px = [], py = []; ++i < 4;) pi = points[i % n],
                px.push(pi[0]),
                py.push(pi[1]);
            for (path = [d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)], --i; ++i < m;) pi = points[i % n],
                px.shift(),
                px.push(pi[0]),
                py.shift(),
                py.push(pi[1]),
                d3_svg_lineBasisBezier(path, px, py);
            return path.join("")
        }

        function d3_svg_lineBundle(points, tension) {
            var n = points.length - 1;
            if (n)
                for (var p, t, x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1; ++i <= n;) p = points[i],
                    t = i / n,
                    p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx),
                    p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
            return d3_svg_lineBasis(points)
        }

        function d3_svg_lineDot4(a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3]
        }

        function d3_svg_lineBasisBezier(path, x, y) {
            path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y))
        }

        function d3_svg_lineSlope(p0, p1) {
            return (p1[1] - p0[1]) / (p1[0] - p0[0])
        }

        function d3_svg_lineFiniteDifferences(points) {
            for (var i = 0,
                    j = points.length - 1,
                    m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1); ++i < j;) m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
            return m[i] = d,
                m
        }

        function d3_svg_lineMonotoneTangents(points) {
            for (var d, a, b, s, tangents = [], m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1; ++i < j;) d = d3_svg_lineSlope(points[i], points[i + 1]),
                Math.abs(d) < 1e-6 ? m[i] = m[i + 1] = 0 : (a = m[i] / d, b = m[i + 1] / d, s = a * a + b * b, s > 9 && (s = 3 * d / Math.sqrt(s), m[i] = s * a, m[i + 1] = s * b));
            for (i = -1; ++i <= j;) s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i])),
                tangents.push([s || 0, m[i] * s || 0]);
            return tangents
        }

        function d3_svg_lineMonotone(points) {
            return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points))
        }

        function d3_geom_hullCCW(i1, i2, i3, v) {
            var t, a, b, c, d, e, f;
            return t = v[i1],
                a = t[0],
                b = t[1],
                t = v[i2],
                c = t[0],
                d = t[1],
                t = v[i3],
                e = t[0],
                f = t[1],
                (f - b) * (c - a) - (d - b) * (e - a) > 0
        }

        function d3_geom_polygonInside(p, a, b) {
            return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0])
        }

        function d3_geom_polygonIntersect(c, d, a, b) {
            var x1 = c[0],
                x3 = a[0],
                x21 = d[0] - x1,
                x43 = b[0] - x3,
                y1 = c[1],
                y3 = a[1],
                y21 = d[1] - y1,
                y43 = b[1] - y3,
                ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
            return [x1 + ua * x21, y1 + ua * y21]
        }

        function d3_geom_polygonClosed(coordinates) {
            var a = coordinates[0],
                b = coordinates[coordinates.length - 1];
            return !(a[0] - b[0] || a[1] - b[1])
        }

        function d3_geom_voronoiTessellate(points, callback) {
            var Sites = {
                    list: points.map(function (v, i) {
                        return {
                            index: i,
                            x: v[0],
                            y: v[1]
                        }
                    }).sort(function (a, b) {
                        return a.y < b.y ? -1 : a.y > b.y ? 1 : a.x < b.x ? -1 : a.x > b.x ? 1 : 0
                    }),
                    bottomSite: null
                },
                EdgeList = {
                    list: [],
                    leftEnd: null,
                    rightEnd: null,
                    init: function () {
                        EdgeList.leftEnd = EdgeList.createHalfEdge(null, "l"),
                            EdgeList.rightEnd = EdgeList.createHalfEdge(null, "l"),
                            EdgeList.leftEnd.r = EdgeList.rightEnd,
                            EdgeList.rightEnd.l = EdgeList.leftEnd,
                            EdgeList.list.unshift(EdgeList.leftEnd, EdgeList.rightEnd)
                    },
                    createHalfEdge: function (edge, side) {
                        return {
                            edge: edge,
                            side: side,
                            vertex: null,
                            l: null,
                            r: null
                        }
                    },
                    insert: function (lb, he) {
                        he.l = lb,
                            he.r = lb.r,
                            lb.r.l = he,
                            lb.r = he
                    },
                    leftBound: function (p) {
                        var he = EdgeList.leftEnd;
                        do he = he.r;
                        while (he != EdgeList.rightEnd && Geom.rightOf(he, p));
                        return he = he.l
                    },
                    del: function (he) {
                        he.l.r = he.r,
                            he.r.l = he.l,
                            he.edge = null
                    },
                    right: function (he) {
                        return he.r
                    },
                    left: function (he) {
                        return he.l
                    },
                    leftRegion: function (he) {
                        return null == he.edge ? Sites.bottomSite : he.edge.region[he.side]
                    },
                    rightRegion: function (he) {
                        return null == he.edge ? Sites.bottomSite : he.edge.region[d3_geom_voronoiOpposite[he.side]]
                    }
                },
                Geom = {
                    bisect: function (s1, s2) {
                        var newEdge = {
                                region: {
                                    l: s1,
                                    r: s2
                                },
                                ep: {
                                    l: null,
                                    r: null
                                }
                            },
                            dx = s2.x - s1.x,
                            dy = s2.y - s1.y,
                            adx = dx > 0 ? dx : -dx,
                            ady = dy > 0 ? dy : -dy;
                        return newEdge.c = s1.x * dx + s1.y * dy + .5 * (dx * dx + dy * dy),
                            adx > ady ? (newEdge.a = 1, newEdge.b = dy / dx, newEdge.c /= dx) : (newEdge.b = 1, newEdge.a = dx / dy, newEdge.c /= dy),
                            newEdge
                    },
                    intersect: function (el1, el2) {
                        var e1 = el1.edge,
                            e2 = el2.edge;
                        if (!e1 || !e2 || e1.region.r == e2.region.r) return null;
                        var d = e1.a * e2.b - e1.b * e2.a;
                        if (Math.abs(d) < 1e-10) return null;
                        var el, e, xint = (e1.c * e2.b - e2.c * e1.b) / d,
                            yint = (e2.c * e1.a - e1.c * e2.a) / d,
                            e1r = e1.region.r,
                            e2r = e2.region.r;
                        e1r.y < e2r.y || e1r.y == e2r.y && e1r.x < e2r.x ? (el = el1, e = e1) : (el = el2, e = e2);
                        var rightOfSite = xint >= e.region.r.x;
                        return rightOfSite && "l" === el.side || !rightOfSite && "r" === el.side ? null : {
                            x: xint,
                            y: yint
                        }
                    },
                    rightOf: function (he, p) {
                        var e = he.edge,
                            topsite = e.region.r,
                            rightOfSite = p.x > topsite.x;
                        if (rightOfSite && "l" === he.side) return 1;
                        if (!rightOfSite && "r" === he.side) return 0;
                        if (1 === e.a) {
                            var dyp = p.y - topsite.y,
                                dxp = p.x - topsite.x,
                                fast = 0,
                                above = 0;
                            if (!rightOfSite && e.b < 0 || rightOfSite && e.b >= 0 ? above = fast = dyp >= e.b * dxp : (above = p.x + p.y * e.b > e.c, e.b < 0 && (above = !above), above || (fast = 1)), !fast) {
                                var dxs = topsite.x - e.region.l.x;
                                above = e.b * (dxp * dxp - dyp * dyp) < dxs * dyp * (1 + 2 * dxp / dxs + e.b * e.b),
                                    e.b < 0 && (above = !above)
                            }
                        } else {
                            var yl = e.c - e.a * p.x,
                                t1 = p.y - yl,
                                t2 = p.x - topsite.x,
                                t3 = yl - topsite.y;
                            above = t1 * t1 > t2 * t2 + t3 * t3
                        }
                        return "l" === he.side ? above : !above
                    },
                    endPoint: function (edge, side, site) {
                        edge.ep[side] = site,
                            edge.ep[d3_geom_voronoiOpposite[side]] && callback(edge)
                    },
                    distance: function (s, t) {
                        var dx = s.x - t.x,
                            dy = s.y - t.y;
                        return Math.sqrt(dx * dx + dy * dy)
                    }
                },
                EventQueue = {
                    list: [],
                    insert: function (he, site, offset) {
                        he.vertex = site,
                            he.ystar = site.y + offset;
                        for (var i = 0,
                                list = EventQueue.list,
                                l = list.length; l > i; i++) {
                            var next = list[i];
                            if (!(he.ystar > next.ystar || he.ystar == next.ystar && site.x > next.vertex.x)) break
                        }
                        list.splice(i, 0, he)
                    },
                    del: function (he) {
                        for (var i = 0,
                                ls = EventQueue.list,
                                l = ls.length; l > i && ls[i] != he; ++i);
                        ls.splice(i, 1)
                    },
                    empty: function () {
                        return 0 === EventQueue.list.length
                    },
                    nextEvent: function (he) {
                        for (var i = 0,
                                ls = EventQueue.list,
                                l = ls.length; l > i; ++i)
                            if (ls[i] == he) return ls[i + 1];
                        return null
                    },
                    min: function () {
                        var elem = EventQueue.list[0];
                        return {
                            x: elem.vertex.x,
                            y: elem.ystar
                        }
                    },
                    extractMin: function () {
                        return EventQueue.list.shift()
                    }
                };
            EdgeList.init(),
                Sites.bottomSite = Sites.list.shift();
            for (var newIntStar, lbnd, rbnd, llbnd, rrbnd, bisector, bot, top, temp, p, v, e, pm, newSite = Sites.list.shift();;)
                if (EventQueue.empty() || (newIntStar = EventQueue.min()), newSite && (EventQueue.empty() || newSite.y < newIntStar.y || newSite.y == newIntStar.y && newSite.x < newIntStar.x)) lbnd = EdgeList.leftBound(newSite),
                    rbnd = EdgeList.right(lbnd),
                    bot = EdgeList.rightRegion(lbnd),
                    e = Geom.bisect(bot, newSite),
                    bisector = EdgeList.createHalfEdge(e, "l"),
                    EdgeList.insert(lbnd, bisector),
                    p = Geom.intersect(lbnd, bisector),
                    p && (EventQueue.del(lbnd), EventQueue.insert(lbnd, p, Geom.distance(p, newSite))),
                    lbnd = bisector,
                    bisector = EdgeList.createHalfEdge(e, "r"),
                    EdgeList.insert(lbnd, bisector),
                    p = Geom.intersect(bisector, rbnd),
                    p && EventQueue.insert(bisector, p, Geom.distance(p, newSite)),
                    newSite = Sites.list.shift();
                else {
                    if (EventQueue.empty()) break;
                    lbnd = EventQueue.extractMin(),
                        llbnd = EdgeList.left(lbnd),
                        rbnd = EdgeList.right(lbnd),
                        rrbnd = EdgeList.right(rbnd),
                        bot = EdgeList.leftRegion(lbnd),
                        top = EdgeList.rightRegion(rbnd),
                        v = lbnd.vertex,
                        Geom.endPoint(lbnd.edge, lbnd.side, v),
                        Geom.endPoint(rbnd.edge, rbnd.side, v),
                        EdgeList.del(lbnd),
                        EventQueue.del(rbnd),
                        EdgeList.del(rbnd),
                        pm = "l",
                        bot.y > top.y && (temp = bot, bot = top, top = temp, pm = "r"),
                        e = Geom.bisect(bot, top),
                        bisector = EdgeList.createHalfEdge(e, pm),
                        EdgeList.insert(llbnd, bisector),
                        Geom.endPoint(e, d3_geom_voronoiOpposite[pm], v),
                        p = Geom.intersect(llbnd, bisector),
                        p && (EventQueue.del(llbnd), EventQueue.insert(llbnd, p, Geom.distance(p, bot))),
                        p = Geom.intersect(bisector, rrbnd),
                        p && EventQueue.insert(bisector, p, Geom.distance(p, bot))
                }
            for (lbnd = EdgeList.right(EdgeList.leftEnd); lbnd != EdgeList.rightEnd; lbnd = EdgeList.right(lbnd)) callback(lbnd.edge)
        }

        function d3_geom_quadtreeCompatX(d) {
            return d.x
        }

        function d3_geom_quadtreeCompatY(d) {
            return d.y
        }

        function d3_geom_quadtreeNode() {
            return {
                leaf: !0,
                nodes: [],
                point: null,
                x: null,
                y: null
            }
        }

        function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
            if (!f(node, x1, y1, x2, y2)) {
                var sx = .5 * (x1 + x2),
                    sy = .5 * (y1 + y2),
                    children = node.nodes;
                children[0] && d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy),
                    children[1] && d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy),
                    children[2] && d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2),
                    children[3] && d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2)
            }
        }

        function d3_interpolateRgb(a, b) {
            a = d3.rgb(a),
                b = d3.rgb(b);
            var ar = a.r,
                ag = a.g,
                ab = a.b,
                br = b.r - ar,
                bg = b.g - ag,
                bb = b.b - ab;
            return function (t) {
                return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t))
            }
        }

        function d3_interpolateObject(a, b) {
            var k, i = {},
                c = {};
            for (k in a) k in b ? i[k] = d3_interpolate(a[k], b[k]) : c[k] = a[k];
            for (k in b) k in a || (c[k] = b[k]);
            return function (t) {
                for (k in i) c[k] = i[k](t);
                return c
            }
        }

        function d3_interpolateNumber(a, b) {
            return b -= a = +a,
                function (t) {
                    return a + b * t
                }
        }

        function d3_interpolateString(a, b) {
            var m, i, j, n, o, s0 = 0,
                s1 = 0,
                s = [],
                q = [];
            for (a += "", b += "", d3_interpolate_number.lastIndex = 0, i = 0; m = d3_interpolate_number.exec(b); ++i) m.index && s.push(b.substring(s0, s1 = m.index)),
                q.push({
                    i: s.length,
                    x: m[0]
                }),
                s.push(null),
                s0 = d3_interpolate_number.lastIndex;
            for (s0 < b.length && s.push(b.substring(s0)), i = 0, n = q.length;
                (m = d3_interpolate_number.exec(a)) && n > i; ++i)
                if (o = q[i], o.x == m[0]) {
                    if (o.i)
                        if (null == s[o.i + 1])
                            for (s[o.i - 1] += o.x, s.splice(o.i, 1), j = i + 1; n > j; ++j) q[j].i--;
                        else
                            for (s[o.i - 1] += o.x + s[o.i + 1], s.splice(o.i, 2), j = i + 1; n > j; ++j) q[j].i -= 2;
                    else if (null == s[o.i + 1]) s[o.i] = o.x;
                    else
                        for (s[o.i] = o.x + s[o.i + 1], s.splice(o.i + 1, 1), j = i + 1; n > j; ++j) q[j].i--;
                    q.splice(i, 1),
                        n--,
                        i--
                } else o.x = d3_interpolateNumber(parseFloat(m[0]), parseFloat(o.x));
            for (; n > i;) o = q.pop(),
                null == s[o.i + 1] ? s[o.i] = o.x : (s[o.i] = o.x + s[o.i + 1], s.splice(o.i + 1, 1)),
                n--;
            return 1 === s.length ? null == s[0] ? (o = q[0].x,
                function (t) {
                    return o(t) + ""
                }) : function () {
                return b
            } : function (t) {
                for (i = 0; n > i; ++i) s[(o = q[i]).i] = o.x(t);
                return s.join("")
            }
        }

        function d3_interpolate(a, b) {
            for (var f, i = d3.interpolators.length; --i >= 0 && !(f = d3.interpolators[i](a, b)););
            return f
        }

        function d3_interpolateArray(a, b) {
            var i, x = [],
                c = [],
                na = a.length,
                nb = b.length,
                n0 = Math.min(a.length, b.length);
            for (i = 0; n0 > i; ++i) x.push(d3_interpolate(a[i], b[i]));
            for (; na > i; ++i) c[i] = a[i];
            for (; nb > i; ++i) c[i] = b[i];
            return function (t) {
                for (i = 0; n0 > i; ++i) c[i] = x[i](t);
                return c
            }
        }

        function d3_ease_clamp(f) {
            return function (t) {
                return 0 >= t ? 0 : t >= 1 ? 1 : f(t)
            }
        }

        function d3_ease_reverse(f) {
            return function (t) {
                return 1 - f(1 - t)
            }
        }

        function d3_ease_reflect(f) {
            return function (t) {
                return .5 * (.5 > t ? f(2 * t) : 2 - f(2 - 2 * t))
            }
        }

        function d3_ease_quad(t) {
            return t * t
        }

        function d3_ease_cubic(t) {
            return t * t * t
        }

        function d3_ease_cubicInOut(t) {
            if (0 >= t) return 0;
            if (t >= 1) return 1;
            var t2 = t * t,
                t3 = t2 * t;
            return 4 * (.5 > t ? t3 : 3 * (t - t2) + t3 - .75)
        }

        function d3_ease_poly(e) {
            return function (t) {
                return Math.pow(t, e)
            }
        }

        function d3_ease_sin(t) {
            return 1 - Math.cos(t * π / 2)
        }

        function d3_ease_exp(t) {
            return Math.pow(2, 10 * (t - 1))
        }

        function d3_ease_circle(t) {
            return 1 - Math.sqrt(1 - t * t)
        }

        function d3_ease_elastic(a, p) {
            var s;
            return arguments.length < 2 && (p = .45),
                arguments.length ? s = p / (2 * π) * Math.asin(1 / a) : (a = 1, s = p / 4),
                function (t) {
                    return 1 + a * Math.pow(2, 10 * -t) * Math.sin(2 * (t - s) * π / p)
                }
        }

        function d3_ease_back(s) {
            return s || (s = 1.70158),
                function (t) {
                    return t * t * ((s + 1) * t - s)
                }
        }

        function d3_ease_bounce(t) {
            return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
        }

        function d3_interpolateHcl(a, b) {
            a = d3.hcl(a),
                b = d3.hcl(b);
            var ah = a.h,
                ac = a.c,
                al = a.l,
                bh = b.h - ah,
                bc = b.c - ac,
                bl = b.l - al;
            return isNaN(bc) && (bc = 0, ac = isNaN(ac) ? b.c : ac),
                isNaN(bh) ? (bh = 0, ah = isNaN(ah) ? b.h : ah) : bh > 180 ? bh -= 360 : -180 > bh && (bh += 360),
                function (t) {
                    return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + ""
                }
        }

        function d3_interpolateHsl(a, b) {
            a = d3.hsl(a),
                b = d3.hsl(b);
            var ah = a.h,
                as = a.s,
                al = a.l,
                bh = b.h - ah,
                bs = b.s - as,
                bl = b.l - al;
            return isNaN(bs) && (bs = 0, as = isNaN(as) ? b.s : as),
                isNaN(bh) ? (bh = 0, ah = isNaN(ah) ? b.h : ah) : bh > 180 ? bh -= 360 : -180 > bh && (bh += 360),
                function (t) {
                    return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + ""
                }
        }

        function d3_interpolateLab(a, b) {
            a = d3.lab(a),
                b = d3.lab(b);
            var al = a.l,
                aa = a.a,
                ab = a.b,
                bl = b.l - al,
                ba = b.a - aa,
                bb = b.b - ab;
            return function (t) {
                return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + ""
            }
        }

        function d3_interpolateRound(a, b) {
            return b -= a,
                function (t) {
                    return Math.round(a + b * t)
                }
        }

        function d3_transform(m) {
            var r0 = [m.a, m.b],
                r1 = [m.c, m.d],
                kx = d3_transformNormalize(r0),
                kz = d3_transformDot(r0, r1),
                ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
            r0[0] * r1[1] < r1[0] * r0[1] && (r0[0] *= -1, r0[1] *= -1, kx *= -1, kz *= -1),
                this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees,
                this.translate = [m.e, m.f],
                this.scale = [kx, ky],
                this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0
        }

        function d3_transformDot(a, b) {
            return a[0] * b[0] + a[1] * b[1]
        }

        function d3_transformNormalize(a) {
            var k = Math.sqrt(d3_transformDot(a, a));
            return k && (a[0] /= k, a[1] /= k),
                k
        }

        function d3_transformCombine(a, b, k) {
            return a[0] += k * b[0],
                a[1] += k * b[1],
                a
        }

        function d3_interpolateTransform(a, b) {
            var n, s = [],
                q = [],
                A = d3.transform(a),
                B = d3.transform(b),
                ta = A.translate,
                tb = B.translate,
                ra = A.rotate,
                rb = B.rotate,
                wa = A.skew,
                wb = B.skew,
                ka = A.scale,
                kb = B.scale;
            return ta[0] != tb[0] || ta[1] != tb[1] ? (s.push("translate(", null, ",", null, ")"), q.push({
                    i: 1,
                    x: d3_interpolateNumber(ta[0], tb[0])
                }, {
                    i: 3,
                    x: d3_interpolateNumber(ta[1], tb[1])
                })) : s.push(tb[0] || tb[1] ? "translate(" + tb + ")" : ""),
                ra != rb ? (ra - rb > 180 ? rb += 360 : rb - ra > 180 && (ra += 360), q.push({
                    i: s.push(s.pop() + "rotate(", null, ")") - 2,
                    x: d3_interpolateNumber(ra, rb)
                })) : rb && s.push(s.pop() + "rotate(" + rb + ")"),
                wa != wb ? q.push({
                    i: s.push(s.pop() + "skewX(", null, ")") - 2,
                    x: d3_interpolateNumber(wa, wb)
                }) : wb && s.push(s.pop() + "skewX(" + wb + ")"),
                ka[0] != kb[0] || ka[1] != kb[1] ? (n = s.push(s.pop() + "scale(", null, ",", null, ")"), q.push({
                    i: n - 4,
                    x: d3_interpolateNumber(ka[0], kb[0])
                }, {
                    i: n - 2,
                    x: d3_interpolateNumber(ka[1], kb[1])
                })) : (1 != kb[0] || 1 != kb[1]) && s.push(s.pop() + "scale(" + kb + ")"),
                n = q.length,
                function (t) {
                    for (var o, i = -1; ++i < n;) s[(o = q[i]).i] = o.x(t);
                    return s.join("")
                }
        }

        function d3_uninterpolateNumber(a, b) {
            return b = b - (a = +a) ? 1 / (b - a) : 0,
                function (x) {
                    return (x - a) * b
                }
        }

        function d3_uninterpolateClamp(a, b) {
            return b = b - (a = +a) ? 1 / (b - a) : 0,
                function (x) {
                    return Math.max(0, Math.min(1, (x - a) * b))
                }
        }

        function d3_layout_bundlePath(link) {
            for (var start = link.source,
                    end = link.target,
                    lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [start]; start !== lca;) start = start.parent,
                points.push(start);
            for (var k = points.length; end !== lca;) points.splice(k, 0, end),
                end = end.parent;
            return points
        }

        function d3_layout_bundleAncestors(node) {
            for (var ancestors = [], parent = node.parent; null != parent;) ancestors.push(node),
                node = parent,
                parent = parent.parent;
            return ancestors.push(node),
                ancestors
        }

        function d3_layout_bundleLeastCommonAncestor(a, b) {
            if (a === b) return a;
            for (var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null; aNode === bNode;) sharedNode = aNode,
                aNode = aNodes.pop(),
                bNode = bNodes.pop();
            return sharedNode
        }

        function d3_layout_forceDragstart(d) {
            d.fixed |= 2
        }

        function d3_layout_forceDragend(d) {
            d.fixed &= -7
        }

        function d3_layout_forceMouseover(d) {
            d.fixed |= 4,
                d.px = d.x,
                d.py = d.y
        }

        function d3_layout_forceMouseout(d) {
            d.fixed &= -5
        }

        function d3_layout_forceAccumulate(quad, alpha, charges) {
            var cx = 0,
                cy = 0;
            if (quad.charge = 0, !quad.leaf)
                for (var c, nodes = quad.nodes,
                        n = nodes.length,
                        i = -1; ++i < n;) c = nodes[i],
                    null != c && (d3_layout_forceAccumulate(c, alpha, charges), quad.charge += c.charge, cx += c.charge * c.cx, cy += c.charge * c.cy);
            if (quad.point) {
                quad.leaf || (quad.point.x += Math.random() - .5, quad.point.y += Math.random() - .5);
                var k = alpha * charges[quad.point.index];
                quad.charge += quad.pointCharge = k,
                    cx += k * quad.point.x,
                    cy += k * quad.point.y
            }
            quad.cx = cx / quad.charge,
                quad.cy = cy / quad.charge
        }

        function d3_layout_hierarchyRebind(object, hierarchy) {
            return d3.rebind(object, hierarchy, "sort", "children", "value"),
                object.nodes = object,
                object.links = d3_layout_hierarchyLinks,
                object
        }

        function d3_layout_hierarchyChildren(d) {
            return d.children
        }

        function d3_layout_hierarchyValue(d) {
            return d.value
        }

        function d3_layout_hierarchySort(a, b) {
            return b.value - a.value
        }

        function d3_layout_hierarchyLinks(nodes) {
            return d3.merge(nodes.map(function (parent) {
                return (parent.children || []).map(function (child) {
                    return {
                        source: parent,
                        target: child
                    }
                })
            }))
        }

        function d3_layout_stackX(d) {
            return d.x
        }

        function d3_layout_stackY(d) {
            return d.y
        }

        function d3_layout_stackOut(d, y0, y) {
            d.y0 = y0,
                d.y = y
        }

        function d3_layout_stackOrderDefault(data) {
            return d3.range(data.length)
        }

        function d3_layout_stackOffsetZero(data) {
            for (var j = -1,
                    m = data[0].length, y0 = []; ++j < m;) y0[j] = 0;
            return y0
        }

        function d3_layout_stackMaxIndex(array) {
            for (var k, i = 1,
                    j = 0,
                    v = array[0][1], n = array.length; n > i; ++i)(k = array[i][1]) > v && (j = i, v = k);
            return j
        }

        function d3_layout_stackReduceSum(d) {
            return d.reduce(d3_layout_stackSum, 0)
        }

        function d3_layout_stackSum(p, d) {
            return p + d[1]
        }

        function d3_layout_histogramBinSturges(range, values) {
            return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1))
        }

        function d3_layout_histogramBinFixed(range, n) {
            for (var x = -1,
                    b = +range[0], m = (range[1] - b) / n, f = []; ++x <= n;) f[x] = m * x + b;
            return f
        }

        function d3_layout_histogramRange(values) {
            return [d3.min(values), d3.max(values)]
        }

        function d3_layout_treeSeparation(a, b) {
            return a.parent == b.parent ? 1 : 2
        }

        function d3_layout_treeLeft(node) {
            var children = node.children;
            return children && children.length ? children[0] : node._tree.thread
        }

        function d3_layout_treeRight(node) {
            var n, children = node.children;
            return children && (n = children.length) ? children[n - 1] : node._tree.thread
        }

        function d3_layout_treeSearch(node, compare) {
            var children = node.children;
            if (children && (n = children.length))
                for (var child, n, i = -1; ++i < n;) compare(child = d3_layout_treeSearch(children[i], compare), node) > 0 && (node = child);
            return node
        }

        function d3_layout_treeRightmost(a, b) {
            return a.x - b.x
        }

        function d3_layout_treeLeftmost(a, b) {
            return b.x - a.x
        }

        function d3_layout_treeDeepest(a, b) {
            return a.depth - b.depth
        }

        function d3_layout_treeVisitAfter(node, callback) {
            function visit(node, previousSibling) {
                var children = node.children;
                if (children && (n = children.length))
                    for (var child, n, previousChild = null,
                            i = -1; ++i < n;) child = children[i],
                        visit(child, previousChild),
                        previousChild = child;
                callback(node, previousSibling)
            }
            visit(node, null)
        }

        function d3_layout_treeShift(node) {
            for (var child, shift = 0,
                    change = 0,
                    children = node.children,
                    i = children.length; --i >= 0;) child = children[i]._tree,
                child.prelim += shift,
                child.mod += shift,
                shift += child.shift + (change += child.change)
        }

        function d3_layout_treeMove(ancestor, node, shift) {
            ancestor = ancestor._tree,
                node = node._tree;
            var change = shift / (node.number - ancestor.number);
            ancestor.change += change,
                node.change -= change,
                node.shift += shift,
                node.prelim += shift,
                node.mod += shift
        }

        function d3_layout_treeAncestor(vim, node, ancestor) {
            return vim._tree.ancestor.parent == node.parent ? vim._tree.ancestor : ancestor
        }

        function d3_layout_packSort(a, b) {
            return a.value - b.value
        }

        function d3_layout_packInsert(a, b) {
            var c = a._pack_next;
            a._pack_next = b,
                b._pack_prev = a,
                b._pack_next = c,
                c._pack_prev = b
        }

        function d3_layout_packSplice(a, b) {
            a._pack_next = b,
                b._pack_prev = a
        }

        function d3_layout_packIntersects(a, b) {
            var dx = b.x - a.x,
                dy = b.y - a.y,
                dr = a.r + b.r;
            return .999 * dr * dr > dx * dx + dy * dy
        }

        function d3_layout_packSiblings(node) {
            function bound(node) {
                xMin = Math.min(node.x - node.r, xMin),
                    xMax = Math.max(node.x + node.r, xMax),
                    yMin = Math.min(node.y - node.r, yMin),
                    yMax = Math.max(node.y + node.r, yMax)
            }
            if ((nodes = node.children) && (n = nodes.length)) {
                var nodes, a, b, c, i, j, k, n, xMin = 1 / 0,
                    xMax = -1 / 0,
                    yMin = 1 / 0,
                    yMax = -1 / 0;
                if (nodes.forEach(d3_layout_packLink), a = nodes[0], a.x = -a.r, a.y = 0, bound(a), n > 1 && (b = nodes[1], b.x = b.r, b.y = 0, bound(b), n > 2))
                    for (c = nodes[2], d3_layout_packPlace(a, b, c), bound(c), d3_layout_packInsert(a, c), a._pack_prev = c, d3_layout_packInsert(c, b), b = a._pack_next, i = 3; n > i; i++) {
                        d3_layout_packPlace(a, b, c = nodes[i]);
                        var isect = 0,
                            s1 = 1,
                            s2 = 1;
                        for (j = b._pack_next; j !== b; j = j._pack_next, s1++)
                            if (d3_layout_packIntersects(j, c)) {
                                isect = 1;
                                break
                            }
                        if (1 == isect)
                            for (k = a._pack_prev; k !== j._pack_prev && !d3_layout_packIntersects(k, c); k = k._pack_prev, s2++);
                        isect ? (s2 > s1 || s1 == s2 && b.r < a.r ? d3_layout_packSplice(a, b = j) : d3_layout_packSplice(a = k, b), i--) : (d3_layout_packInsert(a, c), b = c, bound(c))
                    }
                var cx = (xMin + xMax) / 2,
                    cy = (yMin + yMax) / 2,
                    cr = 0;
                for (i = 0; n > i; i++) c = nodes[i],
                    c.x -= cx,
                    c.y -= cy,
                    cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
                node.r = cr,
                    nodes.forEach(d3_layout_packUnlink)
            }
        }

        function d3_layout_packLink(node) {
            node._pack_next = node._pack_prev = node
        }

        function d3_layout_packUnlink(node) {
            delete node._pack_next,
                delete node._pack_prev
        }

        function d3_layout_packTransform(node, x, y, k) {
            var children = node.children;
            if (node.x = x += k * node.x, node.y = y += k * node.y, node.r *= k, children)
                for (var i = -1,
                        n = children.length; ++i < n;) d3_layout_packTransform(children[i], x, y, k)
        }

        function d3_layout_packPlace(a, b, c) {
            var db = a.r + c.r,
                dx = b.x - a.x,
                dy = b.y - a.y;
            if (db && (dx || dy)) {
                var da = b.r + c.r,
                    dc = dx * dx + dy * dy;
                da *= da,
                    db *= db;
                var x = .5 + (db - da) / (2 * dc),
                    y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
                c.x = a.x + x * dx + y * dy,
                    c.y = a.y + x * dy - y * dx
            } else c.x = a.x + db,
                c.y = a.y
        }

        function d3_layout_clusterY(children) {
            return 1 + d3.max(children,
                function (child) {
                    return child.y
                })
        }

        function d3_layout_clusterX(children) {
            return children.reduce(function (x, child) {
                    return x + child.x
                },
                0) / children.length
        }

        function d3_layout_clusterLeft(node) {
            var children = node.children;
            return children && children.length ? d3_layout_clusterLeft(children[0]) : node
        }

        function d3_layout_clusterRight(node) {
            var n, children = node.children;
            return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node
        }

        function d3_layout_treemapPadNull(node) {
            return {
                x: node.x,
                y: node.y,
                dx: node.dx,
                dy: node.dy
            }
        }

        function d3_layout_treemapPad(node, padding) {
            var x = node.x + padding[3],
                y = node.y + padding[0],
                dx = node.dx - padding[1] - padding[3],
                dy = node.dy - padding[0] - padding[2];
            return 0 > dx && (x += dx / 2, dx = 0),
                0 > dy && (y += dy / 2, dy = 0), {
                    x: x,
                    y: y,
                    dx: dx,
                    dy: dy
                }
        }

        function d3_scaleExtent(domain) {
            var start = domain[0],
                stop = domain[domain.length - 1];
            return stop > start ? [start, stop] : [stop, start]
        }

        function d3_scaleRange(scale) {
            return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range())
        }

        function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
            var u = uninterpolate(domain[0], domain[1]),
                i = interpolate(range[0], range[1]);
            return function (x) {
                return i(u(x))
            }
        }

        function d3_scale_nice(domain, nice) {
            var dx, i0 = 0,
                i1 = domain.length - 1,
                x0 = domain[i0],
                x1 = domain[i1];
            return x0 > x1 && (dx = i0, i0 = i1, i1 = dx, dx = x0, x0 = x1, x1 = dx),
                domain[i0] = nice.floor(x0),
                domain[i1] = nice.ceil(x1),
                domain
        }

        function d3_scale_niceStep(step) {
            return step ? {
                floor: function (x) {
                    return Math.floor(x / step) * step
                },
                ceil: function (x) {
                    return Math.ceil(x / step) * step
                }
            } : d3_scale_niceIdentity
        }

        function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
            var u = [],
                i = [],
                j = 0,
                k = Math.min(domain.length, range.length) - 1;
            for (domain[k] < domain[0] && (domain = domain.slice().reverse(), range = range.slice().reverse()); ++j <= k;) u.push(uninterpolate(domain[j - 1], domain[j])),
                i.push(interpolate(range[j - 1], range[j]));
            return function (x) {
                var j = d3.bisect(domain, x, 1, k) - 1;
                return i[j](u[j](x))
            }
        }

        function d3_scale_linear(domain, range, interpolate, clamp) {
            function rescale() {
                var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear,
                    uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
                return output = linear(domain, range, uninterpolate, interpolate),
                    input = linear(range, domain, uninterpolate, d3_interpolate),
                    scale
            }

            function scale(x) {
                return output(x)
            }
            var output, input;
            return scale.invert = function (y) {
                    return input(y)
                },
                scale.domain = function (x) {
                    return arguments.length ? (domain = x.map(Number), rescale()) : domain
                },
                scale.range = function (x) {
                    return arguments.length ? (range = x, rescale()) : range
                },
                scale.rangeRound = function (x) {
                    return scale.range(x).interpolate(d3_interpolateRound)
                },
                scale.clamp = function (x) {
                    return arguments.length ? (clamp = x, rescale()) : clamp
                },
                scale.interpolate = function (x) {
                    return arguments.length ? (interpolate = x, rescale()) : interpolate
                },
                scale.ticks = function (m) {
                    return d3_scale_linearTicks(domain, m)
                },
                scale.tickFormat = function (m, format) {
                    return d3_scale_linearTickFormat(domain, m, format)
                },
                scale.nice = function (m) {
                    return d3_scale_linearNice(domain, m),
                        rescale()
                },
                scale.copy = function () {
                    return d3_scale_linear(domain, range, interpolate, clamp)
                },
                rescale()
        }

        function d3_scale_linearRebind(scale, linear) {
            return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp")
        }

        function d3_scale_linearNice(domain, m) {
            return d3_scale_nice(domain, d3_scale_niceStep(m ? d3_scale_linearTickRange(domain, m)[2] : d3_scale_linearNiceStep(domain)))
        }

        function d3_scale_linearNiceStep(domain) {
            var extent = d3_scaleExtent(domain),
                span = extent[1] - extent[0];
            return Math.pow(10, Math.round(Math.log(span) / Math.LN10) - 1)
        }

        function d3_scale_linearTickRange(domain, m) {
            var extent = d3_scaleExtent(domain),
                span = extent[1] - extent[0],
                step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)),
                err = m / span * step;
            return .15 >= err ? step *= 10 : .35 >= err ? step *= 5 : .75 >= err && (step *= 2),
                extent[0] = Math.ceil(extent[0] / step) * step,
                extent[1] = Math.floor(extent[1] / step) * step + .5 * step,
                extent[2] = step,
                extent
        }

        function d3_scale_linearTicks(domain, m) {
            return d3.range.apply(d3, d3_scale_linearTickRange(domain, m))
        }

        function d3_scale_linearTickFormat(domain, m, format) {
            var precision = -Math.floor(Math.log(d3_scale_linearTickRange(domain, m)[2]) / Math.LN10 + .01);
            return d3.format(format ? format.replace(d3_format_re,
                function (a, b, c, d, e, f, g, h, i, j) {
                    return [b, c, d, e, f, g, h, i || "." + (precision - 2 * ("%" === j)), j].join("")
                }) : ",." + precision + "f")
        }

        function d3_scale_log(linear, base, positive, domain) {
            function log(x) {
                return (positive ? Math.log(0 > x ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base)
            }

            function pow(x) {
                return positive ? Math.pow(base, x) : -Math.pow(base, -x)
            }

            function scale(x) {
                return linear(log(x))
            }
            return scale.invert = function (x) {
                    return pow(linear.invert(x))
                },
                scale.domain = function (x) {
                    return arguments.length ? (positive = x[0] >= 0, linear.domain((domain = x.map(Number)).map(log)), scale) : domain
                },
                scale.base = function (_) {
                    return arguments.length ? (base = +_, linear.domain(domain.map(log)), scale) : base
                },
                scale.nice = function () {
                    var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
                    return linear.domain(niced),
                        domain = niced.map(pow),
                        scale
                },
                scale.ticks = function () {
                    var extent = d3_scaleExtent(domain),
                        ticks = [],
                        u = extent[0],
                        v = extent[1],
                        i = Math.floor(log(u)),
                        j = Math.ceil(log(v)),
                        n = base % 1 ? 2 : base;
                    if (isFinite(j - i)) {
                        if (positive) {
                            for (; j > i; i++)
                                for (var k = 1; n > k; k++) ticks.push(pow(i) * k);
                            ticks.push(pow(i))
                        } else
                            for (ticks.push(pow(i)); i++ < j;)
                                for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
                        for (i = 0; ticks[i] < u; i++);
                        for (j = ticks.length; ticks[j - 1] > v; j--);
                        ticks = ticks.slice(i, j)
                    }
                    return ticks
                },
                scale.tickFormat = function (n, format) {
                    if (!arguments.length) return d3_scale_logFormat;
                    arguments.length < 2 ? format = d3_scale_logFormat : "function" != typeof format && (format = d3.format(format));
                    var e, k = Math.max(.1, n / scale.ticks().length),
                        f = positive ? (e = 1e-12, Math.ceil) : (e = -1e-12, Math.floor);
                    return function (d) {
                        return d / pow(f(log(d) + e)) <= k ? format(d) : ""
                    }
                },
                scale.copy = function () {
                    return d3_scale_log(linear.copy(), base, positive, domain)
                },
                d3_scale_linearRebind(scale, linear)
        }

        function d3_scale_pow(linear, exponent, domain) {
            function scale(x) {
                return linear(powp(x))
            }
            var powp = d3_scale_powPow(exponent),
                powb = d3_scale_powPow(1 / exponent);
            return scale.invert = function (x) {
                    return powb(linear.invert(x))
                },
                scale.domain = function (x) {
                    return arguments.length ? (linear.domain((domain = x.map(Number)).map(powp)), scale) : domain
                },
                scale.ticks = function (m) {
                    return d3_scale_linearTicks(domain, m)
                },
                scale.tickFormat = function (m, format) {
                    return d3_scale_linearTickFormat(domain, m, format)
                },
                scale.nice = function (m) {
                    return scale.domain(d3_scale_linearNice(domain, m))
                },
                scale.exponent = function (x) {
                    return arguments.length ? (powp = d3_scale_powPow(exponent = x), powb = d3_scale_powPow(1 / exponent), linear.domain(domain.map(powp)), scale) : exponent
                },
                scale.copy = function () {
                    return d3_scale_pow(linear.copy(), exponent, domain)
                },
                d3_scale_linearRebind(scale, linear)
        }

        function d3_scale_powPow(e) {
            return function (x) {
                return 0 > x ? -Math.pow(-x, e) : Math.pow(x, e)
            }
        }

        function d3_scale_ordinal(domain, ranger) {
            function scale(x) {
                return range[((index.get(x) || index.set(x, domain.push(x))) - 1) % range.length]
            }

            function steps(start, step) {
                return d3.range(domain.length).map(function (i) {
                    return start + step * i
                })
            }
            var index, range, rangeBand;
            return scale.domain = function (x) {
                    if (!arguments.length) return domain;
                    domain = [],
                        index = new d3_Map;
                    for (var xi, i = -1,
                            n = x.length; ++i < n;) index.has(xi = x[i]) || index.set(xi, domain.push(xi));
                    return scale[ranger.t].apply(scale, ranger.a)
                },
                scale.range = function (x) {
                    return arguments.length ? (range = x, rangeBand = 0, ranger = {
                            t: "range",
                            a: arguments
                        },
                        scale) : range
                },
                scale.rangePoints = function (x, padding) {
                    arguments.length < 2 && (padding = 0);
                    var start = x[0],
                        stop = x[1],
                        step = (stop - start) / (Math.max(1, domain.length - 1) + padding);
                    return range = steps(domain.length < 2 ? (start + stop) / 2 : start + step * padding / 2, step),
                        rangeBand = 0,
                        ranger = {
                            t: "rangePoints",
                            a: arguments
                        },
                        scale
                },
                scale.rangeBands = function (x, padding, outerPadding) {
                    arguments.length < 2 && (padding = 0),
                        arguments.length < 3 && (outerPadding = padding);
                    var reverse = x[1] < x[0],
                        start = x[reverse - 0],
                        stop = x[1 - reverse],
                        step = (stop - start) / (domain.length - padding + 2 * outerPadding);
                    return range = steps(start + step * outerPadding, step),
                        reverse && range.reverse(),
                        rangeBand = step * (1 - padding),
                        ranger = {
                            t: "rangeBands",
                            a: arguments
                        },
                        scale
                },
                scale.rangeRoundBands = function (x, padding, outerPadding) {
                    arguments.length < 2 && (padding = 0),
                        arguments.length < 3 && (outerPadding = padding);
                    var reverse = x[1] < x[0],
                        start = x[reverse - 0],
                        stop = x[1 - reverse],
                        step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding)),
                        error = stop - start - (domain.length - padding) * step;
                    return range = steps(start + Math.round(error / 2), step),
                        reverse && range.reverse(),
                        rangeBand = Math.round(step * (1 - padding)),
                        ranger = {
                            t: "rangeRoundBands",
                            a: arguments
                        },
                        scale
                },
                scale.rangeBand = function () {
                    return rangeBand
                },
                scale.rangeExtent = function () {
                    return d3_scaleExtent(ranger.a[0])
                },
                scale.copy = function () {
                    return d3_scale_ordinal(domain, ranger)
                },
                scale.domain(domain)
        }

        function d3_scale_quantile(domain, range) {
            function rescale() {
                var k = 0,
                    q = range.length;
                for (thresholds = []; ++k < q;) thresholds[k - 1] = d3.quantile(domain, k / q);
                return scale
            }

            function scale(x) {
                return isNaN(x = +x) ? void 0 : range[d3.bisect(thresholds, x)]
            }
            var thresholds;
            return scale.domain = function (x) {
                    return arguments.length ? (domain = x.filter(function (d) {
                        return !isNaN(d)
                    }).sort(d3.ascending), rescale()) : domain
                },
                scale.range = function (x) {
                    return arguments.length ? (range = x, rescale()) : range
                },
                scale.quantiles = function () {
                    return thresholds
                },
                scale.invertExtent = function (y) {
                    return y = range.indexOf(y),
                        0 > y ? [0 / 0, 0 / 0] : [y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1]]
                },
                scale.copy = function () {
                    return d3_scale_quantile(domain, range)
                },
                rescale()
        }

        function d3_scale_quantize(x0, x1, range) {
            function scale(x) {
                return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))]
            }

            function rescale() {
                return kx = range.length / (x1 - x0),
                    i = range.length - 1,
                    scale
            }
            var kx, i;
            return scale.domain = function (x) {
                    return arguments.length ? (x0 = +x[0], x1 = +x[x.length - 1], rescale()) : [x0, x1]
                },
                scale.range = function (x) {
                    return arguments.length ? (range = x, rescale()) : range
                },
                scale.invertExtent = function (y) {
                    return y = range.indexOf(y),
                        y = 0 > y ? 0 / 0 : y / kx + x0, [y, y + 1 / kx]
                },
                scale.copy = function () {
                    return d3_scale_quantize(x0, x1, range)
                },
                rescale()
        }

        function d3_scale_threshold(domain, range) {
            function scale(x) {
                return x >= x ? range[d3.bisect(domain, x)] : void 0
            }
            return scale.domain = function (_) {
                    return arguments.length ? (domain = _, scale) : domain
                },
                scale.range = function (_) {
                    return arguments.length ? (range = _, scale) : range
                },
                scale.invertExtent = function (y) {
                    return y = range.indexOf(y), [domain[y - 1], domain[y]]
                },
                scale.copy = function () {
                    return d3_scale_threshold(domain, range)
                },
                scale
        }

        function d3_scale_identity(domain) {
            function identity(x) {
                return +x
            }
            return identity.invert = identity,
                identity.domain = identity.range = function (x) {
                    return arguments.length ? (domain = x.map(identity), identity) : domain
                },
                identity.ticks = function (m) {
                    return d3_scale_linearTicks(domain, m)
                },
                identity.tickFormat = function (m, format) {
                    return d3_scale_linearTickFormat(domain, m, format)
                },
                identity.copy = function () {
                    return d3_scale_identity(domain)
                },
                identity
        }

        function d3_svg_arcInnerRadius(d) {
            return d.innerRadius
        }

        function d3_svg_arcOuterRadius(d) {
            return d.outerRadius
        }

        function d3_svg_arcStartAngle(d) {
            return d.startAngle
        }

        function d3_svg_arcEndAngle(d) {
            return d.endAngle
        }

        function d3_svg_lineRadial(points) {
            for (var point, r, a, i = -1,
                    n = points.length; ++i < n;) point = points[i],
                r = point[0],
                a = point[1] + d3_svg_arcOffset,
                point[0] = r * Math.cos(a),
                point[1] = r * Math.sin(a);
            return points
        }

        function d3_svg_area(projection) {
            function area(data) {
                function segment() {
                    segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z")
                }
                for (var d, x, y, segments = [], points0 = [], points1 = [], i = -1, n = data.length, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ?
                        function () {
                            return x
                        } : d3_functor(x1), fy1 = y0 === y1 ?
                        function () {
                            return y
                        } : d3_functor(y1); ++i < n;) defined.call(this, d = data[i], i) ? (points0.push([x = +fx0.call(this, d, i), y = +fy0.call(this, d, i)]), points1.push([+fx1.call(this, d, i), +fy1.call(this, d, i)])) : points0.length && (segment(), points0 = [], points1 = []);
                return points0.length && segment(),
                    segments.length ? segments.join("") : null
            }
            var x0 = d3_svg_lineX,
                x1 = d3_svg_lineX,
                y0 = 0,
                y1 = d3_svg_lineY,
                defined = d3_true,
                interpolate = d3_svg_lineLinear,
                interpolateKey = interpolate.key,
                interpolateReverse = interpolate,
                L = "L",
                tension = .7;
            return area.x = function (_) {
                    return arguments.length ? (x0 = x1 = _, area) : x1
                },
                area.x0 = function (_) {
                    return arguments.length ? (x0 = _, area) : x0
                },
                area.x1 = function (_) {
                    return arguments.length ? (x1 = _, area) : x1
                },
                area.y = function (_) {
                    return arguments.length ? (y0 = y1 = _, area) : y1
                },
                area.y0 = function (_) {
                    return arguments.length ? (y0 = _, area) : y0
                },
                area.y1 = function (_) {
                    return arguments.length ? (y1 = _, area) : y1
                },
                area.defined = function (_) {
                    return arguments.length ? (defined = _, area) : defined
                },
                area.interpolate = function (_) {
                    return arguments.length ? (interpolateKey = "function" == typeof _ ? interpolate = _ : (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key, interpolateReverse = interpolate.reverse || interpolate, L = interpolate.closed ? "M" : "L", area) : interpolateKey
                },
                area.tension = function (_) {
                    return arguments.length ? (tension = _, area) : tension
                },
                area
        }

        function d3_svg_chordRadius(d) {
            return d.radius
        }

        function d3_svg_diagonalProjection(d) {
            return [d.x, d.y]
        }

        function d3_svg_diagonalRadialProjection(projection) {
            return function () {
                var d = projection.apply(this, arguments),
                    r = d[0],
                    a = d[1] + d3_svg_arcOffset;
                return [r * Math.cos(a), r * Math.sin(a)]
            }
        }

        function d3_svg_symbolSize() {
            return 64
        }

        function d3_svg_symbolType() {
            return "circle"
        }

        function d3_svg_symbolCircle(size) {
            var r = Math.sqrt(size / π);
            return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z"
        }

        function d3_transition(groups, id) {
            return d3_subclass(groups, d3_transitionPrototype),
                groups.id = id,
                groups
        }

        function d3_transition_tween(groups, name, value, tween) {
            var id = groups.id;
            return d3_selection_each(groups, "function" == typeof value ?
                function (node, i, j) {
                    node.__transition__[id].tween.set(name, tween(value.call(node, node.__data__, i, j)))
                } : (value = tween(value),
                    function (node) {
                        node.__transition__[id].tween.set(name, value)
                    }))
        }

        function d3_transition_text(b) {
            return null == b && (b = ""),
                function () {
                    this.textContent = b
                }
        }

        function d3_transitionNode(node, i, id, inherit) {
            var lock = node.__transition__ || (node.__transition__ = {
                    active: 0,
                    count: 0
                }),
                transition = lock[id];
            if (!transition) {
                var time = inherit.time;
                transition = lock[id] = {
                        tween: new d3_Map,
                        time: time,
                        ease: inherit.ease,
                        delay: inherit.delay,
                        duration: inherit.duration
                    },
                    ++lock.count,
                    d3.timer(function (elapsed) {
                            function start(elapsed) {
                                return lock.active > id ? stop() : (lock.active = id, transition.event && transition.event.start.call(node, d, i), transition.tween.forEach(function (key, value) {
                                    (value = value.call(node, d, i)) && tweened.push(value)
                                }), tick(elapsed) ? 1 : void d3_timer_replace(tick, 0, time))
                            }

                            function tick(elapsed) {
                                if (lock.active !== id) return stop();
                                for (var t = (elapsed - delay) / duration, e = ease(t), n = tweened.length; n > 0;) tweened[--n].call(node, e);
                                return t >= 1 ? (stop(), transition.event && transition.event.end.call(node, d, i), 1) : void 0
                            }

                            function stop() {
                                return --lock.count ? delete lock[id] : delete node.__transition__,
                                    1
                            }
                            var d = node.__data__,
                                ease = transition.ease,
                                delay = transition.delay,
                                duration = transition.duration,
                                tweened = [];
                            return elapsed >= delay ? start(elapsed) : void d3_timer_replace(start, delay, time)
                        },
                        0, time)
            }
        }

        function d3_svg_axisX(selection, x) {
            selection.attr("transform",
                function (d) {
                    return "translate(" + x(d) + ",0)"
                })
        }

        function d3_svg_axisY(selection, y) {
            selection.attr("transform",
                function (d) {
                    return "translate(0," + y(d) + ")"
                })
        }

        function d3_svg_axisSubdivide(scale, ticks, m) {
            if (subticks = [], m && ticks.length > 1) {
                for (var subticks, j, v, extent = d3_scaleExtent(scale.domain()), i = -1, n = ticks.length, d = (ticks[1] - ticks[0]) / ++m; ++i < n;)
                    for (j = m; --j > 0;)(v = +ticks[i] - j * d) >= extent[0] && subticks.push(v);
                for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) subticks.push(v)
            }
            return subticks
        }

        function d3_time_utc() {
            this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0])
        }

        function d3_time_interval(local, step, number) {
            function round(date) {
                var d0 = local(date),
                    d1 = offset(d0, 1);
                return d1 - date > date - d0 ? d0 : d1
            }

            function ceil(date) {
                return step(date = local(new d3_time(date - 1)), 1),
                    date
            }

            function offset(date, k) {
                return step(date = new d3_time(+date), k),
                    date
            }

            function range(t0, t1, dt) {
                var time = ceil(t0),
                    times = [];
                if (dt > 1)
                    for (; t1 > time;) number(time) % dt || times.push(new Date(+time)),
                        step(time, 1);
                else
                    for (; t1 > time;) times.push(new Date(+time)),
                        step(time, 1);
                return times
            }

            function range_utc(t0, t1, dt) {
                try {
                    d3_time = d3_time_utc;
                    var utc = new d3_time_utc;
                    return utc._ = t0,
                        range(utc, t1, dt)
                } finally {
                    d3_time = Date
                }
            }
            local.floor = local,
                local.round = round,
                local.ceil = ceil,
                local.offset = offset,
                local.range = range;
            var utc = local.utc = d3_time_interval_utc(local);
            return utc.floor = utc,
                utc.round = d3_time_interval_utc(round),
                utc.ceil = d3_time_interval_utc(ceil),
                utc.offset = d3_time_interval_utc(offset),
                utc.range = range_utc,
                local
        }

        function d3_time_interval_utc(method) {
            return function (date, k) {
                try {
                    d3_time = d3_time_utc;
                    var utc = new d3_time_utc;
                    return utc._ = date,
                        method(utc, k)._
                } finally {
                    d3_time = Date
                }
            }
        }

        function d3_time_parse(date, template, string, j) {
            for (var c, p, i = 0,
                    n = template.length,
                    m = string.length; n > i;) {
                if (j >= m) return -1;
                if (c = template.charCodeAt(i++), 37 === c) {
                    if (p = d3_time_parsers[template.charAt(i++)], !p || (j = p(date, string, j)) < 0) return -1
                } else if (c != string.charCodeAt(j++)) return -1
            }
            return j
        }

        function d3_time_formatRe(names) {
            return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i")
        }

        function d3_time_formatLookup(names) {
            for (var map = new d3_Map,
                    i = -1,
                    n = names.length; ++i < n;) map.set(names[i].toLowerCase(), i);
            return map
        }

        function d3_time_formatPad(value, fill, width) {
            var sign = 0 > value ? "-" : "",
                string = (sign ? -value : value) + "",
                length = string.length;
            return sign + (width > length ? new Array(width - length + 1).join(fill) + string : string)
        }

        function d3_time_parseWeekdayAbbrev(date, string, i) {
            d3_time_dayAbbrevRe.lastIndex = 0;
            var n = d3_time_dayAbbrevRe.exec(string.substring(i));
            return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1
        }

        function d3_time_parseWeekday(date, string, i) {
            d3_time_dayRe.lastIndex = 0;
            var n = d3_time_dayRe.exec(string.substring(i));
            return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1
        }

        function d3_time_parseWeekdayNumber(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.substring(i, i + 1));
            return n ? (date.w = +n[0], i + n[0].length) : -1
        }

        function d3_time_parseWeekNumberSunday(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.substring(i));
            return n ? (date.U = +n[0], i + n[0].length) : -1
        }

        function d3_time_parseWeekNumberMonday(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.substring(i));
            return n ? (date.W = +n[0], i + n[0].length) : -1
        }

        function d3_time_parseMonthAbbrev(date, string, i) {
            d3_time_monthAbbrevRe.lastIndex = 0;
            var n = d3_time_monthAbbrevRe.exec(string.substring(i));
            return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1
        }

        function d3_time_parseMonth(date, string, i) {
            d3_time_monthRe.lastIndex = 0;
            var n = d3_time_monthRe.exec(string.substring(i));
            return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1
        }

        function d3_time_parseLocaleFull(date, string, i) {
            return d3_time_parse(date, d3_time_formats.c.toString(), string, i)
        }

        function d3_time_parseLocaleDate(date, string, i) {
            return d3_time_parse(date, d3_time_formats.x.toString(), string, i)
        }

        function d3_time_parseLocaleTime(date, string, i) {
            return d3_time_parse(date, d3_time_formats.X.toString(), string, i)
        }

        function d3_time_parseFullYear(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.substring(i, i + 4));
            return n ? (date.y = +n[0], i + n[0].length) : -1
        }

        function d3_time_parseYear(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.substring(i, i + 2));
            return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1
        }

        function d3_time_expandYear(d) {
            return d + (d > 68 ? 1900 : 2e3)
        }

        function d3_time_parseMonthNumber(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.substring(i, i + 2));
            return n ? (date.m = n[0] - 1, i + n[0].length) : -1
        }

        function d3_time_parseDay(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.substring(i, i + 2));
            return n ? (date.d = +n[0], i + n[0].length) : -1
        }

        function d3_time_parseDayOfYear(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.substring(i, i + 3));
            return n ? (date.j = +n[0], i + n[0].length) : -1
        }

        function d3_time_parseHour24(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.substring(i, i + 2));
            return n ? (date.H = +n[0], i + n[0].length) : -1
        }

        function d3_time_parseMinutes(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.substring(i, i + 2));
            return n ? (date.M = +n[0], i + n[0].length) : -1
        }

        function d3_time_parseSeconds(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.substring(i, i + 2));
            return n ? (date.S = +n[0], i + n[0].length) : -1
        }

        function d3_time_parseMilliseconds(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.substring(i, i + 3));
            return n ? (date.L = +n[0], i + n[0].length) : -1
        }

        function d3_time_parseAmPm(date, string, i) {
            var n = d3_time_amPmLookup.get(string.substring(i, i += 2).toLowerCase());
            return null == n ? -1 : (date.p = n, i)
        }

        function d3_time_zone(d) {
            var z = d.getTimezoneOffset(),
                zs = z > 0 ? "-" : "+",
                zh = ~~(Math.abs(z) / 60),
                zm = Math.abs(z) % 60;
            return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2)
        }

        function d3_time_parseLiteralPercent(date, string, i) {
            d3_time_percentRe.lastIndex = 0;
            var n = d3_time_percentRe.exec(string.substring(i, i + 1));
            return n ? i + n[0].length : -1
        }

        function d3_time_formatIsoNative(date) {
            return date.toISOString()
        }

        function d3_time_scale(linear, methods, format) {
            function scale(x) {
                return linear(x)
            }
            return scale.invert = function (x) {
                    return d3_time_scaleDate(linear.invert(x))
                },
                scale.domain = function (x) {
                    return arguments.length ? (linear.domain(x), scale) : linear.domain().map(d3_time_scaleDate)
                },
                scale.nice = function (m) {
                    return scale.domain(d3_scale_nice(scale.domain(), m))
                },
                scale.ticks = function (m, k) {
                    var extent = d3_scaleExtent(scale.domain());
                    if ("function" != typeof m) {
                        var span = extent[1] - extent[0],
                            target = span / m,
                            i = d3.bisect(d3_time_scaleSteps, target);
                        if (i == d3_time_scaleSteps.length) return methods.year(extent, m);
                        if (!i) return linear.ticks(m).map(d3_time_scaleDate);
                        target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target && --i,
                            m = methods[i],
                            k = m[1],
                            m = m[0].range
                    }
                    return m(extent[0], new Date(+extent[1] + 1), k)
                },
                scale.tickFormat = function () {
                    return format
                },
                scale.copy = function () {
                    return d3_time_scale(linear.copy(), methods, format)
                },
                d3_scale_linearRebind(scale, linear)
        }

        function d3_time_scaleDate(t) {
            return new Date(t)
        }

        function d3_time_scaleFormat(formats) {
            return function (date) {
                for (var i = formats.length - 1,
                        f = formats[i]; !f[1](date);) f = formats[--i];
                return f[0](date)
            }
        }

        function d3_time_scaleSetYear(y) {
            var d = new Date(y, 0, 1);
            return d.setFullYear(y),
                d
        }

        function d3_time_scaleGetYear(d) {
            var y = d.getFullYear(),
                d0 = d3_time_scaleSetYear(y),
                d1 = d3_time_scaleSetYear(y + 1);
            return y + (d - d0) / (d1 - d0)
        }

        function d3_time_scaleUTCSetYear(y) {
            var d = new Date(Date.UTC(y, 0, 1));
            return d.setUTCFullYear(y),
                d
        }

        function d3_time_scaleUTCGetYear(d) {
            var y = d.getUTCFullYear(),
                d0 = d3_time_scaleUTCSetYear(y),
                d1 = d3_time_scaleUTCSetYear(y + 1);
            return y + (d - d0) / (d1 - d0)
        }

        function d3_json(request) {
            return JSON.parse(request.responseText)
        }

        function d3_html(request) {
            var range = d3_document.createRange();
            return range.selectNode(d3_document.body),
                range.createContextualFragment(request.responseText)
        }
        var d3 = {
            version: "3.2.8"
        };
        Date.now || (Date.now = function () {
            return +new Date
        });
        var d3_document = document,
            d3_documentElement = d3_document.documentElement,
            d3_window = window;
        try {
            d3_document.createElement("div").style.setProperty("opacity", 0, "")
        } catch (error) {
            var d3_element_prototype = d3_window.Element.prototype,
                d3_element_setAttribute = d3_element_prototype.setAttribute,
                d3_element_setAttributeNS = d3_element_prototype.setAttributeNS,
                d3_style_prototype = d3_window.CSSStyleDeclaration.prototype,
                d3_style_setProperty = d3_style_prototype.setProperty;
            d3_element_prototype.setAttribute = function (name, value) {
                    d3_element_setAttribute.call(this, name, value + "")
                },
                d3_element_prototype.setAttributeNS = function (space, local, value) {
                    d3_element_setAttributeNS.call(this, space, local, value + "")
                },
                d3_style_prototype.setProperty = function (name, value, priority) {
                    d3_style_setProperty.call(this, name, value + "", priority)
                }
        }
        d3.ascending = function (a, b) {
                return b > a ? -1 : a > b ? 1 : a >= b ? 0 : 0 / 0
            },
            d3.descending = function (a, b) {
                return a > b ? -1 : b > a ? 1 : b >= a ? 0 : 0 / 0
            },
            d3.min = function (array, f) {
                var a, b, i = -1,
                    n = array.length;
                if (1 === arguments.length) {
                    for (; ++i < n && !(null != (a = array[i]) && a >= a);) a = void 0;
                    for (; ++i < n;) null != (b = array[i]) && a > b && (a = b)
                } else {
                    for (; ++i < n && !(null != (a = f.call(array, array[i], i)) && a >= a);) a = void 0;
                    for (; ++i < n;) null != (b = f.call(array, array[i], i)) && a > b && (a = b)
                }
                return a
            },
            d3.max = function (array, f) {
                var a, b, i = -1,
                    n = array.length;
                if (1 === arguments.length) {
                    for (; ++i < n && !(null != (a = array[i]) && a >= a);) a = void 0;
                    for (; ++i < n;) null != (b = array[i]) && b > a && (a = b)
                } else {
                    for (; ++i < n && !(null != (a = f.call(array, array[i], i)) && a >= a);) a = void 0;
                    for (; ++i < n;) null != (b = f.call(array, array[i], i)) && b > a && (a = b)
                }
                return a
            },
            d3.extent = function (array, f) {
                var a, b, c, i = -1,
                    n = array.length;
                if (1 === arguments.length) {
                    for (; ++i < n && !(null != (a = c = array[i]) && a >= a);) a = c = void 0;
                    for (; ++i < n;) null != (b = array[i]) && (a > b && (a = b), b > c && (c = b))
                } else {
                    for (; ++i < n && !(null != (a = c = f.call(array, array[i], i)) && a >= a);) a = void 0;
                    for (; ++i < n;) null != (b = f.call(array, array[i], i)) && (a > b && (a = b), b > c && (c = b))
                }
                return [a, c]
            },
            d3.sum = function (array, f) {
                var a, s = 0,
                    n = array.length,
                    i = -1;
                if (1 === arguments.length)
                    for (; ++i < n;) isNaN(a = +array[i]) || (s += a);
                else
                    for (; ++i < n;) isNaN(a = +f.call(array, array[i], i)) || (s += a);
                return s
            },
            d3.mean = function (array, f) {
                var a, n = array.length,
                    m = 0,
                    i = -1,
                    j = 0;
                if (1 === arguments.length)
                    for (; ++i < n;) d3_number(a = array[i]) && (m += (a - m) / ++j);
                else
                    for (; ++i < n;) d3_number(a = f.call(array, array[i], i)) && (m += (a - m) / ++j);
                return j ? m : void 0
            },
            d3.quantile = function (values, p) {
                var H = (values.length - 1) * p + 1,
                    h = Math.floor(H),
                    v = +values[h - 1],
                    e = H - h;
                return e ? v + e * (values[h] - v) : v
            },
            d3.median = function (array, f) {
                return arguments.length > 1 && (array = array.map(f)),
                    array = array.filter(d3_number),
                    array.length ? d3.quantile(array.sort(d3.ascending), .5) : void 0
            },
            d3.bisector = function (f) {
                return {
                    left: function (a, x, lo, hi) {
                        for (arguments.length < 3 && (lo = 0), arguments.length < 4 && (hi = a.length); hi > lo;) {
                            var mid = lo + hi >>> 1;
                            f.call(a, a[mid], mid) < x ? lo = mid + 1 : hi = mid
                        }
                        return lo
                    },
                    right: function (a, x, lo, hi) {
                        for (arguments.length < 3 && (lo = 0), arguments.length < 4 && (hi = a.length); hi > lo;) {
                            var mid = lo + hi >>> 1;
                            x < f.call(a, a[mid], mid) ? hi = mid : lo = mid + 1
                        }
                        return lo
                    }
                }
            };
        var d3_bisector = d3.bisector(function (d) {
            return d
        });
        d3.bisectLeft = d3_bisector.left,
            d3.bisect = d3.bisectRight = d3_bisector.right,
            d3.shuffle = function (array) {
                for (var t, i, m = array.length; m;) i = Math.random() * m-- | 0,
                    t = array[m],
                    array[m] = array[i],
                    array[i] = t;
                return array
            },
            d3.permute = function (array, indexes) {
                for (var i = indexes.length,
                        permutes = new Array(i); i--;) permutes[i] = array[indexes[i]];
                return permutes
            },
            d3.zip = function () {
                if (!(n = arguments.length)) return [];
                for (var i = -1,
                        m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m;)
                    for (var n, j = -1,
                            zip = zips[i] = new Array(n); ++j < n;) zip[j] = arguments[j][i];
                return zips
            },
            d3.transpose = function (matrix) {
                return d3.zip.apply(d3, matrix)
            },
            d3.keys = function (map) {
                var keys = [];
                for (var key in map) keys.push(key);
                return keys
            },
            d3.values = function (map) {
                var values = [];
                for (var key in map) values.push(map[key]);
                return values
            },
            d3.entries = function (map) {
                var entries = [];
                for (var key in map) entries.push({
                    key: key,
                    value: map[key]
                });
                return entries
            },
            d3.merge = function (arrays) {
                return Array.prototype.concat.apply([], arrays)
            },
            d3.range = function (start, stop, step) {
                if (arguments.length < 3 && (step = 1, arguments.length < 2 && (stop = start, start = 0)), (stop - start) / step === 1 / 0) throw new Error("infinite range");
                var j, range = [],
                    k = d3_range_integerScale(Math.abs(step)),
                    i = -1;
                if (start *= k, stop *= k, step *= k, 0 > step)
                    for (;
                        (j = start + step * ++i) > stop;) range.push(j / k);
                else
                    for (;
                        (j = start + step * ++i) < stop;) range.push(j / k);
                return range
            },
            d3.map = function (object) {
                var map = new d3_Map;
                if (object instanceof d3_Map) object.forEach(function (key, value) {
                    map.set(key, value)
                });
                else
                    for (var key in object) map.set(key, object[key]);
                return map
            },
            d3_class(d3_Map, {
                has: function (key) {
                    return d3_map_prefix + key in this
                },
                get: function (key) {
                    return this[d3_map_prefix + key]
                },
                set: function (key, value) {
                    return this[d3_map_prefix + key] = value
                },
                remove: function (key) {
                    return key = d3_map_prefix + key,
                        key in this && delete this[key]
                },
                keys: function () {
                    var keys = [];
                    return this.forEach(function (key) {
                            keys.push(key)
                        }),
                        keys
                },
                values: function () {
                    var values = [];
                    return this.forEach(function (key, value) {
                            values.push(value)
                        }),
                        values
                },
                entries: function () {
                    var entries = [];
                    return this.forEach(function (key, value) {
                            entries.push({
                                key: key,
                                value: value
                            })
                        }),
                        entries
                },
                forEach: function (f) {
                    for (var key in this) key.charCodeAt(0) === d3_map_prefixCode && f.call(this, key.substring(1), this[key])
                }
            });
        var d3_map_prefix = "\x00",
            d3_map_prefixCode = d3_map_prefix.charCodeAt(0);
        d3.nest = function () {
                function map(mapType, array, depth) {
                    if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
                    for (var keyValue, object, setter, values, i = -1,
                            n = array.length,
                            key = keys[depth++], valuesByKey = new d3_Map; ++i < n;)(values = valuesByKey.get(keyValue = key(object = array[i]))) ? values.push(object) : valuesByKey.set(keyValue, [object]);
                    return mapType ? (object = mapType(), setter = function (keyValue, values) {
                            object.set(keyValue, map(mapType, values, depth))
                        }) : (object = {},
                            setter = function (keyValue, values) {
                                object[keyValue] = map(mapType, values, depth)
                            }),
                        valuesByKey.forEach(setter),
                        object
                }

                function entries(map, depth) {
                    if (depth >= keys.length) return map;
                    var array = [],
                        sortKey = sortKeys[depth++];
                    return map.forEach(function (key, keyMap) {
                            array.push({
                                key: key,
                                values: entries(keyMap, depth)
                            })
                        }),
                        sortKey ? array.sort(function (a, b) {
                            return sortKey(a.key, b.key)
                        }) : array
                }
                var sortValues, rollup, nest = {},
                    keys = [],
                    sortKeys = [];
                return nest.map = function (array, mapType) {
                        return map(mapType, array, 0)
                    },
                    nest.entries = function (array) {
                        return entries(map(d3.map, array, 0), 0)
                    },
                    nest.key = function (d) {
                        return keys.push(d),
                            nest
                    },
                    nest.sortKeys = function (order) {
                        return sortKeys[keys.length - 1] = order,
                            nest
                    },
                    nest.sortValues = function (order) {
                        return sortValues = order,
                            nest
                    },
                    nest.rollup = function (f) {
                        return rollup = f,
                            nest
                    },
                    nest
            },
            d3.set = function (array) {
                var set = new d3_Set;
                if (array)
                    for (var i = 0,
                            n = array.length; n > i; ++i) set.add(array[i]);
                return set
            },
            d3_class(d3_Set, {
                has: function (value) {
                    return d3_map_prefix + value in this
                },
                add: function (value) {
                    return this[d3_map_prefix + value] = !0,
                        value
                },
                remove: function (value) {
                    return value = d3_map_prefix + value,
                        value in this && delete this[value]
                },
                values: function () {
                    var values = [];
                    return this.forEach(function (value) {
                            values.push(value)
                        }),
                        values
                },
                forEach: function (f) {
                    for (var value in this) value.charCodeAt(0) === d3_map_prefixCode && f.call(this, value.substring(1))
                }
            }),
            d3.behavior = {},
            d3.rebind = function (target, source) {
                for (var method, i = 1,
                        n = arguments.length; ++i < n;) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
                return target
            };
        var d3_vendorPrefixes = ["webkit", "ms", "moz", "Moz", "o", "O"],
            d3_array = d3_arraySlice;
        try {
            d3_array(d3_documentElement.childNodes)[0].nodeType
        } catch (e) {
            d3_array = d3_arrayCopy
        }
        d3.dispatch = function () {
                for (var dispatch = new d3_dispatch,
                        i = -1,
                        n = arguments.length; ++i < n;) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
                return dispatch
            },
            d3_dispatch.prototype.on = function (type, listener) {
                var i = type.indexOf("."),
                    name = "";
                if (i >= 0 && (name = type.substring(i + 1), type = type.substring(0, i)), type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
                if (2 === arguments.length) {
                    if (null == listener)
                        for (type in this) this.hasOwnProperty(type) && this[type].on(name, null);
                    return this
                }
            },
            d3.event = null,
            d3.requote = function (s) {
                return s.replace(d3_requote_re, "\\$&")
            };
        var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g,
            d3_subclass = {}.__proto__ ?
            function (object, prototype) {
                object.__proto__ = prototype
            } : function (object, prototype) {
                for (var property in prototype) object[property] = prototype[property]
            },
            d3_select = function (s, n) {
                return n.querySelector(s)
            },
            d3_selectAll = function (s, n) {
                return n.querySelectorAll(s)
            },
            d3_selectMatcher = d3_documentElement[d3_vendorSymbol(d3_documentElement, "matchesSelector")],
            d3_selectMatches = function (n, s) {
                return d3_selectMatcher.call(n, s)
            };
        "function" == typeof Sizzle && (d3_select = function (s, n) {
                    return Sizzle(s, n)[0] || null
                },
                d3_selectAll = function (s, n) {
                    return Sizzle.uniqueSort(Sizzle(s, n))
                },
                d3_selectMatches = Sizzle.matchesSelector),
            d3.selection = function () {
                return d3_selectionRoot
            };
        var d3_selectionPrototype = d3.selection.prototype = [];
        d3_selectionPrototype.select = function (selector) {
                var subgroup, subnode, group, node, subgroups = [];
                selector = d3_selection_selector(selector);
                for (var j = -1,
                        m = this.length; ++j < m;) {
                    subgroups.push(subgroup = []),
                        subgroup.parentNode = (group = this[j]).parentNode;
                    for (var i = -1,
                            n = group.length; ++i < n;)(node = group[i]) ? (subgroup.push(subnode = selector.call(node, node.__data__, i, j)), subnode && "__data__" in node && (subnode.__data__ = node.__data__)) : subgroup.push(null)
                }
                return d3_selection(subgroups)
            },
            d3_selectionPrototype.selectAll = function (selector) {
                var subgroup, node, subgroups = [];
                selector = d3_selection_selectorAll(selector);
                for (var j = -1,
                        m = this.length; ++j < m;)
                    for (var group = this[j], i = -1, n = group.length; ++i < n;)(node = group[i]) && (subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j))), subgroup.parentNode = node);
                return d3_selection(subgroups)
            };
        var d3_nsPrefix = {
            svg: "http://www.w3.org/2000/svg",
            xhtml: "http://www.w3.org/1999/xhtml",
            xlink: "http://www.w3.org/1999/xlink",
            xml: "http://www.w3.org/XML/1998/namespace",
            xmlns: "http://www.w3.org/2000/xmlns/"
        };
        d3.ns = {
                prefix: d3_nsPrefix,
                qualify: function (name) {
                    var i = name.indexOf(":"),
                        prefix = name;
                    return i >= 0 && (prefix = name.substring(0, i), name = name.substring(i + 1)),
                        d3_nsPrefix.hasOwnProperty(prefix) ? {
                            space: d3_nsPrefix[prefix],
                            local: name
                        } : name
                }
            },
            d3_selectionPrototype.attr = function (name, value) {
                if (arguments.length < 2) {
                    if ("string" == typeof name) {
                        var node = this.node();
                        return name = d3.ns.qualify(name),
                            name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name)
                    }
                    for (value in name) this.each(d3_selection_attr(value, name[value]));
                    return this
                }
                return this.each(d3_selection_attr(name, value))
            },
            d3_selectionPrototype.classed = function (name, value) {
                if (arguments.length < 2) {
                    if ("string" == typeof name) {
                        var node = this.node(),
                            n = (name = name.trim().split(/^|\s+/g)).length,
                            i = -1;
                        if (value = node.classList) {
                            for (; ++i < n;)
                                if (!value.contains(name[i])) return !1
                        } else
                            for (value = node.getAttribute("class"); ++i < n;)
                                if (!d3_selection_classedRe(name[i]).test(value)) return !1;
                        return !0
                    }
                    for (value in name) this.each(d3_selection_classed(value, name[value]));
                    return this
                }
                return this.each(d3_selection_classed(name, value))
            },
            d3_selectionPrototype.style = function (name, value, priority) {
                var n = arguments.length;
                if (3 > n) {
                    if ("string" != typeof name) {
                        2 > n && (value = "");
                        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
                        return this
                    }
                    if (2 > n) return d3_window.getComputedStyle(this.node(), null).getPropertyValue(name);
                    priority = ""
                }
                return this.each(d3_selection_style(name, value, priority))
            },
            d3_selectionPrototype.property = function (name, value) {
                if (arguments.length < 2) {
                    if ("string" == typeof name) return this.node()[name];
                    for (value in name) this.each(d3_selection_property(value, name[value]));
                    return this
                }
                return this.each(d3_selection_property(name, value))
            },
            d3_selectionPrototype.text = function (value) {
                return arguments.length ? this.each("function" == typeof value ?
                    function () {
                        var v = value.apply(this, arguments);
                        this.textContent = null == v ? "" : v
                    } : null == value ?
                    function () {
                        this.textContent = ""
                    } : function () {
                        this.textContent = value
                    }) : this.node().textContent
            },
            d3_selectionPrototype.html = function (value) {
                return arguments.length ? this.each("function" == typeof value ?
                    function () {
                        var v = value.apply(this, arguments);
                        this.innerHTML = null == v ? "" : v
                    } : null == value ?
                    function () {
                        this.innerHTML = ""
                    } : function () {
                        this.innerHTML = value
                    }) : this.node().innerHTML
            },
            d3_selectionPrototype.append = function (name) {
                return name = d3_selection_creator(name),
                    this.select(function () {
                        return this.appendChild(name.apply(this, arguments))
                    })
            },
            d3_selectionPrototype.insert = function (name, before) {
                return name = d3_selection_creator(name),
                    before = d3_selection_selector(before),
                    this.select(function () {
                        return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments))
                    })
            },
            d3_selectionPrototype.remove = function () {
                return this.each(function () {
                    var parent = this.parentNode;
                    parent && parent.removeChild(this)
                })
            },
            d3_selectionPrototype.data = function (value, key) {
                function bind(group, groupData) {
                    var i, node, nodeData, n = group.length,
                        m = groupData.length,
                        n0 = Math.min(n, m),
                        updateNodes = new Array(m),
                        enterNodes = new Array(m),
                        exitNodes = new Array(n);
                    if (key) {
                        var keyValue, nodeByKeyValue = new d3_Map,
                            dataByKeyValue = new d3_Map,
                            keyValues = [];
                        for (i = -1; ++i < n;) keyValue = key.call(node = group[i], node.__data__, i),
                            nodeByKeyValue.has(keyValue) ? exitNodes[i] = node : nodeByKeyValue.set(keyValue, node),
                            keyValues.push(keyValue);
                        for (i = -1; ++i < m;) keyValue = key.call(groupData, nodeData = groupData[i], i),
                            (node = nodeByKeyValue.get(keyValue)) ? (updateNodes[i] = node, node.__data__ = nodeData) : dataByKeyValue.has(keyValue) || (enterNodes[i] = d3_selection_dataNode(nodeData)),
                            dataByKeyValue.set(keyValue, nodeData),
                            nodeByKeyValue.remove(keyValue);
                        for (i = -1; ++i < n;) nodeByKeyValue.has(keyValues[i]) && (exitNodes[i] = group[i])
                    } else {
                        for (i = -1; ++i < n0;) node = group[i],
                            nodeData = groupData[i],
                            node ? (node.__data__ = nodeData, updateNodes[i] = node) : enterNodes[i] = d3_selection_dataNode(nodeData);
                        for (; m > i; ++i) enterNodes[i] = d3_selection_dataNode(groupData[i]);
                        for (; n > i; ++i) exitNodes[i] = group[i]
                    }
                    enterNodes.update = updateNodes,
                        enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode,
                        enter.push(enterNodes),
                        update.push(updateNodes),
                        exit.push(exitNodes)
                }
                var group, node, i = -1,
                    n = this.length;
                if (!arguments.length) {
                    for (value = new Array(n = (group = this[0]).length); ++i < n;)(node = group[i]) && (value[i] = node.__data__);
                    return value
                }
                var enter = d3_selection_enter([]),
                    update = d3_selection([]),
                    exit = d3_selection([]);
                if ("function" == typeof value)
                    for (; ++i < n;) bind(group = this[i], value.call(group, group.parentNode.__data__, i));
                else
                    for (; ++i < n;) bind(group = this[i], value);
                return update.enter = function () {
                        return enter
                    },
                    update.exit = function () {
                        return exit
                    },
                    update
            },
            d3_selectionPrototype.datum = function (value) {
                return arguments.length ? this.property("__data__", value) : this.property("__data__")
            },
            d3_selectionPrototype.filter = function (filter) {
                var subgroup, group, node, subgroups = [];
                "function" != typeof filter && (filter = d3_selection_filter(filter));
                for (var j = 0,
                        m = this.length; m > j; j++) {
                    subgroups.push(subgroup = []),
                        subgroup.parentNode = (group = this[j]).parentNode;
                    for (var i = 0,
                            n = group.length; n > i; i++)(node = group[i]) && filter.call(node, node.__data__, i) && subgroup.push(node)
                }
                return d3_selection(subgroups)
            },
            d3_selectionPrototype.order = function () {
                for (var j = -1,
                        m = this.length; ++j < m;)
                    for (var node, group = this[j], i = group.length - 1, next = group[i]; --i >= 0;)(node = group[i]) && (next && next !== node.nextSibling && next.parentNode.insertBefore(node, next), next = node);
                return this
            },
            d3_selectionPrototype.sort = function (comparator) {
                comparator = d3_selection_sortComparator.apply(this, arguments);
                for (var j = -1,
                        m = this.length; ++j < m;) this[j].sort(comparator);
                return this.order()
            },
            d3_selectionPrototype.each = function (callback) {
                return d3_selection_each(this,
                    function (node, i, j) {
                        callback.call(node, node.__data__, i, j)
                    })
            },
            d3_selectionPrototype.call = function (callback) {
                var args = d3_array(arguments);
                return callback.apply(args[0] = this, args),
                    this
            },
            d3_selectionPrototype.empty = function () {
                return !this.node()
            },
            d3_selectionPrototype.node = function () {
                for (var j = 0,
                        m = this.length; m > j; j++)
                    for (var group = this[j], i = 0, n = group.length; n > i; i++) {
                        var node = group[i];
                        if (node) return node
                    }
                return null
            },
            d3_selectionPrototype.size = function () {
                var n = 0;
                return this.each(function () {
                        ++n
                    }),
                    n
            };
        var d3_selection_enterPrototype = [];
        d3.selection.enter = d3_selection_enter,
            d3.selection.enter.prototype = d3_selection_enterPrototype,
            d3_selection_enterPrototype.append = d3_selectionPrototype.append,
            d3_selection_enterPrototype.empty = d3_selectionPrototype.empty,
            d3_selection_enterPrototype.node = d3_selectionPrototype.node,
            d3_selection_enterPrototype.call = d3_selectionPrototype.call,
            d3_selection_enterPrototype.size = d3_selectionPrototype.size,
            d3_selection_enterPrototype.select = function (selector) {
                for (var subgroup, subnode, upgroup, group, node, subgroups = [], j = -1, m = this.length; ++j < m;) {
                    upgroup = (group = this[j]).update,
                        subgroups.push(subgroup = []),
                        subgroup.parentNode = group.parentNode;
                    for (var i = -1,
                            n = group.length; ++i < n;)(node = group[i]) ? (subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j)), subnode.__data__ = node.__data__) : subgroup.push(null)
                }
                return d3_selection(subgroups)
            },
            d3_selection_enterPrototype.insert = function (name, before) {
                return arguments.length < 2 && (before = d3_selection_enterInsertBefore(this)),
                    d3_selectionPrototype.insert.call(this, name, before)
            },
            d3_selectionPrototype.transition = function () {
                for (var subgroup, node, id = d3_transitionInheritId || ++d3_transitionId,
                        subgroups = [], transition = d3_transitionInherit || {
                            time: Date.now(),
                            ease: d3_ease_cubicInOut,
                            delay: 0,
                            duration: 250
                        },
                        j = -1, m = this.length; ++j < m;) {
                    subgroups.push(subgroup = []);
                    for (var group = this[j], i = -1, n = group.length; ++i < n;)(node = group[i]) && d3_transitionNode(node, i, id, transition),
                        subgroup.push(node)
                }
                return d3_transition(subgroups, id)
            },
            d3.select = function (node) {
                var group = ["string" == typeof node ? d3_select(node, d3_document) : node];
                return group.parentNode = d3_documentElement,
                    d3_selection([group])
            },
            d3.selectAll = function (nodes) {
                var group = d3_array("string" == typeof nodes ? d3_selectAll(nodes, d3_document) : nodes);
                return group.parentNode = d3_documentElement,
                    d3_selection([group])
            };
        var d3_selectionRoot = d3.select(d3_documentElement);
        d3_selectionPrototype.on = function (type, listener, capture) {
            var n = arguments.length;
            if (3 > n) {
                if ("string" != typeof type) {
                    2 > n && (listener = !1);
                    for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
                    return this
                }
                if (2 > n) return (n = this.node()["__on" + type]) && n._;
                capture = !1
            }
            return this.each(d3_selection_on(type, listener, capture))
        };
        var d3_selection_onFilters = d3.map({
            mouseenter: "mouseover",
            mouseleave: "mouseout"
        });
        d3_selection_onFilters.forEach(function (k) {
            "on" + k in d3_document && d3_selection_onFilters.remove(k)
        });
        var d3_event_dragSelect = d3_vendorSymbol(d3_documentElement.style, "userSelect"),
            d3_event_dragId = 0;
        d3.mouse = function (container) {
            return d3_mousePoint(container, d3_eventSource())
        };
        var d3_mouse_bug44083 = /WebKit/.test(d3_window.navigator.userAgent) ? -1 : 0;
        d3.touches = function (container, touches) {
                return arguments.length < 2 && (touches = d3_eventSource().touches),
                    touches ? d3_array(touches).map(function (touch) {
                        var point = d3_mousePoint(container, touch);
                        return point.identifier = touch.identifier,
                            point
                    }) : []
            },
            d3.behavior.drag = function () {
                function drag() {
                    this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart)
                }

                function touchid() {
                    return d3.event.changedTouches[0].identifier
                }

                function touchposition(parent, id) {
                    return d3.touches(parent).filter(function (p) {
                        return p.identifier === id
                    })[0]
                }

                function dragstart(id, position, move, end) {
                    return function () {
                        function moved() {
                            if (!parent) return ended();
                            var p = position(parent, eventId),
                                dx = p[0] - origin_[0],
                                dy = p[1] - origin_[1];
                            dragged |= dx | dy,
                                origin_ = p,
                                event_({
                                    type: "drag",
                                    x: p[0] + offset[0],
                                    y: p[1] + offset[1],
                                    dx: dx,
                                    dy: dy
                                })
                        }

                        function ended() {
                            w.on(move + "." + drag, null).on(end + "." + drag, null),
                                dragRestore(dragged && d3.event.target === eventTarget),
                                event_({
                                    type: "dragend"
                                })
                        }
                        var offset, target = this,
                            parent = target.parentNode,
                            event_ = event.of(target, arguments),
                            eventTarget = d3.event.target,
                            eventId = id(),
                            drag = null == eventId ? "drag" : "drag-" + eventId,
                            origin_ = position(parent, eventId),
                            dragged = 0,
                            w = d3.select(d3_window).on(move + "." + drag, moved).on(end + "." + drag, ended),
                            dragRestore = d3_event_dragSuppress();
                        origin ? (offset = origin.apply(target, arguments), offset = [offset.x - origin_[0], offset.y - origin_[1]]) : offset = [0, 0],
                            event_({
                                type: "dragstart"
                            })
                    }
                }
                var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"),
                    origin = null,
                    mousedown = dragstart(d3_noop, d3.mouse, "mousemove", "mouseup"),
                    touchstart = dragstart(touchid, touchposition, "touchmove", "touchend");
                return drag.origin = function (x) {
                        return arguments.length ? (origin = x, drag) : origin
                    },
                    d3.rebind(drag, event, "on")
            },
            d3.behavior.zoom = function () {
                function zoom() {
                    this.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on(mousemove, mousewheelreset).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted)
                }

                function location(p) {
                    return [(p[0] - translate[0]) / scale, (p[1] - translate[1]) / scale]
                }

                function point(l) {
                    return [l[0] * scale + translate[0], l[1] * scale + translate[1]]
                }

                function scaleTo(s) {
                    scale = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s))
                }

                function translateTo(p, l) {
                    l = point(l),
                        translate[0] += p[0] - l[0],
                        translate[1] += p[1] - l[1]
                }

                function rescale() {
                    x1 && x1.domain(x0.range().map(function (x) {
                            return (x - translate[0]) / scale
                        }).map(x0.invert)),
                        y1 && y1.domain(y0.range().map(function (y) {
                            return (y - translate[1]) / scale
                        }).map(y0.invert))
                }

                function dispatch(event) {
                    rescale(),
                        event({
                            type: "zoom",
                            scale: scale,
                            translate: translate
                        })
                }

                function mousedowned() {
                    function moved() {
                        dragged = 1,
                            translateTo(d3.mouse(target), l),
                            dispatch(event_)
                    }

                    function ended() {
                        w.on(mousemove, d3_window === target ? mousewheelreset : null).on(mouseup, null),
                            dragRestore(dragged && d3.event.target === eventTarget)
                    }
                    var target = this,
                        event_ = event.of(target, arguments),
                        eventTarget = d3.event.target,
                        dragged = 0,
                        w = d3.select(d3_window).on(mousemove, moved).on(mouseup, ended),
                        l = location(d3.mouse(target)),
                        dragRestore = d3_event_dragSuppress()
                }

                function touchstarted() {
                    function relocate() {
                        var touches = d3.touches(target);
                        return scale0 = scale,
                            locations0 = {},
                            touches.forEach(function (t) {
                                locations0[t.identifier] = location(t)
                            }),
                            touches
                    }

                    function started() {
                        var now = Date.now(),
                            touches = relocate();
                        if (1 === touches.length) {
                            if (500 > now - touchtime) {
                                var p = touches[0],
                                    l = locations0[p.identifier];
                                scaleTo(2 * scale),
                                    translateTo(p, l),
                                    d3_eventPreventDefault(),
                                    dispatch(event_)
                            }
                            touchtime = now
                        } else if (touches.length > 1) {
                            var p = touches[0],
                                q = touches[1],
                                dx = p[0] - q[0],
                                dy = p[1] - q[1];
                            distance0 = dx * dx + dy * dy
                        }
                    }

                    function moved() {
                        var touches = d3.touches(target),
                            p0 = touches[0],
                            l0 = locations0[p0.identifier];
                        if (p1 = touches[1]) {
                            var p1, l1 = locations0[p1.identifier],
                                scale1 = d3.event.scale;
                            if (null == scale1) {
                                var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1;
                                scale1 = distance0 && Math.sqrt(distance1 / distance0)
                            }
                            p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2],
                                l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2],
                                scaleTo(scale1 * scale0)
                        }
                        touchtime = null,
                            translateTo(p0, l0),
                            dispatch(event_)
                    }

                    function ended() {
                        d3.event.touches.length ? relocate() : (w.on(touchmove, null).on(touchend, null), t.on(mousedown, mousedowned).on(touchstart, touchstarted), dragRestore())
                    }
                    var locations0, scale0, target = this,
                        event_ = event.of(target, arguments),
                        distance0 = 0,
                        w = d3.select(d3_window).on(touchmove, moved).on(touchend, ended),
                        t = d3.select(target).on(mousedown, null).on(touchstart, started),
                        dragRestore = d3_event_dragSuppress();
                    started()
                }

                function mousewheeled() {
                    d3_eventPreventDefault(),
                        translate0 || (translate0 = location(d3.mouse(this))),
                        scaleTo(Math.pow(2, .002 * d3_behavior_zoomDelta()) * scale),
                        translateTo(d3.mouse(this), translate0),
                        dispatch(event.of(this, arguments))
                }

                function mousewheelreset() {
                    translate0 = null
                }

                function dblclicked() {
                    var p = d3.mouse(this),
                        l = location(p),
                        k = Math.log(scale) / Math.LN2;
                    scaleTo(Math.pow(2, d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1)),
                        translateTo(p, l),
                        dispatch(event.of(this, arguments))
                }
                var translate0, touchtime, x0, x1, y0, y1, translate = [0, 0],
                    scale = 1,
                    scaleExtent = d3_behavior_zoomInfinity,
                    mousedown = "mousedown.zoom",
                    mousemove = "mousemove.zoom",
                    mouseup = "mouseup.zoom",
                    touchstart = "touchstart.zoom",
                    touchmove = "touchmove.zoom",
                    touchend = "touchend.zoom",
                    event = d3_eventDispatch(zoom, "zoom");
                return zoom.translate = function (x) {
                        return arguments.length ? (translate = x.map(Number), rescale(), zoom) : translate
                    },
                    zoom.scale = function (x) {
                        return arguments.length ? (scale = +x, rescale(), zoom) : scale
                    },
                    zoom.scaleExtent = function (x) {
                        return arguments.length ? (scaleExtent = null == x ? d3_behavior_zoomInfinity : x.map(Number), zoom) : scaleExtent
                    },
                    zoom.x = function (z) {
                        return arguments.length ? (x1 = z, x0 = z.copy(), translate = [0, 0], scale = 1, zoom) : x1
                    },
                    zoom.y = function (z) {
                        return arguments.length ? (y1 = z, y0 = z.copy(), translate = [0, 0], scale = 1, zoom) : y1
                    },
                    d3.rebind(zoom, event, "on")
            };
        var d3_behavior_zoomDelta, d3_behavior_zoomInfinity = [0, 1 / 0],
            d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function () {
                    return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1)
                },
                "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function () {
                    return d3.event.wheelDelta
                },
                "mousewheel") : (d3_behavior_zoomDelta = function () {
                    return -d3.event.detail
                },
                "MozMousePixelScroll");
        d3_Color.prototype.toString = function () {
                return this.rgb() + ""
            },
            d3.hsl = function (h, s, l) {
                return 1 === arguments.length ? h instanceof d3_Hsl ? d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : d3_hsl(+h, +s, +l)
            };
        var d3_hslPrototype = d3_Hsl.prototype = new d3_Color;
        d3_hslPrototype.brighter = function (k) {
                return k = Math.pow(.7, arguments.length ? k : 1),
                    d3_hsl(this.h, this.s, this.l / k)
            },
            d3_hslPrototype.darker = function (k) {
                return k = Math.pow(.7, arguments.length ? k : 1),
                    d3_hsl(this.h, this.s, k * this.l)
            },
            d3_hslPrototype.rgb = function () {
                return d3_hsl_rgb(this.h, this.s, this.l)
            };
        var π = Math.PI,
            ε = 1e-6,
            ε2 = ε * ε,
            d3_radians = π / 180,
            d3_degrees = 180 / π;
        d3.hcl = function (h, c, l) {
            return 1 === arguments.length ? h instanceof d3_Hcl ? d3_hcl(h.h, h.c, h.l) : h instanceof d3_Lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : d3_hcl(+h, +c, +l)
        };
        var d3_hclPrototype = d3_Hcl.prototype = new d3_Color;
        d3_hclPrototype.brighter = function (k) {
                return d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)))
            },
            d3_hclPrototype.darker = function (k) {
                return d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)))
            },
            d3_hclPrototype.rgb = function () {
                return d3_hcl_lab(this.h, this.c, this.l).rgb()
            },
            d3.lab = function (l, a, b) {
                return 1 === arguments.length ? l instanceof d3_Lab ? d3_lab(l.l, l.a, l.b) : l instanceof d3_Hcl ? d3_hcl_lab(l.l, l.c, l.h) : d3_rgb_lab((l = d3.rgb(l)).r, l.g, l.b) : d3_lab(+l, +a, +b)
            };
        var d3_lab_K = 18,
            d3_lab_X = .95047,
            d3_lab_Y = 1,
            d3_lab_Z = 1.08883,
            d3_labPrototype = d3_Lab.prototype = new d3_Color;
        d3_labPrototype.brighter = function (k) {
                return d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b)
            },
            d3_labPrototype.darker = function (k) {
                return d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b)
            },
            d3_labPrototype.rgb = function () {
                return d3_lab_rgb(this.l, this.a, this.b)
            },
            d3.rgb = function (r, g, b) {
                return 1 === arguments.length ? r instanceof d3_Rgb ? d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : d3_rgb(~~r, ~~g, ~~b)
            };
        var d3_rgbPrototype = d3_Rgb.prototype = new d3_Color;
        d3_rgbPrototype.brighter = function (k) {
                k = Math.pow(.7, arguments.length ? k : 1);
                var r = this.r,
                    g = this.g,
                    b = this.b,
                    i = 30;
                return r || g || b ? (r && i > r && (r = i), g && i > g && (g = i), b && i > b && (b = i), d3_rgb(Math.min(255, ~~(r / k)), Math.min(255, ~~(g / k)), Math.min(255, ~~(b / k)))) : d3_rgb(i, i, i)
            },
            d3_rgbPrototype.darker = function (k) {
                return k = Math.pow(.7, arguments.length ? k : 1),
                    d3_rgb(~~(k * this.r), ~~(k * this.g), ~~(k * this.b))
            },
            d3_rgbPrototype.hsl = function () {
                return d3_rgb_hsl(this.r, this.g, this.b)
            },
            d3_rgbPrototype.toString = function () {
                return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b)
            };
        var d3_rgb_names = d3.map({
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        });
        d3_rgb_names.forEach(function (key, value) {
                d3_rgb_names.set(key, d3_rgbNumber(value))
            }),
            d3.functor = d3_functor,
            d3.xhr = d3_xhrType(d3_identity),
            d3.dsv = function (delimiter, mimeType) {
                function dsv(url, row, callback) {
                    arguments.length < 3 && (callback = row, row = null);
                    var xhr = d3.xhr(url, mimeType, callback);
                    return xhr.row = function (_) {
                            return arguments.length ? xhr.response(null == (row = _) ? response : typedResponse(_)) : row
                        },
                        xhr.row(row)
                }

                function response(request) {
                    return dsv.parse(request.responseText)
                }

                function typedResponse(f) {
                    return function (request) {
                        return dsv.parse(request.responseText, f)
                    }
                }

                function formatRow(row) {
                    return row.map(formatValue).join(delimiter)
                }

                function formatValue(text) {
                    return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text
                }
                var reFormat = new RegExp('["' + delimiter + "\n]"),
                    delimiterCode = delimiter.charCodeAt(0);
                return dsv.parse = function (text, f) {
                        var o;
                        return dsv.parseRows(text,
                            function (row, i) {
                                if (o) return o(row, i - 1);
                                var a = new Function("d", "return {" + row.map(function (name, i) {
                                    return JSON.stringify(name) + ": d[" + i + "]"
                                }).join(",") + "}");
                                o = f ?
                                    function (row, i) {
                                        return f(a(row), i)
                                    } : a
                            })
                    },
                    dsv.parseRows = function (text, f) {
                        function token() {
                            if (I >= N) return EOF;
                            if (eol) return eol = !1,
                                EOL;
                            var j = I;
                            if (34 === text.charCodeAt(j)) {
                                for (var i = j; i++ < N;)
                                    if (34 === text.charCodeAt(i)) {
                                        if (34 !== text.charCodeAt(i + 1)) break;
                                        ++i
                                    }
                                I = i + 2;
                                var c = text.charCodeAt(i + 1);
                                return 13 === c ? (eol = !0, 10 === text.charCodeAt(i + 2) && ++I) : 10 === c && (eol = !0),
                                    text.substring(j + 1, i).replace(/""/g, '"')
                            }
                            for (; N > I;) {
                                var c = text.charCodeAt(I++),
                                    k = 1;
                                if (10 === c) eol = !0;
                                else if (13 === c) eol = !0,
                                    10 === text.charCodeAt(I) && (++I, ++k);
                                else if (c !== delimiterCode) continue;
                                return text.substring(j, I - k)
                            }
                            return text.substring(j)
                        }
                        for (var t, eol, EOL = {},
                                EOF = {},
                                rows = [], N = text.length, I = 0, n = 0;
                            (t = token()) !== EOF;) {
                            for (var a = []; t !== EOL && t !== EOF;) a.push(t),
                                t = token();
                            (!f || (a = f(a, n++))) && rows.push(a)
                        }
                        return rows
                    },
                    dsv.format = function (rows) {
                        if (Array.isArray(rows[0])) return dsv.formatRows(rows);
                        var fieldSet = new d3_Set,
                            fields = [];
                        return rows.forEach(function (row) {
                            for (var field in row) fieldSet.has(field) || fields.push(fieldSet.add(field))
                        }), [fields.map(formatValue).join(delimiter)].concat(rows.map(function (row) {
                            return fields.map(function (field) {
                                return formatValue(row[field])
                            }).join(delimiter)
                        })).join("\n")
                    },
                    dsv.formatRows = function (rows) {
                        return rows.map(formatRow).join("\n")
                    },
                    dsv
            },
            d3.csv = d3.dsv(",", "text/csv"),
            d3.tsv = d3.dsv("	", "text/tab-separated-values");
        var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_active, d3_timer_frame = d3_window[d3_vendorSymbol(d3_window, "requestAnimationFrame")] ||
            function (callback) {
                setTimeout(callback, 17)
            };
        d3.timer = function (callback, delay, then) {
                var n = arguments.length;
                2 > n && (delay = 0),
                    3 > n && (then = Date.now());
                var time = then + delay,
                    timer = {
                        callback: callback,
                        time: time,
                        next: null
                    };
                d3_timer_queueTail ? d3_timer_queueTail.next = timer : d3_timer_queueHead = timer,
                    d3_timer_queueTail = timer,
                    d3_timer_interval || (d3_timer_timeout = clearTimeout(d3_timer_timeout), d3_timer_interval = 1, d3_timer_frame(d3_timer_step))
            },
            d3.timer.flush = function () {
                d3_timer_mark(),
                    d3_timer_sweep()
            };
        var d3_format_decimalPoint = ".",
            d3_format_thousandsSeparator = ",",
            d3_format_grouping = [3, 3],
            d3_format_currencySymbol = "$",
            d3_formatPrefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"].map(d3_formatPrefix);
        d3.formatPrefix = function (value, precision) {
                var i = 0;
                return value && (0 > value && (value *= -1), precision && (value = d3.round(value, d3_format_precision(value, precision))), i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10), i = Math.max(-24, Math.min(24, 3 * Math.floor((0 >= i ? i + 1 : i - 1) / 3)))),
                    d3_formatPrefixes[8 + i / 3]
            },
            d3.round = function (x, n) {
                return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x)
            },
            d3.format = function (specifier) {
                var match = d3_format_re.exec(specifier),
                    fill = match[1] || " ",
                    align = match[2] || ">",
                    sign = match[3] || "",
                    symbol = match[4] || "",
                    zfill = match[5],
                    width = +match[6],
                    comma = match[7],
                    precision = match[8],
                    type = match[9],
                    scale = 1,
                    suffix = "",
                    integer = !1;
                switch (precision && (precision = +precision.substring(1)), (zfill || "0" === fill && "=" === align) && (zfill = fill = "0", align = "=", comma && (width -= Math.floor((width - 1) / 4))), type) {
                    case "n":
                        comma = !0,
                            type = "g";
                        break;
                    case "%":
                        scale = 100,
                            suffix = "%",
                            type = "f";
                        break;
                    case "p":
                        scale = 100,
                            suffix = "%",
                            type = "r";
                        break;
                    case "b":
                    case "o":
                    case "x":
                    case "X":
                        "#" === symbol && (symbol = "0" + type.toLowerCase());
                    case "c":
                    case "d":
                        integer = !0,
                            precision = 0;
                        break;
                    case "s":
                        scale = -1,
                            type = "r"
                }
                "#" === symbol ? symbol = "" : "$" === symbol && (symbol = d3_format_currencySymbol),
                    "r" != type || precision || (type = "g"),
                    null != precision && ("g" == type ? precision = Math.max(1, Math.min(21, precision)) : ("e" == type || "f" == type) && (precision = Math.max(0, Math.min(20, precision)))),
                    type = d3_format_types.get(type) || d3_format_typeDefault;
                var zcomma = zfill && comma;
                return function (value) {
                    if (integer && value % 1) return "";
                    var negative = 0 > value || 0 === value && 0 > 1 / value ? (value = -value, "-") : sign;
                    if (0 > scale) {
                        var prefix = d3.formatPrefix(value, precision);
                        value = prefix.scale(value),
                            suffix = prefix.symbol
                    } else value *= scale;
                    value = type(value, precision);
                    var i = value.lastIndexOf("."),
                        before = 0 > i ? value : value.substring(0, i),
                        after = 0 > i ? "" : d3_format_decimalPoint + value.substring(i + 1);
                    !zfill && comma && (before = d3_format_group(before));
                    var length = symbol.length + before.length + after.length + (zcomma ? 0 : negative.length),
                        padding = width > length ? new Array(length = width - length + 1).join(fill) : "";
                    return zcomma && (before = d3_format_group(padding + before)),
                        negative += symbol,
                        value = before + after,
                        ("<" === align ? negative + value + padding : ">" === align ? padding + negative + value : "^" === align ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + suffix
                }
            };
        var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i,
            d3_format_types = d3.map({
                b: function (x) {
                    return x.toString(2)
                },
                c: function (x) {
                    return String.fromCharCode(x)
                },
                o: function (x) {
                    return x.toString(8)
                },
                x: function (x) {
                    return x.toString(16)
                },
                X: function (x) {
                    return x.toString(16).toUpperCase()
                },
                g: function (x, p) {
                    return x.toPrecision(p)
                },
                e: function (x, p) {
                    return x.toExponential(p)
                },
                f: function (x, p) {
                    return x.toFixed(p)
                },
                r: function (x, p) {
                    return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))))
                }
            }),
            d3_format_group = d3_identity;
        if (d3_format_grouping) {
            var d3_format_groupingLength = d3_format_grouping.length;
            d3_format_group = function (value) {
                for (var i = value.length,
                        t = [], j = 0, g = d3_format_grouping[0]; i > 0 && g > 0;) t.push(value.substring(i -= g, i + g)),
                    g = d3_format_grouping[j = (j + 1) % d3_format_groupingLength];
                return t.reverse().join(d3_format_thousandsSeparator)
            }
        }
        d3.geo = {},
            d3_adder.prototype = {
                s: 0,
                t: 0,
                add: function (y) {
                    d3_adderSum(y, this.t, d3_adderTemp),
                        d3_adderSum(d3_adderTemp.s, this.s, this),
                        this.s ? this.t += d3_adderTemp.t : this.s = d3_adderTemp.t
                },
                reset: function () {
                    this.s = this.t = 0
                },
                valueOf: function () {
                    return this.s
                }
            };
        var d3_adderTemp = new d3_adder;
        d3.geo.stream = function (object, listener) {
            object && d3_geo_streamObjectType.hasOwnProperty(object.type) ? d3_geo_streamObjectType[object.type](object, listener) : d3_geo_streamGeometry(object, listener)
        };
        var d3_geo_streamObjectType = {
                Feature: function (feature, listener) {
                    d3_geo_streamGeometry(feature.geometry, listener)
                },
                FeatureCollection: function (object, listener) {
                    for (var features = object.features,
                            i = -1,
                            n = features.length; ++i < n;) d3_geo_streamGeometry(features[i].geometry, listener)
                }
            },
            d3_geo_streamGeometryType = {
                Sphere: function (object, listener) {
                    listener.sphere()
                },
                Point: function (object, listener) {
                    var coordinate = object.coordinates;
                    listener.point(coordinate[0], coordinate[1])
                },
                MultiPoint: function (object, listener) {
                    for (var coordinate, coordinates = object.coordinates,
                            i = -1,
                            n = coordinates.length; ++i < n;) coordinate = coordinates[i],
                        listener.point(coordinate[0], coordinate[1])
                },
                LineString: function (object, listener) {
                    d3_geo_streamLine(object.coordinates, listener, 0)
                },
                MultiLineString: function (object, listener) {
                    for (var coordinates = object.coordinates,
                            i = -1,
                            n = coordinates.length; ++i < n;) d3_geo_streamLine(coordinates[i], listener, 0)
                },
                Polygon: function (object, listener) {
                    d3_geo_streamPolygon(object.coordinates, listener)
                },
                MultiPolygon: function (object, listener) {
                    for (var coordinates = object.coordinates,
                            i = -1,
                            n = coordinates.length; ++i < n;) d3_geo_streamPolygon(coordinates[i], listener)
                },
                GeometryCollection: function (object, listener) {
                    for (var geometries = object.geometries,
                            i = -1,
                            n = geometries.length; ++i < n;) d3_geo_streamGeometry(geometries[i], listener)
                }
            };
        d3.geo.area = function (object) {
            return d3_geo_areaSum = 0,
                d3.geo.stream(object, d3_geo_area),
                d3_geo_areaSum
        };
        var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder,
            d3_geo_area = {
                sphere: function () {
                    d3_geo_areaSum += 4 * π
                },
                point: d3_noop,
                lineStart: d3_noop,
                lineEnd: d3_noop,
                polygonStart: function () {
                    d3_geo_areaRingSum.reset(),
                        d3_geo_area.lineStart = d3_geo_areaRingStart
                },
                polygonEnd: function () {
                    var area = 2 * d3_geo_areaRingSum;
                    d3_geo_areaSum += 0 > area ? 4 * π + area : area,
                        d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop
                }
            };
        d3.geo.bounds = function () {
                function point(λ, φ) {
                    ranges.push(range = [λ0 = λ, λ1 = λ]),
                        φ0 > φ && (φ0 = φ),
                        φ > φ1 && (φ1 = φ)
                }

                function linePoint(λ, φ) {
                    var p = d3_geo_cartesian([λ * d3_radians, φ * d3_radians]);
                    if (p0) {
                        var normal = d3_geo_cartesianCross(p0, p),
                            equatorial = [normal[1], -normal[0], 0],
                            inflection = d3_geo_cartesianCross(equatorial, normal);
                        d3_geo_cartesianNormalize(inflection),
                            inflection = d3_geo_spherical(inflection);
                        var dλ = λ - λ_,
                            s = dλ > 0 ? 1 : -1,
                            λi = inflection[0] * d3_degrees * s,
                            antimeridian = Math.abs(dλ) > 180;
                        if (antimeridian ^ (λi > s * λ_ && s * λ > λi)) {
                            varφi = inflection[1] * d3_degrees;
                            φi > φ1 && (φ1 = φi)
                        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (λi > s * λ_ && s * λ > λi)) {
                            varφi = -inflection[1] * d3_degrees;
                            φ0 > φi && (φ0 = φi)
                        }
                        elseφ0 > φ && (φ0 = φ),
                            φ > φ1 && (φ1 = φ);
                        antimeridian ? λ_ > λ ? angle(λ0, λ) > angle(λ0, λ1) && (λ1 = λ) : angle(λ, λ1) > angle(λ0, λ1) && (λ0 = λ) : λ1 >= λ0 ? (λ0 > λ && (λ0 = λ), λ > λ1 && (λ1 = λ)) : λ > λ_ ? angle(λ0, λ) > angle(λ0, λ1) && (λ1 = λ) : angle(λ, λ1) > angle(λ0, λ1) && (λ0 = λ)
                    } else point(λ, φ);
                    p0 = p,
                        λ_ = λ
                }

                function lineStart() {
                    bound.point = linePoint
                }

                function lineEnd() {
                    range[0] = λ0,
                        range[1] = λ1,
                        bound.point = point,
                        p0 = null
                }

                function ringPoint(λ, φ) {
                    if (p0) {
                        var dλ = λ - λ_;
                        dλSum += Math.abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ
                    }
                    elseλ__ = λ,
                        φ__ = φ;
                    d3_geo_area.point(λ, φ),
                        linePoint(λ, φ)
                }

                function ringStart() {
                    d3_geo_area.lineStart()
                }

                function ringEnd() {
                    ringPoint(λ__, φ__),
                        d3_geo_area.lineEnd(),
                        Math.abs(dλSum) > ε && (λ0 = -(λ1 = 180)),
                        range[0] = λ0,
                        range[1] = λ1,
                        p0 = null
                }

                function angle(λ0, λ1) {
                    return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1
                }

                function compareRanges(a, b) {
                    return a[0] - b[0]
                }

                function withinRange(x, range) {
                    return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x
                }
                var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range, bound = {
                    point: point,
                    lineStart: lineStart,
                    lineEnd: lineEnd,
                    polygonStart: function () {
                        bound.point = ringPoint,
                            bound.lineStart = ringStart,
                            bound.lineEnd = ringEnd,
                            dλSum = 0,
                            d3_geo_area.polygonStart()
                    },
                    polygonEnd: function () {
                        d3_geo_area.polygonEnd(),
                            bound.point = point,
                            bound.lineStart = lineStart,
                            bound.lineEnd = lineEnd,
                            0 > d3_geo_areaRingSum ? (λ0 = -(λ1 = 180), φ0 = -(φ1 = 90)) : dλSum > ε ? φ1 = 90 : -ε > dλSum && (φ0 = -90),
                            range[0] = λ0,
                            range[1] = λ1
                    }
                };
                return function (feature) {
                    φ1 = λ1 = -(λ0 = φ0 = 1 / 0),
                        ranges = [],
                        d3.geo.stream(feature, bound);
                    var n = ranges.length;
                    if (n) {
                        ranges.sort(compareRanges);
                        for (var b, i = 1,
                                a = ranges[0], merged = [a]; n > i; ++i) b = ranges[i],
                            withinRange(b[0], a) || withinRange(b[1], a) ? (angle(a[0], b[1]) > angle(a[0], a[1]) && (a[1] = b[1]), angle(b[0], a[1]) > angle(a[0], a[1]) && (a[0] = b[0])) : merged.push(a = b);
                        for (var dλ, b, best = -1 / 0,
                                n = merged.length - 1,
                                i = 0,
                                a = merged[n]; n >= i; a = b, ++i) b = merged[i],
                            (dλ = angle(a[1], b[0])) > best && (best = dλ, λ0 = b[0], λ1 = a[1])
                    }
                    return ranges = range = null,
                        1 / 0 === λ0 || 1 / 0 === φ0 ? [
                            [0 / 0, 0 / 0],
                            [0 / 0, 0 / 0]
                        ] : [
                            [λ0, φ0],
                            [λ1, φ1]
                        ]
                }
            }(),
            d3.geo.centroid = function (object) {
                d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0,
                    d3.geo.stream(object, d3_geo_centroid);
                var x = d3_geo_centroidX2,
                    y = d3_geo_centroidY2,
                    z = d3_geo_centroidZ2,
                    m = x * x + y * y + z * z;
                returnε2 > m && (x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1, ε > d3_geo_centroidW1 && (x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0), m = x * x + y * y + z * z, ε2 > m) ? [0 / 0, 0 / 0] : [Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees]
            };
        var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2, d3_geo_centroid = {
                sphere: d3_noop,
                point: d3_geo_centroidPoint,
                lineStart: d3_geo_centroidLineStart,
                lineEnd: d3_geo_centroidLineEnd,
                polygonStart: function () {
                    d3_geo_centroid.lineStart = d3_geo_centroidRingStart
                },
                polygonEnd: function () {
                    d3_geo_centroid.lineStart = d3_geo_centroidLineStart
                }
            },
            d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, d3_geo_clipAntimeridianPolygonContains),
            d3_geo_clipAntimeridianPoint = [-π, 0],
            d3_geo_clipViewMAX = 1e9;
        (d3.geo.conicEqualArea = function () {
            return d3_geo_conic(d3_geo_conicEqualArea)
        }).raw = d3_geo_conicEqualArea,
            d3.geo.albers = function () {
                return d3.geo.conicEqualArea().rotate([96, 0]).center([-.6, 38.7]).parallels([29.5, 45.5]).scale(1070)
            },
            d3.geo.albersUsa = function () {
                function albersUsa(coordinates) {
                    var x = coordinates[0],
                        y = coordinates[1];
                    return point = null,
                        lower48Point(x, y),
                        point || (alaskaPoint(x, y), point) || hawaiiPoint(x, y),
                        point
                }
                var point, lower48Point, alaskaPoint, hawaiiPoint, lower48 = d3.geo.albers(),
                    alaska = d3.geo.conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
                    hawaii = d3.geo.conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
                    pointStream = {
                        point: function (x, y) {
                            point = [x, y]
                        }
                    };
                return albersUsa.invert = function (coordinates) {
                        var k = lower48.scale(),
                            t = lower48.translate(),
                            x = (coordinates[0] - t[0]) / k,
                            y = (coordinates[1] - t[1]) / k;
                        return (y >= .12 && .234 > y && x >= -.425 && -.214 > x ? alaska : y >= .166 && .234 > y && x >= -.214 && -.115 > x ? hawaii : lower48).invert(coordinates)
                    },
                    albersUsa.stream = function (stream) {
                        var lower48Stream = lower48.stream(stream),
                            alaskaStream = alaska.stream(stream),
                            hawaiiStream = hawaii.stream(stream);
                        return {
                            point: function (x, y) {
                                lower48Stream.point(x, y),
                                    alaskaStream.point(x, y),
                                    hawaiiStream.point(x, y)
                            },
                            sphere: function () {
                                lower48Stream.sphere(),
                                    alaskaStream.sphere(),
                                    hawaiiStream.sphere()
                            },
                            lineStart: function () {
                                lower48Stream.lineStart(),
                                    alaskaStream.lineStart(),
                                    hawaiiStream.lineStart()
                            },
                            lineEnd: function () {
                                lower48Stream.lineEnd(),
                                    alaskaStream.lineEnd(),
                                    hawaiiStream.lineEnd()
                            },
                            polygonStart: function () {
                                lower48Stream.polygonStart(),
                                    alaskaStream.polygonStart(),
                                    hawaiiStream.polygonStart()
                            },
                            polygonEnd: function () {
                                lower48Stream.polygonEnd(),
                                    alaskaStream.polygonEnd(),
                                    hawaiiStream.polygonEnd()
                            }
                        }
                    },
                    albersUsa.precision = function (_) {
                        return arguments.length ? (lower48.precision(_), alaska.precision(_), hawaii.precision(_), albersUsa) : lower48.precision()
                    },
                    albersUsa.scale = function (_) {
                        return arguments.length ? (lower48.scale(_), alaska.scale(.35 * _), hawaii.scale(_), albersUsa.translate(lower48.translate())) : lower48.scale()
                    },
                    albersUsa.translate = function (_) {
                        if (!arguments.length) return lower48.translate();
                        var k = lower48.scale(),
                            x = +_[0],
                            y = +_[1];
                        return lower48Point = lower48.translate(_).clipExtent([
                                [x - .455 * k, y - .238 * k],
                                [x + .455 * k, y + .238 * k]
                            ]).stream(pointStream).point,
                            alaskaPoint = alaska.translate([x - .307 * k, y + .201 * k]).clipExtent([
                                [x - .425 * k + ε, y + .12 * k + ε],
                                [x - .214 * k - ε, y + .234 * k - ε]
                            ]).stream(pointStream).point,
                            hawaiiPoint = hawaii.translate([x - .205 * k, y + .212 * k]).clipExtent([
                                [x - .214 * k + ε, y + .166 * k + ε],
                                [x - .115 * k - ε, y + .234 * k - ε]
                            ]).stream(pointStream).point,
                            albersUsa
                    },
                    albersUsa.scale(1070)
            };
        var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1, d3_geo_pathArea = {
                point: d3_noop,
                lineStart: d3_noop,
                lineEnd: d3_noop,
                polygonStart: function () {
                    d3_geo_pathAreaPolygon = 0,
                        d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart
                },
                polygonEnd: function () {
                    d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop,
                        d3_geo_pathAreaSum += Math.abs(d3_geo_pathAreaPolygon / 2)
                }
            },
            d3_geo_pathBounds = {
                point: d3_geo_pathBoundsPoint,
                lineStart: d3_noop,
                lineEnd: d3_noop,
                polygonStart: d3_noop,
                polygonEnd: d3_noop
            },
            d3_geo_pathCentroid = {
                point: d3_geo_pathCentroidPoint,
                lineStart: d3_geo_pathCentroidLineStart,
                lineEnd: d3_geo_pathCentroidLineEnd,
                polygonStart: function () {
                    d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart
                },
                polygonEnd: function () {
                    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint,
                        d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart,
                        d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd
                }
            };
        d3.geo.path = function () {
                function path(object) {
                    return object && ("function" == typeof pointRadius && contextStream.pointRadius(+pointRadius.apply(this, arguments)), cacheStream && cacheStream.valid || (cacheStream = projectStream(contextStream)), d3.geo.stream(object, cacheStream)),
                        contextStream.result()
                }

                function reset() {
                    return cacheStream = null,
                        path
                }
                var projection, context, projectStream, contextStream, cacheStream, pointRadius = 4.5;
                return path.area = function (object) {
                        return d3_geo_pathAreaSum = 0,
                            d3.geo.stream(object, projectStream(d3_geo_pathArea)),
                            d3_geo_pathAreaSum
                    },
                    path.centroid = function (object) {
                        return d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0,
                            d3.geo.stream(object, projectStream(d3_geo_pathCentroid)),
                            d3_geo_centroidZ2 ? [d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2] : d3_geo_centroidZ1 ? [d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1] : d3_geo_centroidZ0 ? [d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0] : [0 / 0, 0 / 0]
                    },
                    path.bounds = function (object) {
                        return d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = 1 / 0),
                            d3.geo.stream(object, projectStream(d3_geo_pathBounds)), [
                                [d3_geo_pathBoundsX0, d3_geo_pathBoundsY0],
                                [d3_geo_pathBoundsX1, d3_geo_pathBoundsY1]
                            ]
                    },
                    path.projection = function (_) {
                        return arguments.length ? (projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity, reset()) : projection
                    },
                    path.context = function (_) {
                        return arguments.length ? (contextStream = null == (context = _) ? new d3_geo_pathBuffer : new d3_geo_pathContext(_), "function" != typeof pointRadius && contextStream.pointRadius(pointRadius), reset()) : context
                    },
                    path.pointRadius = function (_) {
                        return arguments.length ? (pointRadius = "function" == typeof _ ? _ : (contextStream.pointRadius(+_), +_), path) : pointRadius
                    },
                    path.projection(d3.geo.albersUsa()).context(null)
            },
            d3.geo.projection = d3_geo_projection,
            d3.geo.projectionMutator = d3_geo_projectionMutator,
            (d3.geo.equirectangular = function () {
                return d3_geo_projection(d3_geo_equirectangular)
            }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular,
            d3.geo.rotation = function (rotate) {
                function forward(coordinates) {
                    return coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians),
                        coordinates[0] *= d3_degrees,
                        coordinates[1] *= d3_degrees,
                        coordinates
                }
                return rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0),
                    forward.invert = function (coordinates) {
                        return coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians),
                            coordinates[0] *= d3_degrees,
                            coordinates[1] *= d3_degrees,
                            coordinates
                    },
                    forward
            },
            d3.geo.circle = function () {
                function circle() {
                    var center = "function" == typeof origin ? origin.apply(this, arguments) : origin,
                        rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert,
                        ring = [];
                    return interpolate(null, null, 1, {
                        point: function (x, y) {
                            ring.push(x = rotate(x, y)),
                                x[0] *= d3_degrees,
                                x[1] *= d3_degrees
                        }
                    }), {
                        type: "Polygon",
                        coordinates: [ring]
                    }
                }
                var angle, interpolate, origin = [0, 0],
                    precision = 6;
                return circle.origin = function (x) {
                        return arguments.length ? (origin = x, circle) : origin
                    },
                    circle.angle = function (x) {
                        return arguments.length ? (interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians), circle) : angle
                    },
                    circle.precision = function (_) {
                        return arguments.length ? (interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians), circle) : precision
                    },
                    circle.angle(90)
            },
            d3.geo.distance = function (a, b) {
                var t, Δλ = (b[0] - a[0]) * d3_radians,
                    φ0 = a[1] * d3_radians,
                    φ1 = b[1] * d3_radians,
                    sinΔλ = Math.sin(Δλ),
                    cosΔλ = Math.cos(Δλ),
                    sinφ0 = Math.sin(φ0),
                    cosφ0 = Math.cos(φ0),
                    sinφ1 = Math.sin(φ1),
                    cosφ1 = Math.cos(φ1);
                return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ)
            },
            d3.geo.graticule = function () {
                function graticule() {
                    return {
                        type: "MultiLineString",
                        coordinates: lines()
                    }
                }

                function lines() {
                    return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function (x) {
                        return Math.abs(x % DX) > ε
                    }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function (y) {
                        return Math.abs(y % DY) > ε
                    }).map(y))
                }
                var x1, x0, X1, X0, y1, y0, Y1, Y0, x, y, X, Y, dx = 10,
                    dy = dx,
                    DX = 90,
                    DY = 360,
                    precision = 2.5;
                return graticule.lines = function () {
                        return lines().map(function (coordinates) {
                            return {
                                type: "LineString",
                                coordinates: coordinates
                            }
                        })
                    },
                    graticule.outline = function () {
                        return {
                            type: "Polygon",
                            coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
                        }
                    },
                    graticule.extent = function (_) {
                        return arguments.length ? graticule.majorExtent(_).minorExtent(_) : graticule.minorExtent()
                    },
                    graticule.majorExtent = function (_) {
                        return arguments.length ? (X0 = +_[0][0], X1 = +_[1][0], Y0 = +_[0][1], Y1 = +_[1][1], X0 > X1 && (_ = X0, X0 = X1, X1 = _), Y0 > Y1 && (_ = Y0, Y0 = Y1, Y1 = _), graticule.precision(precision)) : [
                            [X0, Y0],
                            [X1, Y1]
                        ]
                    },
                    graticule.minorExtent = function (_) {
                        return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], x0 > x1 && (_ = x0, x0 = x1, x1 = _), y0 > y1 && (_ = y0, y0 = y1, y1 = _), graticule.precision(precision)) : [
                            [x0, y0],
                            [x1, y1]
                        ]
                    },
                    graticule.step = function (_) {
                        return arguments.length ? graticule.majorStep(_).minorStep(_) : graticule.minorStep()
                    },
                    graticule.majorStep = function (_) {
                        return arguments.length ? (DX = +_[0], DY = +_[1], graticule) : [DX, DY]
                    },
                    graticule.minorStep = function (_) {
                        return arguments.length ? (dx = +_[0], dy = +_[1], graticule) : [dx, dy]
                    },
                    graticule.precision = function (_) {
                        return arguments.length ? (precision = +_, x = d3_geo_graticuleX(y0, y1, 90), y = d3_geo_graticuleY(x0, x1, precision), X = d3_geo_graticuleX(Y0, Y1, 90), Y = d3_geo_graticuleY(X0, X1, precision), graticule) : precision
                    },
                    graticule.majorExtent([
                        [-180, -90 + ε],
                        [180, 90 - ε]
                    ]).minorExtent([
                        [-180, -80 - ε],
                        [180, 80 + ε]
                    ])
            },
            d3.geo.greatArc = function () {
                function greatArc() {
                    return {
                        type: "LineString",
                        coordinates: [source_ || source.apply(this, arguments), target_ || target.apply(this, arguments)]
                    }
                }
                var source_, target_, source = d3_source,
                    target = d3_target;
                return greatArc.distance = function () {
                        return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments))
                    },
                    greatArc.source = function (_) {
                        return arguments.length ? (source = _, source_ = "function" == typeof _ ? null : _, greatArc) : source
                    },
                    greatArc.target = function (_) {
                        return arguments.length ? (target = _, target_ = "function" == typeof _ ? null : _, greatArc) : target
                    },
                    greatArc.precision = function () {
                        return arguments.length ? greatArc : 0
                    },
                    greatArc
            },
            d3.geo.interpolate = function (source, target) {
                return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians)
            },
            d3.geo.length = function (object) {
                return d3_geo_lengthSum = 0,
                    d3.geo.stream(object, d3_geo_length),
                    d3_geo_lengthSum
            };
        var d3_geo_lengthSum, d3_geo_length = {
                sphere: d3_noop,
                point: d3_noop,
                lineStart: d3_geo_lengthLineStart,
                lineEnd: d3_noop,
                polygonStart: d3_noop,
                polygonEnd: d3_noop
            },
            d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function (cosλcosφ) {
                    return Math.sqrt(2 / (1 + cosλcosφ))
                },
                function (ρ) {
                    return 2 * Math.asin(ρ / 2)
                });
        (d3.geo.azimuthalEqualArea = function () {
            return d3_geo_projection(d3_geo_azimuthalEqualArea)
        }).raw = d3_geo_azimuthalEqualArea;
        var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function (cosλcosφ) {
                var c = Math.acos(cosλcosφ);
                return c && c / Math.sin(c)
            },
            d3_identity);
        (d3.geo.azimuthalEquidistant = function () {
            return d3_geo_projection(d3_geo_azimuthalEquidistant)
        }).raw = d3_geo_azimuthalEquidistant,
            (d3.geo.conicConformal = function () {
                return d3_geo_conic(d3_geo_conicConformal)
            }).raw = d3_geo_conicConformal,
            (d3.geo.conicEquidistant = function () {
                return d3_geo_conic(d3_geo_conicEquidistant)
            }).raw = d3_geo_conicEquidistant;
        var d3_geo_gnomonic = d3_geo_azimuthal(function (cosλcosφ) {
                return 1 / cosλcosφ
            },
            Math.atan);
        (d3.geo.gnomonic = function () {
            return d3_geo_projection(d3_geo_gnomonic)
        }).raw = d3_geo_gnomonic,
            d3_geo_mercator.invert = function (x, y) {
                return [x, 2 * Math.atan(Math.exp(y)) - π / 2]
            },
            (d3.geo.mercator = function () {
                return d3_geo_mercatorProjection(d3_geo_mercator)
            }).raw = d3_geo_mercator;
        var d3_geo_orthographic = d3_geo_azimuthal(function () {
                return 1
            },
            Math.asin);
        (d3.geo.orthographic = function () {
            return d3_geo_projection(d3_geo_orthographic)
        }).raw = d3_geo_orthographic;
        var d3_geo_stereographic = d3_geo_azimuthal(function (cosλcosφ) {
                return 1 / (1 + cosλcosφ)
            },
            function (ρ) {
                return 2 * Math.atan(ρ)
            });
        (d3.geo.stereographic = function () {
            return d3_geo_projection(d3_geo_stereographic)
        }).raw = d3_geo_stereographic,
            d3_geo_transverseMercator.invert = function (x, y) {
                return [Math.atan2(d3_sinh(x), Math.cos(y)), d3_asin(Math.sin(y) / d3_cosh(x))]
            },
            (d3.geo.transverseMercator = function () {
                return d3_geo_mercatorProjection(d3_geo_transverseMercator)
            }).raw = d3_geo_transverseMercator,
            d3.geom = {},
            d3.svg = {},
            d3.svg.line = function () {
                return d3_svg_line(d3_identity)
            };
        var d3_svg_lineInterpolators = d3.map({
            linear: d3_svg_lineLinear,
            "linear-closed": d3_svg_lineLinearClosed,
            step: d3_svg_lineStep,
            "step-before": d3_svg_lineStepBefore,
            "step-after": d3_svg_lineStepAfter,
            basis: d3_svg_lineBasis,
            "basis-open": d3_svg_lineBasisOpen,
            "basis-closed": d3_svg_lineBasisClosed,
            bundle: d3_svg_lineBundle,
            cardinal: d3_svg_lineCardinal,
            "cardinal-open": d3_svg_lineCardinalOpen,
            "cardinal-closed": d3_svg_lineCardinalClosed,
            monotone: d3_svg_lineMonotone
        });
        d3_svg_lineInterpolators.forEach(function (key, value) {
            value.key = key,
                value.closed = /-closed$/.test(key)
        });
        var d3_svg_lineBasisBezier1 = [0, 2 / 3, 1 / 3, 0],
            d3_svg_lineBasisBezier2 = [0, 1 / 3, 2 / 3, 0],
            d3_svg_lineBasisBezier3 = [0, 1 / 6, 2 / 3, 1 / 6];
        d3.geom.hull = function (vertices) {
                function hull(data) {
                    if (data.length < 3) return [];
                    var vertices, d, i, j, x1, y1, x2, y2, u, v, a, sp, fx = d3_functor(x),
                        fy = d3_functor(y),
                        n = data.length,
                        plen = n - 1,
                        points = [],
                        stack = [],
                        h = 0;
                    if (fx === d3_svg_lineX && y === d3_svg_lineY) vertices = data;
                    else
                        for (i = 0, vertices = []; n > i; ++i) vertices.push([+fx.call(this, d = data[i], i), +fy.call(this, d, i)]);
                    for (i = 1; n > i; ++i)(vertices[i][1] < vertices[h][1] || vertices[i][1] == vertices[h][1] && vertices[i][0] < vertices[h][0]) && (h = i);
                    for (i = 0; n > i; ++i) i !== h && (y1 = vertices[i][1] - vertices[h][1], x1 = vertices[i][0] - vertices[h][0], points.push({
                        angle: Math.atan2(y1, x1),
                        index: i
                    }));
                    for (points.sort(function (a, b) {
                            return a.angle - b.angle
                        }), a = points[0].angle, v = points[0].index, u = 0, i = 1; plen > i; ++i) {
                        if (j = points[i].index, a == points[i].angle) {
                            if (x1 = vertices[v][0] - vertices[h][0], y1 = vertices[v][1] - vertices[h][1], x2 = vertices[j][0] - vertices[h][0], y2 = vertices[j][1] - vertices[h][1], x1 * x1 + y1 * y1 >= x2 * x2 + y2 * y2) {
                                points[i].index = -1;
                                continue
                            }
                            points[u].index = -1
                        }
                        a = points[i].angle,
                            u = i,
                            v = j
                    }
                    for (stack.push(h), i = 0, j = 0; 2 > i; ++j) points[j].index > -1 && (stack.push(points[j].index), i++);
                    for (sp = stack.length; plen > j; ++j)
                        if (!(points[j].index < 0)) {
                            for (; !d3_geom_hullCCW(stack[sp - 2], stack[sp - 1], points[j].index, vertices);) --sp;
                            stack[sp++] = points[j].index
                        }
                    var poly = [];
                    for (i = sp - 1; i >= 0; --i) poly.push(data[stack[i]]);
                    return poly
                }
                var x = d3_svg_lineX,
                    y = d3_svg_lineY;
                return arguments.length ? hull(vertices) : (hull.x = function (_) {
                        return arguments.length ? (x = _, hull) : x
                    },
                    hull.y = function (_) {
                        return arguments.length ? (y = _, hull) : y
                    },
                    hull)
            },
            d3.geom.polygon = function (coordinates) {
                return d3_subclass(coordinates, d3_geom_polygonPrototype),
                    coordinates
            };
        var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
        d3_geom_polygonPrototype.area = function () {
                for (var a, i = -1,
                        n = this.length,
                        b = this[n - 1], area = 0; ++i < n;) a = b,
                    b = this[i],
                    area += a[1] * b[0] - a[0] * b[1];
                return .5 * area
            },
            d3_geom_polygonPrototype.centroid = function (k) {
                var a, c, i = -1,
                    n = this.length,
                    x = 0,
                    y = 0,
                    b = this[n - 1];
                for (arguments.length || (k = -1 / (6 * this.area())); ++i < n;) a = b,
                    b = this[i],
                    c = a[0] * b[1] - b[0] * a[1],
                    x += (a[0] + b[0]) * c,
                    y += (a[1] + b[1]) * c;
                return [x * k, y * k]
            },
            d3_geom_polygonPrototype.clip = function (subject) {
                for (var input, j, m, b, c, d, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), a = this[n - 1]; ++i < n;) {
                    for (input = subject.slice(), subject.length = 0, b = this[i], c = input[(m = input.length - closed) - 1], j = -1; ++j < m;) d = input[j],
                        d3_geom_polygonInside(d, a, b) ? (d3_geom_polygonInside(c, a, b) || subject.push(d3_geom_polygonIntersect(c, d, a, b)), subject.push(d)) : d3_geom_polygonInside(c, a, b) && subject.push(d3_geom_polygonIntersect(c, d, a, b)),
                        c = d;
                    closed && subject.push(subject[0]),
                        a = b
                }
                return subject
            },
            d3.geom.delaunay = function (vertices) {
                var edges = vertices.map(function () {
                        return []
                    }),
                    triangles = [];
                return d3_geom_voronoiTessellate(vertices,
                        function (e) {
                            edges[e.region.l.index].push(vertices[e.region.r.index])
                        }),
                    edges.forEach(function (edge, i) {
                        var v = vertices[i],
                            cx = v[0],
                            cy = v[1];
                        edge.forEach(function (v) {
                                v.angle = Math.atan2(v[0] - cx, v[1] - cy)
                            }),
                            edge.sort(function (a, b) {
                                return a.angle - b.angle
                            });
                        for (var j = 0,
                                m = edge.length - 1; m > j; j++) triangles.push([v, edge[j], edge[j + 1]])
                    }),
                    triangles
            },
            d3.geom.voronoi = function (points) {
                function voronoi(data) {
                    var points, d, i, polygons = data.map(function () {
                            return []
                        }),
                        fx = d3_functor(x),
                        fy = d3_functor(y),
                        n = data.length,
                        Z = 1e6;
                    if (fx === d3_svg_lineX && fy === d3_svg_lineY) points = data;
                    else
                        for (points = new Array(n), i = 0; n > i; ++i) points[i] = [+fx.call(this, d = data[i], i), +fy.call(this, d, i)];
                    if (d3_geom_voronoiTessellate(points,
                            function (e) {
                                var s1, s2, x1, x2, y1, y2;
                                1 === e.a && e.b >= 0 ? (s1 = e.ep.r, s2 = e.ep.l) : (s1 = e.ep.l, s2 = e.ep.r),
                                    1 === e.a ? (y1 = s1 ? s1.y : -Z, x1 = e.c - e.b * y1, y2 = s2 ? s2.y : Z, x2 = e.c - e.b * y2) : (x1 = s1 ? s1.x : -Z, y1 = e.c - e.a * x1, x2 = s2 ? s2.x : Z, y2 = e.c - e.a * x2);
                                var v1 = [x1, y1],
                                    v2 = [x2, y2];
                                polygons[e.region.l.index].push(v1, v2),
                                    polygons[e.region.r.index].push(v1, v2)
                            }), polygons = polygons.map(function (polygon, i) {
                            var cx = points[i][0],
                                cy = points[i][1],
                                angle = polygon.map(function (v) {
                                    return Math.atan2(v[0] - cx, v[1] - cy)
                                }),
                                order = d3.range(polygon.length).sort(function (a, b) {
                                    return angle[a] - angle[b]
                                });
                            return order.filter(function (d, i) {
                                return !i || angle[d] - angle[order[i - 1]] > ε
                            }).map(function (d) {
                                return polygon[d]
                            })
                        }), polygons.forEach(function (polygon, i) {
                            var n = polygon.length;
                            if (!n) return polygon.push([-Z, -Z], [-Z, Z], [Z, Z], [Z, -Z]);
                            if (!(n > 2)) {
                                var p0 = points[i],
                                    p1 = polygon[0],
                                    p2 = polygon[1],
                                    x0 = p0[0],
                                    y0 = p0[1],
                                    x1 = p1[0],
                                    y1 = p1[1],
                                    x2 = p2[0],
                                    y2 = p2[1],
                                    dx = Math.abs(x2 - x1),
                                    dy = y2 - y1;
                                if (Math.abs(dy) < ε) {
                                    var y = y1 > y0 ? -Z : Z;
                                    polygon.push([-Z, y], [Z, y])
                                } else if (ε > dx) {
                                    var x = x1 > x0 ? -Z : Z;
                                    polygon.push([x, -Z], [x, Z])
                                } else {
                                    var y = (x1 - x0) * (y2 - y1) > (x2 - x1) * (y1 - y0) ? Z : -Z,
                                        z = Math.abs(dy) - dx;
                                    Math.abs(z) < ε ? polygon.push([0 > dy ? y : -y, y]) : (z > 0 && (y *= -1), polygon.push([-Z, y], [Z, y]))
                                }
                            }
                        }), clipPolygon)
                        for (i = 0; n > i; ++i) clipPolygon.clip(polygons[i]);
                    for (i = 0; n > i; ++i) polygons[i].point = data[i];
                    return polygons
                }
                var x = d3_svg_lineX,
                    y = d3_svg_lineY,
                    clipPolygon = null;
                return arguments.length ? voronoi(points) : (voronoi.x = function (_) {
                        return arguments.length ? (x = _, voronoi) : x
                    },
                    voronoi.y = function (_) {
                        return arguments.length ? (y = _, voronoi) : y
                    },
                    voronoi.clipExtent = function (_) {
                        if (!arguments.length) return clipPolygon && [clipPolygon[0], clipPolygon[2]];
                        if (null == _) clipPolygon = null;
                        else {
                            var x1 = +_[0][0],
                                y1 = +_[0][1],
                                x2 = +_[1][0],
                                y2 = +_[1][1];
                            clipPolygon = d3.geom.polygon([
                                [x1, y1],
                                [x1, y2],
                                [x2, y2],
                                [x2, y1]
                            ])
                        }
                        return voronoi
                    },
                    voronoi.size = function (_) {
                        return arguments.length ? voronoi.clipExtent(_ && [
                            [0, 0], _
                        ]) : clipPolygon && clipPolygon[2]
                    },
                    voronoi.links = function (data) {
                        var points, d, i, graph = data.map(function () {
                                return []
                            }),
                            links = [],
                            fx = d3_functor(x),
                            fy = d3_functor(y),
                            n = data.length;
                        if (fx === d3_svg_lineX && fy === d3_svg_lineY) points = data;
                        else
                            for (points = new Array(n), i = 0; n > i; ++i) points[i] = [+fx.call(this, d = data[i], i), +fy.call(this, d, i)];
                        return d3_geom_voronoiTessellate(points,
                                function (e) {
                                    var l = e.region.l.index,
                                        r = e.region.r.index;
                                    graph[l][r] || (graph[l][r] = graph[r][l] = !0, links.push({
                                        source: data[l],
                                        target: data[r]
                                    }))
                                }),
                            links
                    },
                    voronoi.triangles = function (data) {
                        if (x === d3_svg_lineX && y === d3_svg_lineY) return d3.geom.delaunay(data);
                        for (var d, points = new Array(n), fx = d3_functor(x), fy = d3_functor(y), i = -1, n = data.length; ++i < n;)(points[i] = [+fx.call(this, d = data[i], i), +fy.call(this, d, i)]).data = d;
                        return d3.geom.delaunay(points).map(function (triangle) {
                            return triangle.map(function (point) {
                                return point.data
                            })
                        })
                    },
                    voronoi)
            };
        var d3_geom_voronoiOpposite = {
            l: "r",
            r: "l"
        };
        d3.geom.quadtree = function (points, x1, y1, x2, y2) {
                function quadtree(data) {
                    function insert(n, d, x, y, x1, y1, x2, y2) {
                        if (!isNaN(x) && !isNaN(y))
                            if (n.leaf) {
                                var nx = n.x,
                                    ny = n.y;
                                if (null != nx)
                                    if (Math.abs(nx - x) + Math.abs(ny - y) < .01) insertChild(n, d, x, y, x1, y1, x2, y2);
                                    else {
                                        var nPoint = n.point;
                                        n.x = n.y = n.point = null,
                                            insertChild(n, nPoint, nx, ny, x1, y1, x2, y2),
                                            insertChild(n, d, x, y, x1, y1, x2, y2)
                                    }
                                else n.x = x,
                                    n.y = y,
                                    n.point = d
                            } else insertChild(n, d, x, y, x1, y1, x2, y2)
                    }

                    function insertChild(n, d, x, y, x1, y1, x2, y2) {
                        var sx = .5 * (x1 + x2),
                            sy = .5 * (y1 + y2),
                            right = x >= sx,
                            bottom = y >= sy,
                            i = (bottom << 1) + right;
                        n.leaf = !1,
                            n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode()),
                            right ? x1 = sx : x2 = sx,
                            bottom ? y1 = sy : y2 = sy,
                            insert(n, d, x, y, x1, y1, x2, y2)
                    }
                    var d, xs, ys, i, n, x1_, y1_, x2_, y2_, fx = d3_functor(x),
                        fy = d3_functor(y);
                    if (null != x1) x1_ = x1,
                        y1_ = y1,
                        x2_ = x2,
                        y2_ = y2;
                    else if (x2_ = y2_ = -(x1_ = y1_ = 1 / 0), xs = [], ys = [], n = data.length, compat)
                        for (i = 0; n > i; ++i) d = data[i],
                            d.x < x1_ && (x1_ = d.x),
                            d.y < y1_ && (y1_ = d.y),
                            d.x > x2_ && (x2_ = d.x),
                            d.y > y2_ && (y2_ = d.y),
                            xs.push(d.x),
                            ys.push(d.y);
                    else
                        for (i = 0; n > i; ++i) {
                            var x_ = +fx(d = data[i], i),
                                y_ = +fy(d, i);
                            x1_ > x_ && (x1_ = x_),
                                y1_ > y_ && (y1_ = y_),
                                x_ > x2_ && (x2_ = x_),
                                y_ > y2_ && (y2_ = y_),
                                xs.push(x_),
                                ys.push(y_)
                        }
                    var dx = x2_ - x1_,
                        dy = y2_ - y1_;
                    dx > dy ? y2_ = y1_ + dx : x2_ = x1_ + dy;
                    var root = d3_geom_quadtreeNode();
                    if (root.add = function (d) {
                            insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_)
                        },
                        root.visit = function (f) {
                            d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_)
                        },
                        i = -1, null == x1) {
                        for (; ++i < n;) insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
                        --i
                    } else data.forEach(root.add);
                    return xs = ys = data = d = null,
                        root
                }
                var compat, x = d3_svg_lineX,
                    y = d3_svg_lineY;
                return (compat = arguments.length) ? (x = d3_geom_quadtreeCompatX, y = d3_geom_quadtreeCompatY, 3 === compat && (y2 = y1, x2 = x1, y1 = x1 = 0), quadtree(points)) : (quadtree.x = function (_) {
                        return arguments.length ? (x = _, quadtree) : x
                    },
                    quadtree.y = function (_) {
                        return arguments.length ? (y = _, quadtree) : y
                    },
                    quadtree.extent = function (_) {
                        return arguments.length ? (null == _ ? x1 = y1 = x2 = y2 = null : (x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], y2 = +_[1][1]), quadtree) : null == x1 ? null : [
                            [x1, y1],
                            [x2, y2]
                        ]
                    },
                    quadtree.size = function (_) {
                        return arguments.length ? (null == _ ? x1 = y1 = x2 = y2 = null : (x1 = y1 = 0, x2 = +_[0], y2 = +_[1]), quadtree) : null == x1 ? null : [x2 - x1, y2 - y1]
                    },
                    quadtree)
            },
            d3.interpolateRgb = d3_interpolateRgb,
            d3.interpolateObject = d3_interpolateObject,
            d3.interpolateNumber = d3_interpolateNumber,
            d3.interpolateString = d3_interpolateString;
        var d3_interpolate_number = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
        d3.interpolate = d3_interpolate,
            d3.interpolators = [function (a, b) {
                var t = typeof b;
                return ("string" === t ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_Color ? d3_interpolateRgb : "object" === t ? Array.isArray(b) ? d3_interpolateArray : d3_interpolateObject : d3_interpolateNumber)(a, b)
            }],
            d3.interpolateArray = d3_interpolateArray;
        var d3_ease_default = function () {
                return d3_identity
            },
            d3_ease = d3.map({
                linear: d3_ease_default,
                poly: d3_ease_poly,
                quad: function () {
                    return d3_ease_quad
                },
                cubic: function () {
                    return d3_ease_cubic
                },
                sin: function () {
                    return d3_ease_sin
                },
                exp: function () {
                    return d3_ease_exp
                },
                circle: function () {
                    return d3_ease_circle
                },
                elastic: d3_ease_elastic,
                back: d3_ease_back,
                bounce: function () {
                    return d3_ease_bounce
                }
            }),
            d3_ease_mode = d3.map({
                "in": d3_identity,
                out: d3_ease_reverse,
                "in-out": d3_ease_reflect,
                "out-in": function (f) {
                    return d3_ease_reflect(d3_ease_reverse(f))
                }
            });
        d3.ease = function (name) {
                var i = name.indexOf("-"),
                    t = i >= 0 ? name.substring(0, i) : name,
                    m = i >= 0 ? name.substring(i + 1) : "in";
                return t = d3_ease.get(t) || d3_ease_default,
                    m = d3_ease_mode.get(m) || d3_identity,
                    d3_ease_clamp(m(t.apply(null, Array.prototype.slice.call(arguments, 1))))
            },
            d3.interpolateHcl = d3_interpolateHcl,
            d3.interpolateHsl = d3_interpolateHsl,
            d3.interpolateLab = d3_interpolateLab,
            d3.interpolateRound = d3_interpolateRound,
            d3.transform = function (string) {
                var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
                return (d3.transform = function (string) {
                    if (null != string) {
                        g.setAttribute("transform", string);
                        var t = g.transform.baseVal.consolidate()
                    }
                    return new d3_transform(t ? t.matrix : d3_transformIdentity)
                })(string)
            },
            d3_transform.prototype.toString = function () {
                return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")"
            };
        var d3_transformIdentity = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: 0,
            f: 0
        };
        d3.interpolateTransform = d3_interpolateTransform,
            d3.layout = {},
            d3.layout.bundle = function () {
                return function (links) {
                    for (var paths = [], i = -1, n = links.length; ++i < n;) paths.push(d3_layout_bundlePath(links[i]));
                    return paths
                }
            },
            d3.layout.chord = function () {
                function relayout() {
                    var k, x, x0, i, j, subgroups = {},
                        groupSums = [],
                        groupIndex = d3.range(n),
                        subgroupIndex = [];
                    for (chords = [], groups = [], k = 0, i = -1; ++i < n;) {
                        for (x = 0, j = -1; ++j < n;) x += matrix[i][j];
                        groupSums.push(x),
                            subgroupIndex.push(d3.range(n)),
                            k += x
                    }
                    for (sortGroups && groupIndex.sort(function (a, b) {
                            return sortGroups(groupSums[a], groupSums[b])
                        }), sortSubgroups && subgroupIndex.forEach(function (d, i) {
                            d.sort(function (a, b) {
                                return sortSubgroups(matrix[i][a], matrix[i][b])
                            })
                        }), k = (2 * π - padding * n) / k, x = 0, i = -1; ++i < n;) {
                        for (x0 = x, j = -1; ++j < n;) {
                            var di = groupIndex[i],
                                dj = subgroupIndex[di][j],
                                v = matrix[di][dj],
                                a0 = x,
                                a1 = x += v * k;
                            subgroups[di + "-" + dj] = {
                                index: di,
                                subindex: dj,
                                startAngle: a0,
                                endAngle: a1,
                                value: v
                            }
                        }
                        groups[di] = {
                                index: di,
                                startAngle: x0,
                                endAngle: x,
                                value: (x - x0) / k
                            },
                            x += padding
                    }
                    for (i = -1; ++i < n;)
                        for (j = i - 1; ++j < n;) {
                            var source = subgroups[i + "-" + j],
                                target = subgroups[j + "-" + i];
                            (source.value || target.value) && chords.push(source.value < target.value ? {
                                source: target,
                                target: source
                            } : {
                                source: source,
                                target: target
                            })
                        }
                    sortChords && resort()
                }

                function resort() {
                    chords.sort(function (a, b) {
                        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2)
                    })
                }
                var chords, groups, matrix, n, sortGroups, sortSubgroups, sortChords, chord = {},
                    padding = 0;
                return chord.matrix = function (x) {
                        return arguments.length ? (n = (matrix = x) && matrix.length, chords = groups = null, chord) : matrix
                    },
                    chord.padding = function (x) {
                        return arguments.length ? (padding = x, chords = groups = null, chord) : padding
                    },
                    chord.sortGroups = function (x) {
                        return arguments.length ? (sortGroups = x, chords = groups = null, chord) : sortGroups
                    },
                    chord.sortSubgroups = function (x) {
                        return arguments.length ? (sortSubgroups = x, chords = null, chord) : sortSubgroups
                    },
                    chord.sortChords = function (x) {
                        return arguments.length ? (sortChords = x, chords && resort(), chord) : sortChords
                    },
                    chord.chords = function () {
                        return chords || relayout(),
                            chords
                    },
                    chord.groups = function () {
                        return groups || relayout(),
                            groups
                    },
                    chord
            },
            d3.layout.force = function () {
                function repulse(node) {
                    return function (quad, x1, _, x2) {
                        if (quad.point !== node) {
                            var dx = quad.cx - node.x,
                                dy = quad.cy - node.y,
                                dn = 1 / Math.sqrt(dx * dx + dy * dy);
                            if (theta > (x2 - x1) * dn) {
                                var k = quad.charge * dn * dn;
                                return node.px -= dx * k,
                                    node.py -= dy * k, !0
                            }
                            if (quad.point && isFinite(dn)) {
                                var k = quad.pointCharge * dn * dn;
                                node.px -= dx * k,
                                    node.py -= dy * k
                            }
                        }
                        return !quad.charge
                    }
                }

                function dragmove(d) {
                    d.px = d3.event.x,
                        d.py = d3.event.y,
                        force.resume()
                }
                var drag, alpha, distances, strengths, charges, force = {},
                    event = d3.dispatch("start", "tick", "end"),
                    size = [1, 1],
                    friction = .9,
                    linkDistance = d3_layout_forceLinkDistance,
                    linkStrength = d3_layout_forceLinkStrength,
                    charge = -30,
                    gravity = .1,
                    theta = .1,
                    nodes = [],
                    links = [];
                return force.tick = function () {
                        if ((alpha *= .99) < .005) return event.end({
                            type: "end",
                            alpha: alpha = 0
                        }), !0;
                        var q, i, o, s, t, l, k, x, y, n = nodes.length,
                            m = links.length;
                        for (i = 0; m > i; ++i) o = links[i],
                            s = o.source,
                            t = o.target,
                            x = t.x - s.x,
                            y = t.y - s.y,
                            (l = x * x + y * y) && (l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l, x *= l, y *= l, t.x -= x * (k = s.weight / (t.weight + s.weight)), t.y -= y * k, s.x += x * (k = 1 - k), s.y += y * k);
                        if ((k = alpha * gravity) && (x = size[0] / 2, y = size[1] / 2, i = -1, k))
                            for (; ++i < n;) o = nodes[i],
                                o.x += (x - o.x) * k,
                                o.y += (y - o.y) * k;
                        if (charge)
                            for (d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges), i = -1; ++i < n;)(o = nodes[i]).fixed || q.visit(repulse(o));
                        for (i = -1; ++i < n;) o = nodes[i],
                            o.fixed ? (o.x = o.px, o.y = o.py) : (o.x -= (o.px - (o.px = o.x)) * friction, o.y -= (o.py - (o.py = o.y)) * friction);
                        event.tick({
                            type: "tick",
                            alpha: alpha
                        })
                    },
                    force.nodes = function (x) {
                        return arguments.length ? (nodes = x, force) : nodes
                    },
                    force.links = function (x) {
                        return arguments.length ? (links = x, force) : links
                    },
                    force.size = function (x) {
                        return arguments.length ? (size = x, force) : size
                    },
                    force.linkDistance = function (x) {
                        return arguments.length ? (linkDistance = "function" == typeof x ? x : +x, force) : linkDistance
                    },
                    force.distance = force.linkDistance,
                    force.linkStrength = function (x) {
                        return arguments.length ? (linkStrength = "function" == typeof x ? x : +x, force) : linkStrength
                    },
                    force.friction = function (x) {
                        return arguments.length ? (friction = +x, force) : friction
                    },
                    force.charge = function (x) {
                        return arguments.length ? (charge = "function" == typeof x ? x : +x, force) : charge
                    },
                    force.gravity = function (x) {
                        return arguments.length ? (gravity = +x, force) : gravity
                    },
                    force.theta = function (x) {
                        return arguments.length ? (theta = +x, force) : theta
                    },
                    force.alpha = function (x) {
                        return arguments.length ? (x = +x, alpha ? alpha = x > 0 ? x : 0 : x > 0 && (event.start({
                            type: "start",
                            alpha: alpha = x
                        }), d3.timer(force.tick)), force) : alpha
                    },
                    force.start = function () {
                        function position(dimension, size) {
                            for (var x, neighbors = neighbor(i), j = -1, m = neighbors.length; ++j < m;)
                                if (!isNaN(x = neighbors[j][dimension])) return x;
                            return Math.random() * size
                        }

                        function neighbor() {
                            if (!neighbors) {
                                for (neighbors = [], j = 0; n > j; ++j) neighbors[j] = [];
                                for (j = 0; m > j; ++j) {
                                    var o = links[j];
                                    neighbors[o.source.index].push(o.target),
                                        neighbors[o.target.index].push(o.source)
                                }
                            }
                            return neighbors[i]
                        }
                        var i, j, neighbors, o, n = nodes.length,
                            m = links.length,
                            w = size[0],
                            h = size[1];
                        for (i = 0; n > i; ++i)(o = nodes[i]).index = i,
                            o.weight = 0;
                        for (i = 0; m > i; ++i) o = links[i],
                            "number" == typeof o.source && (o.source = nodes[o.source]),
                            "number" == typeof o.target && (o.target = nodes[o.target]),
                            ++o.source.weight,
                            ++o.target.weight;
                        for (i = 0; n > i; ++i) o = nodes[i],
                            isNaN(o.x) && (o.x = position("x", w)),
                            isNaN(o.y) && (o.y = position("y", h)),
                            isNaN(o.px) && (o.px = o.x),
                            isNaN(o.py) && (o.py = o.y);
                        if (distances = [], "function" == typeof linkDistance)
                            for (i = 0; m > i; ++i) distances[i] = +linkDistance.call(this, links[i], i);
                        else
                            for (i = 0; m > i; ++i) distances[i] = linkDistance;
                        if (strengths = [], "function" == typeof linkStrength)
                            for (i = 0; m > i; ++i) strengths[i] = +linkStrength.call(this, links[i], i);
                        else
                            for (i = 0; m > i; ++i) strengths[i] = linkStrength;
                        if (charges = [], "function" == typeof charge)
                            for (i = 0; n > i; ++i) charges[i] = +charge.call(this, nodes[i], i);
                        else
                            for (i = 0; n > i; ++i) charges[i] = charge;
                        return force.resume()
                    },
                    force.resume = function () {
                        return force.alpha(.1)
                    },
                    force.stop = function () {
                        return force.alpha(0)
                    },
                    force.drag = function () {
                        return drag || (drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend)),
                            arguments.length ? void this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag) : drag
                    },
                    d3.rebind(force, event, "on")
            };
        var d3_layout_forceLinkDistance = 20,
            d3_layout_forceLinkStrength = 1;
        d3.layout.hierarchy = function () {
                function recurse(node, depth, nodes) {
                    var childs = children.call(hierarchy, node, depth);
                    if (node.depth = depth, nodes.push(node), childs && (n = childs.length)) {
                        for (var n, d, i = -1,
                                c = node.children = [], v = 0, j = depth + 1; ++i < n;) d = recurse(childs[i], j, nodes),
                            d.parent = node,
                            c.push(d),
                            v += d.value;
                        sort && c.sort(sort),
                            value && (node.value = v)
                    } else value && (node.value = +value.call(hierarchy, node, depth) || 0);
                    return node
                }

                function revalue(node, depth) {
                    var children = node.children,
                        v = 0;
                    if (children && (n = children.length))
                        for (var n, i = -1,
                                j = depth + 1; ++i < n;) v += revalue(children[i], j);
                    else value && (v = +value.call(hierarchy, node, depth) || 0);
                    return value && (node.value = v),
                        v
                }

                function hierarchy(d) {
                    var nodes = [];
                    return recurse(d, 0, nodes),
                        nodes
                }
                var sort = d3_layout_hierarchySort,
                    children = d3_layout_hierarchyChildren,
                    value = d3_layout_hierarchyValue;
                return hierarchy.sort = function (x) {
                        return arguments.length ? (sort = x, hierarchy) : sort
                    },
                    hierarchy.children = function (x) {
                        return arguments.length ? (children = x, hierarchy) : children
                    },
                    hierarchy.value = function (x) {
                        return arguments.length ? (value = x, hierarchy) : value
                    },
                    hierarchy.revalue = function (root) {
                        return revalue(root, 0),
                            root
                    },
                    hierarchy
            },
            d3.layout.partition = function () {
                function position(node, x, dx, dy) {
                    var children = node.children;
                    if (node.x = x, node.y = node.depth * dy, node.dx = dx, node.dy = dy, children && (n = children.length)) {
                        var n, c, d, i = -1;
                        for (dx = node.value ? dx / node.value : 0; ++i < n;) position(c = children[i], x, d = c.value * dx, dy),
                            x += d
                    }
                }

                function depth(node) {
                    var children = node.children,
                        d = 0;
                    if (children && (n = children.length))
                        for (var n, i = -1; ++i < n;) d = Math.max(d, depth(children[i]));
                    return 1 + d
                }

                function partition(d, i) {
                    var nodes = hierarchy.call(this, d, i);
                    return position(nodes[0], 0, size[0], size[1] / depth(nodes[0])),
                        nodes
                }
                var hierarchy = d3.layout.hierarchy(),
                    size = [1, 1];
                return partition.size = function (x) {
                        return arguments.length ? (size = x, partition) : size
                    },
                    d3_layout_hierarchyRebind(partition, hierarchy)
            },
            d3.layout.pie = function () {
                function pie(data) {
                    var values = data.map(function (d, i) {
                            return +value.call(pie, d, i)
                        }),
                        a = +("function" == typeof startAngle ? startAngle.apply(this, arguments) : startAngle),
                        k = (("function" == typeof endAngle ? endAngle.apply(this, arguments) : endAngle) - a) / d3.sum(values),
                        index = d3.range(data.length);
                    null != sort && index.sort(sort === d3_layout_pieSortByValue ?
                        function (i, j) {
                            return values[j] - values[i]
                        } : function (i, j) {
                            return sort(data[i], data[j])
                        });
                    var arcs = [];
                    return index.forEach(function (i) {
                            var d;
                            arcs[i] = {
                                data: data[i],
                                value: d = values[i],
                                startAngle: a,
                                endAngle: a += d * k
                            }
                        }),
                        arcs
                }
                var value = Number,
                    sort = d3_layout_pieSortByValue,
                    startAngle = 0,
                    endAngle = 2 * π;
                return pie.value = function (x) {
                        return arguments.length ? (value = x, pie) : value
                    },
                    pie.sort = function (x) {
                        return arguments.length ? (sort = x, pie) : sort
                    },
                    pie.startAngle = function (x) {
                        return arguments.length ? (startAngle = x, pie) : startAngle
                    },
                    pie.endAngle = function (x) {
                        return arguments.length ? (endAngle = x, pie) : endAngle
                    },
                    pie
            };
        var d3_layout_pieSortByValue = {};
        d3.layout.stack = function () {
            function stack(data, index) {
                var series = data.map(function (d, i) {
                        return values.call(stack, d, i)
                    }),
                    points = series.map(function (d) {
                        return d.map(function (v, i) {
                            return [x.call(stack, v, i), y.call(stack, v, i)]
                        })
                    }),
                    orders = order.call(stack, points, index);
                series = d3.permute(series, orders),
                    points = d3.permute(points, orders);
                var i, j, o, offsets = offset.call(stack, points, index),
                    n = series.length,
                    m = series[0].length;
                for (j = 0; m > j; ++j)
                    for (out.call(stack, series[0][j], o = offsets[j], points[0][j][1]), i = 1; n > i; ++i) out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
                return data
            }
            var values = d3_identity,
                order = d3_layout_stackOrderDefault,
                offset = d3_layout_stackOffsetZero,
                out = d3_layout_stackOut,
                x = d3_layout_stackX,
                y = d3_layout_stackY;
            return stack.values = function (x) {
                    return arguments.length ? (values = x, stack) : values
                },
                stack.order = function (x) {
                    return arguments.length ? (order = "function" == typeof x ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault, stack) : order
                },
                stack.offset = function (x) {
                    return arguments.length ? (offset = "function" == typeof x ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero, stack) : offset
                },
                stack.x = function (z) {
                    return arguments.length ? (x = z, stack) : x
                },
                stack.y = function (z) {
                    return arguments.length ? (y = z, stack) : y
                },
                stack.out = function (z) {
                    return arguments.length ? (out = z, stack) : out
                },
                stack
        };
        var d3_layout_stackOrders = d3.map({
                "inside-out": function (data) {
                    var i, j, n = data.length,
                        max = data.map(d3_layout_stackMaxIndex),
                        sums = data.map(d3_layout_stackReduceSum),
                        index = d3.range(n).sort(function (a, b) {
                            return max[a] - max[b]
                        }),
                        top = 0,
                        bottom = 0,
                        tops = [],
                        bottoms = [];
                    for (i = 0; n > i; ++i) j = index[i],
                        bottom > top ? (top += sums[j], tops.push(j)) : (bottom += sums[j], bottoms.push(j));
                    return bottoms.reverse().concat(tops)
                },
                reverse: function (data) {
                    return d3.range(data.length).reverse()
                },
                "default": d3_layout_stackOrderDefault
            }),
            d3_layout_stackOffsets = d3.map({
                silhouette: function (data) {
                    var i, j, o, n = data.length,
                        m = data[0].length,
                        sums = [],
                        max = 0,
                        y0 = [];
                    for (j = 0; m > j; ++j) {
                        for (i = 0, o = 0; n > i; i++) o += data[i][j][1];
                        o > max && (max = o),
                            sums.push(o)
                    }
                    for (j = 0; m > j; ++j) y0[j] = (max - sums[j]) / 2;
                    return y0
                },
                wiggle: function (data) {
                    var i, j, k, s1, s2, s3, dx, o, o0, n = data.length,
                        x = data[0],
                        m = x.length,
                        y0 = [];
                    for (y0[0] = o = o0 = 0, j = 1; m > j; ++j) {
                        for (i = 0, s1 = 0; n > i; ++i) s1 += data[i][j][1];
                        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; n > i; ++i) {
                            for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); i > k; ++k) s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
                            s2 += s3 * data[i][j][1]
                        }
                        y0[j] = o -= s1 ? s2 / s1 * dx : 0,
                            o0 > o && (o0 = o)
                    }
                    for (j = 0; m > j; ++j) y0[j] -= o0;
                    return y0
                },
                expand: function (data) {
                    var i, j, o, n = data.length,
                        m = data[0].length,
                        k = 1 / n,
                        y0 = [];
                    for (j = 0; m > j; ++j) {
                        for (i = 0, o = 0; n > i; i++) o += data[i][j][1];
                        if (o)
                            for (i = 0; n > i; i++) data[i][j][1] /= o;
                        else
                            for (i = 0; n > i; i++) data[i][j][1] = k
                    }
                    for (j = 0; m > j; ++j) y0[j] = 0;
                    return y0
                },
                zero: d3_layout_stackOffsetZero
            });
        d3.layout.histogram = function () {
                function histogram(data, i) {
                    for (var bin, x, bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n; ++i < m;) bin = bins[i] = [],
                        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]),
                        bin.y = 0;
                    if (m > 0)
                        for (i = -1; ++i < n;) x = values[i],
                            x >= range[0] && x <= range[1] && (bin = bins[d3.bisect(thresholds, x, 1, m) - 1], bin.y += k, bin.push(data[i]));
                    return bins
                }
                var frequency = !0,
                    valuer = Number,
                    ranger = d3_layout_histogramRange,
                    binner = d3_layout_histogramBinSturges;
                return histogram.value = function (x) {
                        return arguments.length ? (valuer = x, histogram) : valuer
                    },
                    histogram.range = function (x) {
                        return arguments.length ? (ranger = d3_functor(x), histogram) : ranger
                    },
                    histogram.bins = function (x) {
                        return arguments.length ? (binner = "number" == typeof x ?
                            function (range) {
                                return d3_layout_histogramBinFixed(range, x)
                            } : d3_functor(x), histogram) : binner
                    },
                    histogram.frequency = function (x) {
                        return arguments.length ? (frequency = !!x, histogram) : frequency
                    },
                    histogram
            },
            d3.layout.tree = function () {
                function tree(d, i) {
                    function firstWalk(node, previousSibling) {
                        var children = node.children,
                            layout = node._tree;
                        if (children && (n = children.length)) {
                            for (var n, previousChild, child, firstChild = children[0], ancestor = firstChild, i = -1; ++i < n;) child = children[i],
                                firstWalk(child, previousChild),
                                ancestor = apportion(child, previousChild, ancestor),
                                previousChild = child;
                            d3_layout_treeShift(node);
                            var midpoint = .5 * (firstChild._tree.prelim + child._tree.prelim);
                            previousSibling ? (layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling), layout.mod = layout.prelim - midpoint) : layout.prelim = midpoint
                        } else previousSibling && (layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling))
                    }

                    function secondWalk(node, x) {
                        node.x = node._tree.prelim + x;
                        var children = node.children;
                        if (children && (n = children.length)) {
                            var n, i = -1;
                            for (x += node._tree.mod; ++i < n;) secondWalk(children[i], x)
                        }
                    }

                    function apportion(node, previousSibling, ancestor) {
                        if (previousSibling) {
                            for (var shift, vip = node,
                                    vop = node,
                                    vim = previousSibling,
                                    vom = node.parent.children[0], sip = vip._tree.mod, sop = vop._tree.mod, sim = vim._tree.mod, som = vom._tree.mod; vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip;) vom = d3_layout_treeLeft(vom),
                                vop = d3_layout_treeRight(vop),
                                vop._tree.ancestor = node,
                                shift = vim._tree.prelim + sim - vip._tree.prelim - sip + separation(vim, vip),
                                shift > 0 && (d3_layout_treeMove(d3_layout_treeAncestor(vim, node, ancestor), node, shift), sip += shift, sop += shift),
                                sim += vim._tree.mod,
                                sip += vip._tree.mod,
                                som += vom._tree.mod,
                                sop += vop._tree.mod;
                            vim && !d3_layout_treeRight(vop) && (vop._tree.thread = vim, vop._tree.mod += sim - sop),
                                vip && !d3_layout_treeLeft(vom) && (vom._tree.thread = vip, vom._tree.mod += sip - som, ancestor = node)
                        }
                        return ancestor
                    }
                    var nodes = hierarchy.call(this, d, i),
                        root = nodes[0];
                    d3_layout_treeVisitAfter(root,
                            function (node, previousSibling) {
                                node._tree = {
                                    ancestor: node,
                                    prelim: 0,
                                    mod: 0,
                                    change: 0,
                                    shift: 0,
                                    number: previousSibling ? previousSibling._tree.number + 1 : 0
                                }
                            }),
                        firstWalk(root),
                        secondWalk(root, -root._tree.prelim);
                    var left = d3_layout_treeSearch(root, d3_layout_treeLeftmost),
                        right = d3_layout_treeSearch(root, d3_layout_treeRightmost),
                        deep = d3_layout_treeSearch(root, d3_layout_treeDeepest),
                        x0 = left.x - separation(left, right) / 2,
                        x1 = right.x + separation(right, left) / 2,
                        y1 = deep.depth || 1;
                    return d3_layout_treeVisitAfter(root, nodeSize ?
                            function (node) {
                                node.x *= size[0],
                                    node.y = node.depth * size[1],
                                    delete node._tree
                            } : function (node) {
                                node.x = (node.x - x0) / (x1 - x0) * size[0],
                                    node.y = node.depth / y1 * size[1],
                                    delete node._tree
                            }),
                        nodes
                }
                var hierarchy = d3.layout.hierarchy().sort(null).value(null),
                    separation = d3_layout_treeSeparation,
                    size = [1, 1],
                    nodeSize = !1;
                return tree.separation = function (x) {
                        return arguments.length ? (separation = x, tree) : separation
                    },
                    tree.size = function (x) {
                        return arguments.length ? (nodeSize = null == (size = x), tree) : nodeSize ? null : size
                    },
                    tree.nodeSize = function (x) {
                        return arguments.length ? (nodeSize = null != (size = x), tree) : nodeSize ? size : null
                    },
                    d3_layout_hierarchyRebind(tree, hierarchy)
            },
            d3.layout.pack = function () {
                function pack(d, i) {
                    var nodes = hierarchy.call(this, d, i),
                        root = nodes[0],
                        w = size[0],
                        h = size[1],
                        r = null == radius ? Math.sqrt : "function" == typeof radius ? radius : function () {
                            return radius
                        };
                    if (root.x = root.y = 0, d3_layout_treeVisitAfter(root,
                            function (d) {
                                d.r = +r(d.value)
                            }), d3_layout_treeVisitAfter(root, d3_layout_packSiblings), padding) {
                        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
                        d3_layout_treeVisitAfter(root,
                                function (d) {
                                    d.r += dr
                                }),
                            d3_layout_treeVisitAfter(root, d3_layout_packSiblings),
                            d3_layout_treeVisitAfter(root,
                                function (d) {
                                    d.r -= dr
                                })
                    }
                    return d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h)),
                        nodes
                }
                var radius, hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort),
                    padding = 0,
                    size = [1, 1];
                return pack.size = function (_) {
                        return arguments.length ? (size = _, pack) : size
                    },
                    pack.radius = function (_) {
                        return arguments.length ? (radius = null == _ || "function" == typeof _ ? _ : +_, pack) : radius
                    },
                    pack.padding = function (_) {
                        return arguments.length ? (padding = +_, pack) : padding
                    },
                    d3_layout_hierarchyRebind(pack, hierarchy)
            },
            d3.layout.cluster = function () {
                function cluster(d, i) {
                    var previousNode, nodes = hierarchy.call(this, d, i),
                        root = nodes[0],
                        x = 0;
                    d3_layout_treeVisitAfter(root,
                        function (node) {
                            var children = node.children;
                            children && children.length ? (node.x = d3_layout_clusterX(children), node.y = d3_layout_clusterY(children)) : (node.x = previousNode ? x += separation(node, previousNode) : 0, node.y = 0, previousNode = node)
                        });
                    var left = d3_layout_clusterLeft(root),
                        right = d3_layout_clusterRight(root),
                        x0 = left.x - separation(left, right) / 2,
                        x1 = right.x + separation(right, left) / 2;
                    return d3_layout_treeVisitAfter(root, nodeSize ?
                            function (node) {
                                node.x = (node.x - root.x) * size[0],
                                    node.y = (root.y - node.y) * size[1]
                            } : function (node) {
                                node.x = (node.x - x0) / (x1 - x0) * size[0],
                                    node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1]
                            }),
                        nodes
                }
                var hierarchy = d3.layout.hierarchy().sort(null).value(null),
                    separation = d3_layout_treeSeparation,
                    size = [1, 1],
                    nodeSize = !1;
                return cluster.separation = function (x) {
                        return arguments.length ? (separation = x, cluster) : separation
                    },
                    cluster.size = function (x) {
                        return arguments.length ? (nodeSize = null == (size = x), cluster) : nodeSize ? null : size
                    },
                    cluster.nodeSize = function (x) {
                        return arguments.length ? (nodeSize = null != (size = x), cluster) : nodeSize ? size : null
                    },
                    d3_layout_hierarchyRebind(cluster, hierarchy)
            },
            d3.layout.treemap = function () {
                function scale(children, k) {
                    for (var child, area, i = -1,
                            n = children.length; ++i < n;) area = (child = children[i]).value * (0 > k ? 0 : k),
                        child.area = isNaN(area) || 0 >= area ? 0 : area
                }

                function squarify(node) {
                    var children = node.children;
                    if (children && children.length) {
                        var child, score, n, rect = pad(node),
                            row = [],
                            remaining = children.slice(),
                            best = 1 / 0,
                            u = "slice" === mode ? rect.dx : "dice" === mode ? rect.dy : "slice-dice" === mode ? 1 & node.depth ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy);
                        for (scale(remaining, rect.dx * rect.dy / node.value), row.area = 0;
                            (n = remaining.length) > 0;) row.push(child = remaining[n - 1]),
                            row.area += child.area,
                            "squarify" !== mode || (score = worst(row, u)) <= best ? (remaining.pop(), best = score) : (row.area -= row.pop().area, position(row, u, rect, !1), u = Math.min(rect.dx, rect.dy), row.length = row.area = 0, best = 1 / 0);
                        row.length && (position(row, u, rect, !0), row.length = row.area = 0),
                            children.forEach(squarify)
                    }
                }

                function stickify(node) {
                    var children = node.children;
                    if (children && children.length) {
                        var child, rect = pad(node),
                            remaining = children.slice(),
                            row = [];
                        for (scale(remaining, rect.dx * rect.dy / node.value), row.area = 0; child = remaining.pop();) row.push(child),
                            row.area += child.area,
                            null != child.z && (position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length), row.length = row.area = 0);
                        children.forEach(stickify)
                    }
                }

                function worst(row, u) {
                    for (var r, s = row.area,
                            rmax = 0,
                            rmin = 1 / 0,
                            i = -1,
                            n = row.length; ++i < n;)(r = row[i].area) && (rmin > r && (rmin = r), r > rmax && (rmax = r));
                    return s *= s,
                        u *= u,
                        s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : 1 / 0
                }

                function position(row, u, rect, flush) {
                    var o, i = -1,
                        n = row.length,
                        x = rect.x,
                        y = rect.y,
                        v = u ? round(row.area / u) : 0;
                    if (u == rect.dx) {
                        for ((flush || v > rect.dy) && (v = rect.dy); ++i < n;) o = row[i],
                            o.x = x,
                            o.y = y,
                            o.dy = v,
                            x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
                        o.z = !0,
                            o.dx += rect.x + rect.dx - x,
                            rect.y += v,
                            rect.dy -= v
                    } else {
                        for ((flush || v > rect.dx) && (v = rect.dx); ++i < n;) o = row[i],
                            o.x = x,
                            o.y = y,
                            o.dx = v,
                            y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
                        o.z = !1,
                            o.dy += rect.y + rect.dy - y,
                            rect.x += v,
                            rect.dx -= v
                    }
                }

                function treemap(d) {
                    var nodes = stickies || hierarchy(d),
                        root = nodes[0];
                    return root.x = 0,
                        root.y = 0,
                        root.dx = size[0],
                        root.dy = size[1],
                        stickies && hierarchy.revalue(root),
                        scale([root], root.dx * root.dy / root.value),
                        (stickies ? stickify : squarify)(root),
                        sticky && (stickies = nodes),
                        nodes
                }
                var stickies, hierarchy = d3.layout.hierarchy(),
                    round = Math.round,
                    size = [1, 1],
                    padding = null,
                    pad = d3_layout_treemapPadNull,
                    sticky = !1,
                    mode = "squarify",
                    ratio = .5 * (1 + Math.sqrt(5));
                return treemap.size = function (x) {
                        return arguments.length ? (size = x, treemap) : size
                    },
                    treemap.padding = function (x) {
                        function padFunction(node) {
                            var p = x.call(treemap, node, node.depth);
                            return null == p ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, "number" == typeof p ? [p, p, p, p] : p)
                        }

                        function padConstant(node) {
                            return d3_layout_treemapPad(node, x)
                        }
                        if (!arguments.length) return padding;
                        var type;
                        return pad = null == (padding = x) ? d3_layout_treemapPadNull : "function" == (type = typeof x) ? padFunction : "number" === type ? (x = [x, x, x, x], padConstant) : padConstant,
                            treemap
                    },
                    treemap.round = function (x) {
                        return arguments.length ? (round = x ? Math.round : Number, treemap) : round != Number
                    },
                    treemap.sticky = function (x) {
                        return arguments.length ? (sticky = x, stickies = null, treemap) : sticky
                    },
                    treemap.ratio = function (x) {
                        return arguments.length ? (ratio = x, treemap) : ratio
                    },
                    treemap.mode = function (x) {
                        return arguments.length ? (mode = x + "", treemap) : mode
                    },
                    d3_layout_hierarchyRebind(treemap, hierarchy)
            },
            d3.random = {
                normal: function (µ, σ) {
                    var n = arguments.length;
                    return 2 > n && (σ = 1),
                        1 > n && (µ = 0),
                        function () {
                            var x, y, r;
                            do x = 2 * Math.random() - 1,
                                y = 2 * Math.random() - 1,
                                r = x * x + y * y;
                            while (!r || r > 1);
                            returnµ + σ * x * Math.sqrt(-2 * Math.log(r) / r)
                        }
                },
                logNormal: function () {
                    var random = d3.random.normal.apply(d3, arguments);
                    return function () {
                        return Math.exp(random())
                    }
                },
                irwinHall: function (m) {
                    return function () {
                        for (var s = 0,
                                j = 0; m > j; j++) s += Math.random();
                        return s / m
                    }
                }
            },
            d3.scale = {};
        var d3_scale_niceIdentity = {
            floor: d3_identity,
            ceil: d3_identity
        };
        d3.scale.linear = function () {
                return d3_scale_linear([0, 1], [0, 1], d3_interpolate, !1)
            },
            d3.scale.log = function () {
                return d3_scale_log(d3.scale.linear().domain([0, 1]), 10, !0, [1, 10])
            };
        var d3_scale_logFormat = d3.format(".0e"),
            d3_scale_logNiceNegative = {
                floor: function (x) {
                    return -Math.ceil(-x)
                },
                ceil: function (x) {
                    return -Math.floor(-x)
                }
            };
        d3.scale.pow = function () {
                return d3_scale_pow(d3.scale.linear(), 1, [0, 1])
            },
            d3.scale.sqrt = function () {
                return d3.scale.pow().exponent(.5)
            },
            d3.scale.ordinal = function () {
                return d3_scale_ordinal([], {
                    t: "range",
                    a: [
                        []
                    ]
                })
            },
            d3.scale.category10 = function () {
                return d3.scale.ordinal().range(d3_category10)
            },
            d3.scale.category20 = function () {
                return d3.scale.ordinal().range(d3_category20)
            },
            d3.scale.category20b = function () {
                return d3.scale.ordinal().range(d3_category20b)
            },
            d3.scale.category20c = function () {
                return d3.scale.ordinal().range(d3_category20c)
            };
        var d3_category10 = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(d3_rgbString),
            d3_category20 = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(d3_rgbString),
            d3_category20b = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654].map(d3_rgbString),
            d3_category20c = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(d3_rgbString);
        d3.scale.quantile = function () {
                return d3_scale_quantile([], [])
            },
            d3.scale.quantize = function () {
                return d3_scale_quantize(0, 1, [0, 1])
            },
            d3.scale.threshold = function () {
                return d3_scale_threshold([.5], [0, 1])
            },
            d3.scale.identity = function () {
                return d3_scale_identity([0, 1])
            },
            d3.svg.arc = function () {
                function arc() {
                    var r0 = innerRadius.apply(this, arguments),
                        r1 = outerRadius.apply(this, arguments),
                        a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset,
                        a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset,
                        da = (a0 > a1 && (da = a0, a0 = a1, a1 = da), a1 - a0),
                        df = π > da ? "0" : "1",
                        c0 = Math.cos(a0),
                        s0 = Math.sin(a0),
                        c1 = Math.cos(a1),
                        s1 = Math.sin(a1);
                    return da >= d3_svg_arcMax ? r0 ? "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "M0," + r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + -r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + r0 + "Z" : "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "Z" : r0 ? "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L" + r0 * c1 + "," + r0 * s1 + "A" + r0 + "," + r0 + " 0 " + df + ",0 " + r0 * c0 + "," + r0 * s0 + "Z" : "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L0,0Z"
                }
                var innerRadius = d3_svg_arcInnerRadius,
                    outerRadius = d3_svg_arcOuterRadius,
                    startAngle = d3_svg_arcStartAngle,
                    endAngle = d3_svg_arcEndAngle;
                return arc.innerRadius = function (v) {
                        return arguments.length ? (innerRadius = d3_functor(v), arc) : innerRadius
                    },
                    arc.outerRadius = function (v) {
                        return arguments.length ? (outerRadius = d3_functor(v), arc) : outerRadius
                    },
                    arc.startAngle = function (v) {
                        return arguments.length ? (startAngle = d3_functor(v), arc) : startAngle
                    },
                    arc.endAngle = function (v) {
                        return arguments.length ? (endAngle = d3_functor(v), arc) : endAngle
                    },
                    arc.centroid = function () {
                        var r = (innerRadius.apply(this, arguments) + outerRadius.apply(this, arguments)) / 2,
                            a = (startAngle.apply(this, arguments) + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;
                        return [Math.cos(a) * r, Math.sin(a) * r]
                    },
                    arc
            };
        var d3_svg_arcOffset = -π / 2,
            d3_svg_arcMax = 2 * π - 1e-6;
        d3.svg.line.radial = function () {
                var line = d3_svg_line(d3_svg_lineRadial);
                return line.radius = line.x,
                    delete line.x,
                    line.angle = line.y,
                    delete line.y,
                    line
            },
            d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter,
            d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore,
            d3.svg.area = function () {
                return d3_svg_area(d3_identity)
            },
            d3.svg.area.radial = function () {
                var area = d3_svg_area(d3_svg_lineRadial);
                return area.radius = area.x,
                    delete area.x,
                    area.innerRadius = area.x0,
                    delete area.x0,
                    area.outerRadius = area.x1,
                    delete area.x1,
                    area.angle = area.y,
                    delete area.y,
                    area.startAngle = area.y0,
                    delete area.y0,
                    area.endAngle = area.y1,
                    delete area.y1,
                    area
            },
            d3.svg.chord = function () {
                function chord(d, i) {
                    var s = subgroup(this, source, d, i),
                        t = subgroup(this, target, d, i);
                    return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z"
                }

                function subgroup(self, f, d, i) {
                    var subgroup = f.call(self, d, i),
                        r = radius.call(self, subgroup, i),
                        a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset,
                        a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;
                    return {
                        r: r,
                        a0: a0,
                        a1: a1,
                        p0: [r * Math.cos(a0), r * Math.sin(a0)],
                        p1: [r * Math.cos(a1), r * Math.sin(a1)]
                    }
                }

                function equals(a, b) {
                    return a.a0 == b.a0 && a.a1 == b.a1
                }

                function arc(r, p, a) {
                    return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p
                }

                function curve(r0, p0, r1, p1) {
                    return "Q 0,0 " + p1
                }
                var source = d3_source,
                    target = d3_target,
                    radius = d3_svg_chordRadius,
                    startAngle = d3_svg_arcStartAngle,
                    endAngle = d3_svg_arcEndAngle;
                return chord.radius = function (v) {
                        return arguments.length ? (radius = d3_functor(v), chord) : radius
                    },
                    chord.source = function (v) {
                        return arguments.length ? (source = d3_functor(v), chord) : source
                    },
                    chord.target = function (v) {
                        return arguments.length ? (target = d3_functor(v), chord) : target
                    },
                    chord.startAngle = function (v) {
                        return arguments.length ? (startAngle = d3_functor(v), chord) : startAngle
                    },
                    chord.endAngle = function (v) {
                        return arguments.length ? (endAngle = d3_functor(v), chord) : endAngle
                    },
                    chord
            },
            d3.svg.diagonal = function () {
                function diagonal(d, i) {
                    var p0 = source.call(this, d, i),
                        p3 = target.call(this, d, i),
                        m = (p0.y + p3.y) / 2,
                        p = [p0, {
                                x: p0.x,
                                y: m
                            },
                            {
                                x: p3.x,
                                y: m
                            },
                            p3
                        ];
                    return p = p.map(projection),
                        "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3]
                }
                var source = d3_source,
                    target = d3_target,
                    projection = d3_svg_diagonalProjection;
                return diagonal.source = function (x) {
                        return arguments.length ? (source = d3_functor(x), diagonal) : source
                    },
                    diagonal.target = function (x) {
                        return arguments.length ? (target = d3_functor(x), diagonal) : target
                    },
                    diagonal.projection = function (x) {
                        return arguments.length ? (projection = x, diagonal) : projection
                    },
                    diagonal
            },
            d3.svg.diagonal.radial = function () {
                var diagonal = d3.svg.diagonal(),
                    projection = d3_svg_diagonalProjection,
                    projection_ = diagonal.projection;
                return diagonal.projection = function (x) {
                        return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection
                    },
                    diagonal
            },
            d3.svg.symbol = function () {
                function symbol(d, i) {
                    return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i))
                }
                var type = d3_svg_symbolType,
                    size = d3_svg_symbolSize;
                return symbol.type = function (x) {
                        return arguments.length ? (type = d3_functor(x), symbol) : type
                    },
                    symbol.size = function (x) {
                        return arguments.length ? (size = d3_functor(x), symbol) : size
                    },
                    symbol
            };
        var d3_svg_symbols = d3.map({
            circle: d3_svg_symbolCircle,
            cross: function (size) {
                var r = Math.sqrt(size / 5) / 2;
                return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z"
            },
            diamond: function (size) {
                var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)),
                    rx = ry * d3_svg_symbolTan30;
                return "M0," + -ry + "L" + rx + ",0 0," + ry + " " + -rx + ",0Z"
            },
            square: function (size) {
                var r = Math.sqrt(size) / 2;
                return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z"
            },
            "triangle-down": function (size) {
                var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
                    ry = rx * d3_svg_symbolSqrt3 / 2;
                return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z"
            },
            "triangle-up": function (size) {
                var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
                    ry = rx * d3_svg_symbolSqrt3 / 2;
                return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z"
            }
        });
        d3.svg.symbolTypes = d3_svg_symbols.keys();
        var d3_transitionInheritId, d3_transitionInherit, d3_svg_symbolSqrt3 = Math.sqrt(3),
            d3_svg_symbolTan30 = Math.tan(30 * d3_radians),
            d3_transitionPrototype = [],
            d3_transitionId = 0;
        d3_transitionPrototype.call = d3_selectionPrototype.call,
            d3_transitionPrototype.empty = d3_selectionPrototype.empty,
            d3_transitionPrototype.node = d3_selectionPrototype.node,
            d3_transitionPrototype.size = d3_selectionPrototype.size,
            d3.transition = function (selection) {
                return arguments.length ? d3_transitionInheritId ? selection.transition() : selection : d3_selectionRoot.transition()
            },
            d3.transition.prototype = d3_transitionPrototype,
            d3_transitionPrototype.select = function (selector) {
                var subgroup, subnode, node, id = this.id,
                    subgroups = [];
                selector = d3_selection_selector(selector);
                for (var j = -1,
                        m = this.length; ++j < m;) {
                    subgroups.push(subgroup = []);
                    for (var group = this[j], i = -1, n = group.length; ++i < n;)(node = group[i]) && (subnode = selector.call(node, node.__data__, i, j)) ? ("__data__" in node && (subnode.__data__ = node.__data__), d3_transitionNode(subnode, i, id, node.__transition__[id]), subgroup.push(subnode)) : subgroup.push(null)
                }
                return d3_transition(subgroups, id)
            },
            d3_transitionPrototype.selectAll = function (selector) {
                var subgroup, subnodes, node, subnode, transition, id = this.id,
                    subgroups = [];
                selector = d3_selection_selectorAll(selector);
                for (var j = -1,
                        m = this.length; ++j < m;)
                    for (var group = this[j], i = -1, n = group.length; ++i < n;)
                        if (node = group[i]) {
                            transition = node.__transition__[id],
                                subnodes = selector.call(node, node.__data__, i, j),
                                subgroups.push(subgroup = []);
                            for (var k = -1,
                                    o = subnodes.length; ++k < o;)(subnode = subnodes[k]) && d3_transitionNode(subnode, k, id, transition),
                                subgroup.push(subnode)
                        }
                return d3_transition(subgroups, id)
            },
            d3_transitionPrototype.filter = function (filter) {
                var subgroup, group, node, subgroups = [];
                "function" != typeof filter && (filter = d3_selection_filter(filter));
                for (var j = 0,
                        m = this.length; m > j; j++) {
                    subgroups.push(subgroup = []);
                    for (var group = this[j], i = 0, n = group.length; n > i; i++)(node = group[i]) && filter.call(node, node.__data__, i) && subgroup.push(node)
                }
                return d3_transition(subgroups, this.id)
            },
            d3_transitionPrototype.tween = function (name, tween) {
                var id = this.id;
                return arguments.length < 2 ? this.node().__transition__[id].tween.get(name) : d3_selection_each(this, null == tween ?
                    function (node) {
                        node.__transition__[id].tween.remove(name)
                    } : function (node) {
                        node.__transition__[id].tween.set(name, tween)
                    })
            },
            d3_transitionPrototype.attr = function (nameNS, value) {
                function attrNull() {
                    this.removeAttribute(name)
                }

                function attrNullNS() {
                    this.removeAttributeNS(name.space, name.local)
                }

                function attrTween(b) {
                    return null == b ? attrNull : (b += "",
                        function () {
                            var i, a = this.getAttribute(name);
                            return a !== b && (i = interpolate(a, b),
                                function (t) {
                                    this.setAttribute(name, i(t))
                                })
                        })
                }

                function attrTweenNS(b) {
                    return null == b ? attrNullNS : (b += "",
                        function () {
                            var i, a = this.getAttributeNS(name.space, name.local);
                            return a !== b && (i = interpolate(a, b),
                                function (t) {
                                    this.setAttributeNS(name.space, name.local, i(t))
                                })
                        })
                }
                if (arguments.length < 2) {
                    for (value in nameNS) this.attr(value, nameNS[value]);
                    return this
                }
                var interpolate = "transform" == nameNS ? d3_interpolateTransform : d3_interpolate,
                    name = d3.ns.qualify(nameNS);
                return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween)
            },
            d3_transitionPrototype.attrTween = function (nameNS, tween) {
                function attrTween(d, i) {
                    var f = tween.call(this, d, i, this.getAttribute(name));
                    return f &&
                        function (t) {
                            this.setAttribute(name, f(t))
                        }
                }

                function attrTweenNS(d, i) {
                    var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
                    return f &&
                        function (t) {
                            this.setAttributeNS(name.space, name.local, f(t))
                        }
                }
                var name = d3.ns.qualify(nameNS);
                return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween)
            },
            d3_transitionPrototype.style = function (name, value, priority) {
                function styleNull() {
                    this.style.removeProperty(name)
                }

                function styleString(b) {
                    return null == b ? styleNull : (b += "",
                        function () {
                            var i, a = d3_window.getComputedStyle(this, null).getPropertyValue(name);
                            return a !== b && (i = d3_interpolate(a, b),
                                function (t) {
                                    this.style.setProperty(name, i(t), priority)
                                })
                        })
                }
                var n = arguments.length;
                if (3 > n) {
                    if ("string" != typeof name) {
                        2 > n && (value = "");
                        for (priority in name) this.style(priority, name[priority], value);
                        return this
                    }
                    priority = ""
                }
                return d3_transition_tween(this, "style." + name, value, styleString)
            },
            d3_transitionPrototype.styleTween = function (name, tween, priority) {
                function styleTween(d, i) {
                    var f = tween.call(this, d, i, d3_window.getComputedStyle(this, null).getPropertyValue(name));
                    return f &&
                        function (t) {
                            this.style.setProperty(name, f(t), priority)
                        }
                }
                return arguments.length < 3 && (priority = ""),
                    this.tween("style." + name, styleTween)
            },
            d3_transitionPrototype.text = function (value) {
                return d3_transition_tween(this, "text", value, d3_transition_text)
            },
            d3_transitionPrototype.remove = function () {
                return this.each("end.transition",
                    function () {
                        var p;
                        !this.__transition__ && (p = this.parentNode) && p.removeChild(this)
                    })
            },
            d3_transitionPrototype.ease = function (value) {
                var id = this.id;
                return arguments.length < 1 ? this.node().__transition__[id].ease : ("function" != typeof value && (value = d3.ease.apply(d3, arguments)), d3_selection_each(this,
                    function (node) {
                        node.__transition__[id].ease = value
                    }))
            },
            d3_transitionPrototype.delay = function (value) {
                var id = this.id;
                return d3_selection_each(this, "function" == typeof value ?
                    function (node, i, j) {
                        node.__transition__[id].delay = 0 | value.call(node, node.__data__, i, j)
                    } : (value |= 0,
                        function (node) {
                            node.__transition__[id].delay = value
                        }))
            },
            d3_transitionPrototype.duration = function (value) {
                var id = this.id;
                return d3_selection_each(this, "function" == typeof value ?
                    function (node, i, j) {
                        node.__transition__[id].duration = Math.max(1, 0 | value.call(node, node.__data__, i, j))
                    } : (value = Math.max(1, 0 | value),
                        function (node) {
                            node.__transition__[id].duration = value
                        }))
            },
            d3_transitionPrototype.each = function (type, listener) {
                var id = this.id;
                if (arguments.length < 2) {
                    var inherit = d3_transitionInherit,
                        inheritId = d3_transitionInheritId;
                    d3_transitionInheritId = id,
                        d3_selection_each(this,
                            function (node, i, j) {
                                d3_transitionInherit = node.__transition__[id],
                                    type.call(node, node.__data__, i, j)
                            }),
                        d3_transitionInherit = inherit,
                        d3_transitionInheritId = inheritId
                } else d3_selection_each(this,
                    function (node) {
                        var transition = node.__transition__[id];
                        (transition.event || (transition.event = d3.dispatch("start", "end"))).on(type, listener)
                    });
                return this
            },
            d3_transitionPrototype.transition = function () {
                for (var subgroup, group, node, transition, id0 = this.id,
                        id1 = ++d3_transitionId,
                        subgroups = [], j = 0, m = this.length; m > j; j++) {
                    subgroups.push(subgroup = []);
                    for (var group = this[j], i = 0, n = group.length; n > i; i++)(node = group[i]) && (transition = Object.create(node.__transition__[id0]), transition.delay += transition.duration, d3_transitionNode(node, i, id1, transition)),
                        subgroup.push(node)
                }
                return d3_transition(subgroups, id1)
            },
            d3.svg.axis = function () {
                function axis(g) {
                    g.each(function () {
                        var tickTransform, g = d3.select(this),
                            ticks = null == tickValues ? scale.ticks ? scale.ticks.apply(scale, tickArguments_) : scale.domain() : tickValues,
                            tickFormat = null == tickFormat_ ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments_) : String : tickFormat_,
                            subticks = d3_svg_axisSubdivide(scale, ticks, tickSubdivide),
                            subtick = g.selectAll(".tick.minor").data(subticks, String),
                            subtickEnter = subtick.enter().insert("line", ".tick").attr("class", "tick minor").style("opacity", 1e-6),
                            subtickExit = d3.transition(subtick.exit()).style("opacity", 1e-6).remove(),
                            subtickUpdate = d3.transition(subtick).style("opacity", 1),
                            tick = g.selectAll(".tick.major").data(ticks, String),
                            tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick major").style("opacity", 1e-6),
                            tickExit = d3.transition(tick.exit()).style("opacity", 1e-6).remove(),
                            tickUpdate = d3.transition(tick).style("opacity", 1),
                            range = d3_scaleRange(scale),
                            path = g.selectAll(".domain").data([0]),
                            pathUpdate = (path.enter().append("path").attr("class", "domain"), d3.transition(path)),
                            scale1 = scale.copy(),
                            scale0 = this.__chart__ || scale1;
                        this.__chart__ = scale1,
                            tickEnter.append("line"),
                            tickEnter.append("text");
                        var lineEnter = tickEnter.select("line"),
                            lineUpdate = tickUpdate.select("line"),
                            text = tick.select("text").text(tickFormat),
                            textEnter = tickEnter.select("text"),
                            textUpdate = tickUpdate.select("text");
                        switch (orient) {
                            case "bottom":
                                tickTransform = d3_svg_axisX,
                                    subtickEnter.attr("y2", tickMinorSize),
                                    subtickUpdate.attr("x2", 0).attr("y2", tickMinorSize),
                                    lineEnter.attr("y2", tickMajorSize),
                                    textEnter.attr("y", Math.max(tickMajorSize, 0) + tickPadding),
                                    lineUpdate.attr("x2", 0).attr("y2", tickMajorSize),
                                    textUpdate.attr("x", 0).attr("y", Math.max(tickMajorSize, 0) + tickPadding),
                                    text.attr("dy", ".71em").style("text-anchor", "middle"),
                                    pathUpdate.attr("d", "M" + range[0] + "," + tickEndSize + "V0H" + range[1] + "V" + tickEndSize);
                                break;
                            case "top":
                                tickTransform = d3_svg_axisX,
                                    subtickEnter.attr("y2", -tickMinorSize),
                                    subtickUpdate.attr("x2", 0).attr("y2", -tickMinorSize),
                                    lineEnter.attr("y2", -tickMajorSize),
                                    textEnter.attr("y", -(Math.max(tickMajorSize, 0) + tickPadding)),
                                    lineUpdate.attr("x2", 0).attr("y2", -tickMajorSize),
                                    textUpdate.attr("x", 0).attr("y", -(Math.max(tickMajorSize, 0) + tickPadding)),
                                    text.attr("dy", "0em").style("text-anchor", "middle"),
                                    pathUpdate.attr("d", "M" + range[0] + "," + -tickEndSize + "V0H" + range[1] + "V" + -tickEndSize);
                                break;
                            case "left":
                                tickTransform = d3_svg_axisY,
                                    subtickEnter.attr("x2", -tickMinorSize),
                                    subtickUpdate.attr("x2", -tickMinorSize).attr("y2", 0),
                                    lineEnter.attr("x2", -tickMajorSize),
                                    textEnter.attr("x", -(Math.max(tickMajorSize, 0) + tickPadding)),
                                    lineUpdate.attr("x2", -tickMajorSize).attr("y2", 0),
                                    textUpdate.attr("x", -(Math.max(tickMajorSize, 0) + tickPadding)).attr("y", 0),
                                    text.attr("dy", ".32em").style("text-anchor", "end"),
                                    pathUpdate.attr("d", "M" + -tickEndSize + "," + range[0] + "H0V" + range[1] + "H" + -tickEndSize);
                                break;
                            case "right":
                                tickTransform = d3_svg_axisY,
                                    subtickEnter.attr("x2", tickMinorSize),
                                    subtickUpdate.attr("x2", tickMinorSize).attr("y2", 0),
                                    lineEnter.attr("x2", tickMajorSize),
                                    textEnter.attr("x", Math.max(tickMajorSize, 0) + tickPadding),
                                    lineUpdate.attr("x2", tickMajorSize).attr("y2", 0),
                                    textUpdate.attr("x", Math.max(tickMajorSize, 0) + tickPadding).attr("y", 0),
                                    text.attr("dy", ".32em").style("text-anchor", "start"),
                                    pathUpdate.attr("d", "M" + tickEndSize + "," + range[0] + "H0V" + range[1] + "H" + tickEndSize)
                        }
                        if (scale.rangeBand) {
                            var dx = scale1.rangeBand() / 2,
                                x = function (d) {
                                    return scale1(d) + dx
                                };
                            tickEnter.call(tickTransform, x),
                                tickUpdate.call(tickTransform, x)
                        } else tickEnter.call(tickTransform, scale0),
                            tickUpdate.call(tickTransform, scale1),
                            tickExit.call(tickTransform, scale1),
                            subtickEnter.call(tickTransform, scale0),
                            subtickUpdate.call(tickTransform, scale1),
                            subtickExit.call(tickTransform, scale1)
                    })
                }
                var tickFormat_, scale = d3.scale.linear(),
                    orient = d3_svg_axisDefaultOrient,
                    tickMajorSize = 6,
                    tickMinorSize = 6,
                    tickEndSize = 6,
                    tickPadding = 3,
                    tickArguments_ = [10],
                    tickValues = null,
                    tickSubdivide = 0;
                return axis.scale = function (x) {
                        return arguments.length ? (scale = x, axis) : scale
                    },
                    axis.orient = function (x) {
                        return arguments.length ? (orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient, axis) : orient
                    },
                    axis.ticks = function () {
                        return arguments.length ? (tickArguments_ = arguments, axis) : tickArguments_
                    },
                    axis.tickValues = function (x) {
                        return arguments.length ? (tickValues = x, axis) : tickValues
                    },
                    axis.tickFormat = function (x) {
                        return arguments.length ? (tickFormat_ = x, axis) : tickFormat_
                    },
                    axis.tickSize = function (x, y) {
                        if (!arguments.length) return tickMajorSize;
                        var n = arguments.length - 1;
                        return tickMajorSize = +x,
                            tickMinorSize = n > 1 ? +y : tickMajorSize,
                            tickEndSize = n > 0 ? +arguments[n] : tickMajorSize,
                            axis
                    },
                    axis.tickPadding = function (x) {
                        return arguments.length ? (tickPadding = +x, axis) : tickPadding
                    },
                    axis.tickSubdivide = function (x) {
                        return arguments.length ? (tickSubdivide = +x, axis) : tickSubdivide
                    },
                    axis
            };
        var d3_svg_axisDefaultOrient = "bottom",
            d3_svg_axisOrients = {
                top: 1,
                right: 1,
                bottom: 1,
                left: 1
            };
        d3.svg.brush = function () {
            function brush(g) {
                g.each(function () {
                    var e, g = d3.select(this),
                        bg = g.selectAll(".background").data([0]),
                        fg = g.selectAll(".extent").data([0]),
                        tz = g.selectAll(".resize").data(resizes, String);
                    g.style("pointer-events", "all").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart),
                        bg.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair"),
                        fg.enter().append("rect").attr("class", "extent").style("cursor", "move"),
                        tz.enter().append("g").attr("class",
                            function (d) {
                                return "resize " + d
                            }).style("cursor",
                            function (d) {
                                return d3_svg_brushCursor[d]
                            }).append("rect").attr("x",
                            function (d) {
                                return /[ew]$/.test(d) ? -3 : null
                            }).attr("y",
                            function (d) {
                                return /^[ns]/.test(d) ? -3 : null
                            }).attr("width", 6).attr("height", 6).style("visibility", "hidden"),
                        tz.style("display", brush.empty() ? "none" : null),
                        tz.exit().remove(),
                        x && (e = d3_scaleRange(x), bg.attr("x", e[0]).attr("width", e[1] - e[0]), redrawX(g)),
                        y && (e = d3_scaleRange(y), bg.attr("y", e[0]).attr("height", e[1] - e[0]), redrawY(g)),
                        redraw(g)
                })
            }

            function redraw(g) {
                g.selectAll(".resize").attr("transform",
                    function (d) {
                        return "translate(" + extent[+/e$/.test(d)][0] + "," + extent[+/^s/.test(d)][1] + ")"
                    })
            }

            function redrawX(g) {
                g.select(".extent").attr("x", extent[0][0]),
                    g.selectAll(".extent,.n>rect,.s>rect").attr("width", extent[1][0] - extent[0][0])
            }

            function redrawY(g) {
                g.select(".extent").attr("y", extent[0][1]),
                    g.selectAll(".extent,.e>rect,.w>rect").attr("height", extent[1][1] - extent[0][1])
            }

            function brushstart() {
                function mouse() {
                    var touches = d3.event.changedTouches;
                    return touches ? d3.touches(target, touches)[0] : d3.mouse(target)
                }

                function keydown() {
                    32 == d3.event.keyCode && (dragging || (center = null, origin[0] -= extent[1][0], origin[1] -= extent[1][1], dragging = 2), d3_eventPreventDefault())
                }

                function keyup() {
                    32 == d3.event.keyCode && 2 == dragging && (origin[0] += extent[1][0], origin[1] += extent[1][1], dragging = 0, d3_eventPreventDefault())
                }

                function brushmove() {
                    var point = mouse(),
                        moved = !1;
                    offset && (point[0] += offset[0], point[1] += offset[1]),
                        dragging || (d3.event.altKey ? (center || (center = [(extent[0][0] + extent[1][0]) / 2, (extent[0][1] + extent[1][1]) / 2]), origin[0] = extent[+(point[0] < center[0])][0], origin[1] = extent[+(point[1] < center[1])][1]) : center = null),
                        resizingX && move1(point, x, 0) && (redrawX(g), moved = !0),
                        resizingY && move1(point, y, 1) && (redrawY(g), moved = !0),
                        moved && (redraw(g), event_({
                            type: "brush",
                            mode: dragging ? "move" : "resize"
                        }))
                }

                function move1(point, scale, i) {
                    var min, max, range = d3_scaleRange(scale),
                        r0 = range[0],
                        r1 = range[1],
                        position = origin[i],
                        size = extent[1][i] - extent[0][i];
                    return dragging && (r0 -= position, r1 -= size + position),
                        min = clamp[i] ? Math.max(r0, Math.min(r1, point[i])) : point[i],
                        dragging ? max = (min += position) + size : (center && (position = Math.max(r0, Math.min(r1, 2 * center[i] - min))), min > position ? (max = min, min = position) : max = position),
                        extent[0][i] !== min || extent[1][i] !== max ? (extentDomain = null, extent[0][i] = min, extent[1][i] = max, !0) : void 0
                }

                function brushend() {
                    brushmove(),
                        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null),
                        d3.select("body").style("cursor", null),
                        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null),
                        dragRestore(),
                        event_({
                            type: "brushend"
                        })
                }
                var center, offset, target = this,
                    eventTarget = d3.select(d3.event.target),
                    event_ = event.of(target, arguments),
                    g = d3.select(target),
                    resizing = eventTarget.datum(),
                    resizingX = !/^(n|s)$/.test(resizing) && x,
                    resizingY = !/^(e|w)$/.test(resizing) && y,
                    dragging = eventTarget.classed("extent"),
                    dragRestore = d3_event_dragSuppress(),
                    origin = mouse(),
                    w = d3.select(d3_window).on("keydown.brush", keydown).on("keyup.brush", keyup);
                if (d3.event.changedTouches ? w.on("touchmove.brush", brushmove).on("touchend.brush", brushend) : w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend), dragging) origin[0] = extent[0][0] - origin[0],
                    origin[1] = extent[0][1] - origin[1];
                else if (resizing) {
                    var ex = +/w$/.test(resizing),
                        ey = +/^n/.test(resizing);
                    offset = [extent[1 - ex][0] - origin[0], extent[1 - ey][1] - origin[1]],
                        origin[0] = extent[ex][0],
                        origin[1] = extent[ey][1]
                } else d3.event.altKey && (center = origin.slice());
                g.style("pointer-events", "none").selectAll(".resize").style("display", null),
                    d3.select("body").style("cursor", eventTarget.style("cursor")),
                    event_({
                        type: "brushstart"
                    }),
                    brushmove()
            }
            var extentDomain, event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"),
                x = null,
                y = null,
                resizes = d3_svg_brushResizes[0],
                extent = [
                    [0, 0],
                    [0, 0]
                ],
                clamp = [!0, !0];
            return brush.x = function (z) {
                    return arguments.length ? (x = z, resizes = d3_svg_brushResizes[!x << 1 | !y], brush) : x
                },
                brush.y = function (z) {
                    return arguments.length ? (y = z, resizes = d3_svg_brushResizes[!x << 1 | !y], brush) : y
                },
                brush.clamp = function (z) {
                    return arguments.length ? (x && y ? clamp = [!!z[0], !!z[1]] : (x || y) && (clamp[+!x] = !!z), brush) : x && y ? clamp : x || y ? clamp[+!x] : null
                },
                brush.extent = function (z) {
                    var x0, x1, y0, y1, t;
                    return arguments.length ? (extentDomain = [
                        [0, 0],
                        [0, 0]
                    ], x && (x0 = z[0], x1 = z[1], y && (x0 = x0[0], x1 = x1[0]), extentDomain[0][0] = x0, extentDomain[1][0] = x1, x.invert && (x0 = x(x0), x1 = x(x1)), x0 > x1 && (t = x0, x0 = x1, x1 = t), extent[0][0] = 0 | x0, extent[1][0] = 0 | x1), y && (y0 = z[0], y1 = z[1], x && (y0 = y0[1], y1 = y1[1]), extentDomain[0][1] = y0, extentDomain[1][1] = y1, y.invert && (y0 = y(y0), y1 = y(y1)), y0 > y1 && (t = y0, y0 = y1, y1 = t), extent[0][1] = 0 | y0, extent[1][1] = 0 | y1), brush) : (z = extentDomain || extent, x && (x0 = z[0][0], x1 = z[1][0], extentDomain || (x0 = extent[0][0], x1 = extent[1][0], x.invert && (x0 = x.invert(x0), x1 = x.invert(x1)), x0 > x1 && (t = x0, x0 = x1, x1 = t))), y && (y0 = z[0][1], y1 = z[1][1], extentDomain || (y0 = extent[0][1], y1 = extent[1][1], y.invert && (y0 = y.invert(y0), y1 = y.invert(y1)), y0 > y1 && (t = y0, y0 = y1, y1 = t))), x && y ? [
                        [x0, y0],
                        [x1, y1]
                    ] : x ? [x0, x1] : y && [y0, y1])
                },
                brush.clear = function () {
                    return extentDomain = null,
                        extent[0][0] = extent[0][1] = extent[1][0] = extent[1][1] = 0,
                        brush
                },
                brush.empty = function () {
                    return x && extent[0][0] === extent[1][0] || y && extent[0][1] === extent[1][1]
                },
                d3.rebind(brush, event, "on")
        };
        var d3_svg_brushCursor = {
                n: "ns-resize",
                e: "ew-resize",
                s: "ns-resize",
                w: "ew-resize",
                nw: "nwse-resize",
                ne: "nesw-resize",
                se: "nwse-resize",
                sw: "nesw-resize"
            },
            d3_svg_brushResizes = [
                ["n", "e", "s", "w", "nw", "ne", "se", "sw"],
                ["e", "w"],
                ["n", "s"],
                []
            ];
        d3.time = {};
        var d3_time = Date,
            d3_time_daySymbols = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
        d3_time_utc.prototype = {
            getDate: function () {
                return this._.getUTCDate()
            },
            getDay: function () {
                return this._.getUTCDay()
            },
            getFullYear: function () {
                return this._.getUTCFullYear()
            },
            getHours: function () {
                return this._.getUTCHours()
            },
            getMilliseconds: function () {
                return this._.getUTCMilliseconds()
            },
            getMinutes: function () {
                return this._.getUTCMinutes()
            },
            getMonth: function () {
                return this._.getUTCMonth()
            },
            getSeconds: function () {
                return this._.getUTCSeconds()
            },
            getTime: function () {
                return this._.getTime()
            },
            getTimezoneOffset: function () {
                return 0
            },
            valueOf: function () {
                return this._.valueOf()
            },
            setDate: function () {
                d3_time_prototype.setUTCDate.apply(this._, arguments)
            },
            setDay: function () {
                d3_time_prototype.setUTCDay.apply(this._, arguments)
            },
            setFullYear: function () {
                d3_time_prototype.setUTCFullYear.apply(this._, arguments)
            },
            setHours: function () {
                d3_time_prototype.setUTCHours.apply(this._, arguments)
            },
            setMilliseconds: function () {
                d3_time_prototype.setUTCMilliseconds.apply(this._, arguments)
            },
            setMinutes: function () {
                d3_time_prototype.setUTCMinutes.apply(this._, arguments)
            },
            setMonth: function () {
                d3_time_prototype.setUTCMonth.apply(this._, arguments)
            },
            setSeconds: function () {
                d3_time_prototype.setUTCSeconds.apply(this._, arguments)
            },
            setTime: function () {
                d3_time_prototype.setTime.apply(this._, arguments)
            }
        };
        var d3_time_prototype = Date.prototype,
            d3_time_formatDateTime = "%a %b %e %X %Y",
            d3_time_formatDate = "%m/%d/%Y",
            d3_time_formatTime = "%H:%M:%S",
            d3_time_days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            d3_time_dayAbbreviations = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            d3_time_months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            d3_time_monthAbbreviations = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        d3.time.year = d3_time_interval(function (date) {
                    return date = d3.time.day(date),
                        date.setMonth(0, 1),
                        date
                },
                function (date, offset) {
                    date.setFullYear(date.getFullYear() + offset)
                },
                function (date) {
                    return date.getFullYear()
                }),
            d3.time.years = d3.time.year.range,
            d3.time.years.utc = d3.time.year.utc.range,
            d3.time.day = d3_time_interval(function (date) {
                    var day = new d3_time(2e3, 0);
                    return day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate()),
                        day
                },
                function (date, offset) {
                    date.setDate(date.getDate() + offset)
                },
                function (date) {
                    return date.getDate() - 1
                }),
            d3.time.days = d3.time.day.range,
            d3.time.days.utc = d3.time.day.utc.range,
            d3.time.dayOfYear = function (date) {
                var year = d3.time.year(date);
                return Math.floor((date - year - 6e4 * (date.getTimezoneOffset() - year.getTimezoneOffset())) / 864e5)
            },
            d3_time_daySymbols.forEach(function (day, i) {
                day = day.toLowerCase(),
                    i = 7 - i;
                var interval = d3.time[day] = d3_time_interval(function (date) {
                        return (date = d3.time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7),
                            date
                    },
                    function (date, offset) {
                        date.setDate(date.getDate() + 7 * Math.floor(offset))
                    },
                    function (date) {
                        var day = d3.time.year(date).getDay();
                        return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i)
                    });
                d3.time[day + "s"] = interval.range,
                    d3.time[day + "s"].utc = interval.utc.range,
                    d3.time[day + "OfYear"] = function (date) {
                        var day = d3.time.year(date).getDay();
                        return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7)
                    }
            }),
            d3.time.week = d3.time.sunday,
            d3.time.weeks = d3.time.sunday.range,
            d3.time.weeks.utc = d3.time.sunday.utc.range,
            d3.time.weekOfYear = d3.time.sundayOfYear,
            d3.time.format = function (template) {
                function format(date) {
                    for (var c, p, f, string = [], i = -1, j = 0; ++i < n;) 37 === template.charCodeAt(i) && (string.push(template.substring(j, i)), null != (p = d3_time_formatPads[c = template.charAt(++i)]) && (c = template.charAt(++i)), (f = d3_time_formats[c]) && (c = f(date, null == p ? "e" === c ? " " : "0" : p)), string.push(c), j = i + 1);
                    return string.push(template.substring(j, i)),
                        string.join("")
                }
                var n = template.length;
                return format.parse = function (string) {
                        var d = {
                                y: 1900,
                                m: 0,
                                d: 1,
                                H: 0,
                                M: 0,
                                S: 0,
                                L: 0
                            },
                            i = d3_time_parse(d, template, string, 0);
                        if (i != string.length) return null;
                        "p" in d && (d.H = d.H % 12 + 12 * d.p);
                        var date = new d3_time;
                        return "j" in d ? date.setFullYear(d.y, 0, d.j) : "w" in d && ("W" in d || "U" in d) ? (date.setFullYear(d.y, 0, 1), date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + 7 * d.W - (date.getDay() + 5) % 7 : d.w + 7 * d.U - (date.getDay() + 6) % 7)) : date.setFullYear(d.y, d.m, d.d),
                            date.setHours(d.H, d.M, d.S, d.L),
                            date
                    },
                    format.toString = function () {
                        return template
                    },
                    format
            };
        var d3_time_dayRe = d3_time_formatRe(d3_time_days),
            d3_time_dayLookup = d3_time_formatLookup(d3_time_days),
            d3_time_dayAbbrevRe = d3_time_formatRe(d3_time_dayAbbreviations),
            d3_time_dayAbbrevLookup = d3_time_formatLookup(d3_time_dayAbbreviations),
            d3_time_monthRe = d3_time_formatRe(d3_time_months),
            d3_time_monthLookup = d3_time_formatLookup(d3_time_months),
            d3_time_monthAbbrevRe = d3_time_formatRe(d3_time_monthAbbreviations),
            d3_time_monthAbbrevLookup = d3_time_formatLookup(d3_time_monthAbbreviations),
            d3_time_percentRe = /^%/,
            d3_time_formatPads = {
                "-": "",
                _: " ",
                0: "0"
            },
            d3_time_formats = {
                a: function (d) {
                    return d3_time_dayAbbreviations[d.getDay()]
                },
                A: function (d) {
                    return d3_time_days[d.getDay()]
                },
                b: function (d) {
                    return d3_time_monthAbbreviations[d.getMonth()]
                },
                B: function (d) {
                    return d3_time_months[d.getMonth()]
                },
                c: d3.time.format(d3_time_formatDateTime),
                d: function (d, p) {
                    return d3_time_formatPad(d.getDate(), p, 2)
                },
                e: function (d, p) {
                    return d3_time_formatPad(d.getDate(), p, 2)
                },
                H: function (d, p) {
                    return d3_time_formatPad(d.getHours(), p, 2)
                },
                I: function (d, p) {
                    return d3_time_formatPad(d.getHours() % 12 || 12, p, 2)
                },
                j: function (d, p) {
                    return d3_time_formatPad(1 + d3.time.dayOfYear(d), p, 3)
                },
                L: function (d, p) {
                    return d3_time_formatPad(d.getMilliseconds(), p, 3)
                },
                m: function (d, p) {
                    return d3_time_formatPad(d.getMonth() + 1, p, 2)
                },
                M: function (d, p) {
                    return d3_time_formatPad(d.getMinutes(), p, 2)
                },
                p: function (d) {
                    return d.getHours() >= 12 ? "PM" : "AM"
                },
                S: function (d, p) {
                    return d3_time_formatPad(d.getSeconds(), p, 2)
                },
                U: function (d, p) {
                    return d3_time_formatPad(d3.time.sundayOfYear(d), p, 2)
                },
                w: function (d) {
                    return d.getDay()
                },
                W: function (d, p) {
                    return d3_time_formatPad(d3.time.mondayOfYear(d), p, 2)
                },
                x: d3.time.format(d3_time_formatDate),
                X: d3.time.format(d3_time_formatTime),
                y: function (d, p) {
                    return d3_time_formatPad(d.getFullYear() % 100, p, 2)
                },
                Y: function (d, p) {
                    return d3_time_formatPad(d.getFullYear() % 1e4, p, 4)
                },
                Z: d3_time_zone,
                "%": function () {
                    return "%"
                }
            },
            d3_time_parsers = {
                a: d3_time_parseWeekdayAbbrev,
                A: d3_time_parseWeekday,
                b: d3_time_parseMonthAbbrev,
                B: d3_time_parseMonth,
                c: d3_time_parseLocaleFull,
                d: d3_time_parseDay,
                e: d3_time_parseDay,
                H: d3_time_parseHour24,
                I: d3_time_parseHour24,
                j: d3_time_parseDayOfYear,
                L: d3_time_parseMilliseconds,
                m: d3_time_parseMonthNumber,
                M: d3_time_parseMinutes,
                p: d3_time_parseAmPm,
                S: d3_time_parseSeconds,
                U: d3_time_parseWeekNumberSunday,
                w: d3_time_parseWeekdayNumber,
                W: d3_time_parseWeekNumberMonday,
                x: d3_time_parseLocaleDate,
                X: d3_time_parseLocaleTime,
                y: d3_time_parseYear,
                Y: d3_time_parseFullYear,
                "%": d3_time_parseLiteralPercent
            },
            d3_time_numberRe = /^\s*\d+/,
            d3_time_amPmLookup = d3.map({
                am: 0,
                pm: 1
            });
        d3.time.format.utc = function (template) {
            function format(date) {
                try {
                    d3_time = d3_time_utc;
                    var utc = new d3_time;
                    return utc._ = date,
                        local(utc)
                } finally {
                    d3_time = Date
                }
            }
            var local = d3.time.format(template);
            return format.parse = function (string) {
                    try {
                        d3_time = d3_time_utc;
                        var date = local.parse(string);
                        return date && date._
                    } finally {
                        d3_time = Date
                    }
                },
                format.toString = local.toString,
                format
        };
        var d3_time_formatIso = d3.time.format.utc("%Y-%m-%dT%H:%M:%S.%LZ");
        d3.time.format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso,
            d3_time_formatIsoNative.parse = function (string) {
                var date = new Date(string);
                return isNaN(date) ? null : date
            },
            d3_time_formatIsoNative.toString = d3_time_formatIso.toString,
            d3.time.second = d3_time_interval(function (date) {
                    return new d3_time(1e3 * Math.floor(date / 1e3))
                },
                function (date, offset) {
                    date.setTime(date.getTime() + 1e3 * Math.floor(offset))
                },
                function (date) {
                    return date.getSeconds()
                }),
            d3.time.seconds = d3.time.second.range,
            d3.time.seconds.utc = d3.time.second.utc.range,
            d3.time.minute = d3_time_interval(function (date) {
                    return new d3_time(6e4 * Math.floor(date / 6e4))
                },
                function (date, offset) {
                    date.setTime(date.getTime() + 6e4 * Math.floor(offset))
                },
                function (date) {
                    return date.getMinutes()
                }),
            d3.time.minutes = d3.time.minute.range,
            d3.time.minutes.utc = d3.time.minute.utc.range,
            d3.time.hour = d3_time_interval(function (date) {
                    var timezone = date.getTimezoneOffset() / 60;
                    return new d3_time(36e5 * (Math.floor(date / 36e5 - timezone) + timezone))
                },
                function (date, offset) {
                    date.setTime(date.getTime() + 36e5 * Math.floor(offset))
                },
                function (date) {
                    return date.getHours()
                }),
            d3.time.hours = d3.time.hour.range,
            d3.time.hours.utc = d3.time.hour.utc.range,
            d3.time.month = d3_time_interval(function (date) {
                    return date = d3.time.day(date),
                        date.setDate(1),
                        date
                },
                function (date, offset) {
                    date.setMonth(date.getMonth() + offset)
                },
                function (date) {
                    return date.getMonth()
                }),
            d3.time.months = d3.time.month.range,
            d3.time.months.utc = d3.time.month.utc.range;
        var d3_time_scaleSteps = [1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6],
            d3_time_scaleLocalMethods = [
                [d3.time.second, 1],
                [d3.time.second, 5],
                [d3.time.second, 15],
                [d3.time.second, 30],
                [d3.time.minute, 1],
                [d3.time.minute, 5],
                [d3.time.minute, 15],
                [d3.time.minute, 30],
                [d3.time.hour, 1],
                [d3.time.hour, 3],
                [d3.time.hour, 6],
                [d3.time.hour, 12],
                [d3.time.day, 1],
                [d3.time.day, 2],
                [d3.time.week, 1],
                [d3.time.month, 1],
                [d3.time.month, 3],
                [d3.time.year, 1]
            ],
            d3_time_scaleLocalFormats = [
                [d3.time.format("%Y"), d3_true],
                [d3.time.format("%B"),
                    function (d) {
                        return d.getMonth()
                    }
                ],
                [d3.time.format("%b %d"),
                    function (d) {
                        return 1 != d.getDate()
                    }
                ],
                [d3.time.format("%a %d"),
                    function (d) {
                        return d.getDay() && 1 != d.getDate()
                    }
                ],
                [d3.time.format("%I %p"),
                    function (d) {
                        return d.getHours()
                    }
                ],
                [d3.time.format("%I:%M"),
                    function (d) {
                        return d.getMinutes()
                    }
                ],
                [d3.time.format(":%S"),
                    function (d) {
                        return d.getSeconds()
                    }
                ],
                [d3.time.format(".%L"),
                    function (d) {
                        return d.getMilliseconds()
                    }
                ]
            ],
            d3_time_scaleLinear = d3.scale.linear(),
            d3_time_scaleLocalFormat = d3_time_scaleFormat(d3_time_scaleLocalFormats);
        d3_time_scaleLocalMethods.year = function (extent, m) {
                return d3_time_scaleLinear.domain(extent.map(d3_time_scaleGetYear)).ticks(m).map(d3_time_scaleSetYear)
            },
            d3.time.scale = function () {
                return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat)
            };
        var d3_time_scaleUTCMethods = d3_time_scaleLocalMethods.map(function (m) {
                return [m[0].utc, m[1]]
            }),
            d3_time_scaleUTCFormats = [
                [d3.time.format.utc("%Y"), d3_true],
                [d3.time.format.utc("%B"),
                    function (d) {
                        return d.getUTCMonth()
                    }
                ],
                [d3.time.format.utc("%b %d"),
                    function (d) {
                        return 1 != d.getUTCDate()
                    }
                ],
                [d3.time.format.utc("%a %d"),
                    function (d) {
                        return d.getUTCDay() && 1 != d.getUTCDate()
                    }
                ],
                [d3.time.format.utc("%I %p"),
                    function (d) {
                        return d.getUTCHours()
                    }
                ],
                [d3.time.format.utc("%I:%M"),
                    function (d) {
                        return d.getUTCMinutes()
                    }
                ],
                [d3.time.format.utc(":%S"),
                    function (d) {
                        return d.getUTCSeconds()
                    }
                ],
                [d3.time.format.utc(".%L"),
                    function (d) {
                        return d.getUTCMilliseconds()
                    }
                ]
            ],
            d3_time_scaleUTCFormat = d3_time_scaleFormat(d3_time_scaleUTCFormats);
        return d3_time_scaleUTCMethods.year = function (extent, m) {
                return d3_time_scaleLinear.domain(extent.map(d3_time_scaleUTCGetYear)).ticks(m).map(d3_time_scaleUTCSetYear)
            },
            d3.time.scale.utc = function () {
                return d3_time_scale(d3.scale.linear(), d3_time_scaleUTCMethods, d3_time_scaleUTCFormat)
            },
            d3.text = d3_xhrType(function (request) {
                return request.responseText
            }),
            d3.json = function (url, callback) {
                return d3_xhr(url, "application/json", d3_json, callback)
            },
            d3.html = function (url, callback) {
                return d3_xhr(url, "text/html", d3_html, callback)
            },
            d3.xml = d3_xhrType(function (request) {
                return request.responseXML
            }),
            d3
    }(), "function" != typeof Blob && "object" != typeof Blob || "undefined" == typeof URL)
    if ("function" != typeof Blob && "object" != typeof Blob || "undefined" == typeof webkitURL) var Blob = function (view) {
        "use strict";
        var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || view.MSBlobBuilder ||
            function (view) {
                var get_class = function (object) {
                        return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1]
                    },
                    FakeBlobBuilder = function () {
                        this.data = []
                    },
                    FakeBlob = function (data, type, encoding) {
                        this.data = data,
                            this.size = data.length,
                            this.type = type,
                            this.encoding = encoding
                    },
                    FBB_proto = FakeBlobBuilder.prototype,
                    FB_proto = FakeBlob.prototype,
                    FileReaderSync = view.FileReaderSync,
                    FileException = function (type) {
                        this.code = this[this.name = type]
                    },
                    file_ex_codes = "NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR".split(" "),
                    file_ex_code = file_ex_codes.length,
                    real_URL = view.URL || view.webkitURL || view,
                    real_create_object_URL = real_URL.createObjectURL,
                    real_revoke_object_URL = real_URL.revokeObjectURL,
                    URL = real_URL,
                    btoa = view.btoa,
                    atob = view.atob,
                    ArrayBuffer = view.ArrayBuffer,
                    Uint8Array = view.Uint8Array;
                for (FakeBlob.fake = FB_proto.fake = !0; file_ex_code--;) FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
                return real_URL.createObjectURL || (URL = view.URL = {}),
                    URL.createObjectURL = function (blob) {
                        var data_URI_header, type = blob.type;
                        return null === type && (type = "application/octet-stream"),
                            blob instanceof FakeBlob ? (data_URI_header = "data:" + type, "base64" === blob.encoding ? data_URI_header + ";base64," + blob.data : "URI" === blob.encoding ? data_URI_header + "," + decodeURIComponent(blob.data) : btoa ? data_URI_header + ";base64," + btoa(blob.data) : data_URI_header + "," + encodeURIComponent(blob.data)) : real_create_object_URL ? real_create_object_URL.call(real_URL, blob) : void 0
                    },
                    URL.revokeObjectURL = function (object_URL) {
                        "data:" !== object_URL.substring(0, 5) && real_revoke_object_URL && real_revoke_object_URL.call(real_URL, object_URL)
                    },
                    FBB_proto.append = function (data) {
                        var bb = this.data;
                        if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {
                            for (var str = "",
                                    buf = new Uint8Array(data), i = 0, buf_len = buf.length; buf_len > i; i++) str += String.fromCharCode(buf[i]);
                            bb.push(str)
                        } else if ("Blob" === get_class(data) || "File" === get_class(data)) {
                            if (!FileReaderSync) throw new FileException("NOT_READABLE_ERR");
                            var fr = new FileReaderSync;
                            bb.push(fr.readAsBinaryString(data))
                        } else data instanceof FakeBlob ? "base64" === data.encoding && atob ? bb.push(atob(data.data)) : "URI" === data.encoding ? bb.push(decodeURIComponent(data.data)) : "raw" === data.encoding && bb.push(data.data) : ("string" != typeof data && (data += ""), bb.push(unescape(encodeURIComponent(data))))
                    },
                    FBB_proto.getBlob = function (type) {
                        return arguments.length || (type = null),
                            new FakeBlob(this.data.join(""), type, "raw")
                    },
                    FBB_proto.toString = function () {
                        return "[object BlobBuilder]"
                    },
                    FB_proto.slice = function (start, end, type) {
                        var args = arguments.length;
                        return 3 > args && (type = null),
                            new FakeBlob(this.data.slice(start, args > 1 ? end : this.data.length), type, this.encoding)
                    },
                    FB_proto.toString = function () {
                        return "[object Blob]"
                    },
                    FakeBlobBuilder
            }(view);
        return function (blobParts, options) {
            var type = options ? options.type || "" : "",
                builder = new BlobBuilder;
            if (blobParts)
                for (var i = 0,
                        len = blobParts.length; len > i; i++) builder.append(blobParts[i]);
            return builder.getBlob(type)
        }
    }(self);
    else self.URL = webkitURL;
var saveAs = saveAs || navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator) ||
    function (view) {
        "use strict";
        var doc = view.document,
            get_URL = function () {
                return view.URL || view.webkitURL || view
            },
            URL = view.URL || view.webkitURL || view,
            save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"),
            can_use_save_link = !view.externalHost && "download" in save_link,
            click = function (node) {
                var event = doc.createEvent("MouseEvents");
                event.initMouseEvent("click", !0, !1, view, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null),
                    node.dispatchEvent(event)
            },
            webkit_req_fs = view.webkitRequestFileSystem,
            req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem,
            throw_outside = function (ex) {
                (view.setImmediate || view.setTimeout)(function () {
                        throw ex
                    },
                    0)
            },
            force_saveable_type = "application/octet-stream",
            fs_min_size = 0,
            deletion_queue = [],
            process_deletion_queue = function () {
                for (var i = deletion_queue.length; i--;) {
                    var file = deletion_queue[i];
                    "string" == typeof file ? URL.revokeObjectURL(file) : file.remove()
                }
                deletion_queue.length = 0
            },
            dispatch = function (filesaver, event_types, event) {
                event_types = [].concat(event_types);
                for (var i = event_types.length; i--;) {
                    var listener = filesaver["on" + event_types[i]];
                    if ("function" == typeof listener) try {
                        listener.call(filesaver, event || filesaver)
                    } catch (ex) {
                        throw_outside(ex)
                    }
                }
            },
            FileSaver = function (blob, name) {
                var object_url, target_view, slice, filesaver = this,
                    type = blob.type,
                    blob_changed = !1,
                    get_object_url = function () {
                        var object_url = get_URL().createObjectURL(blob);
                        return deletion_queue.push(object_url),
                            object_url
                    },
                    dispatch_all = function () {
                        dispatch(filesaver, "writestart progress write writeend".split(" "))
                    },
                    fs_error = function () {
                        (blob_changed || !object_url) && (object_url = get_object_url(blob)),
                        target_view ? target_view.location.href = object_url : window.open(object_url, "_blank"),
                            filesaver.readyState = filesaver.DONE,
                            dispatch_all()
                    },
                    abortable = function (func) {
                        return function () {
                            return filesaver.readyState !== filesaver.DONE ? func.apply(this, arguments) : void 0
                        }
                    },
                    create_if_not_found = {
                        create: !0,
                        exclusive: !1
                    };
                return filesaver.readyState = filesaver.INIT,
                    name || (name = "download"),
                    can_use_save_link ? (object_url = get_object_url(blob), save_link.href = object_url, save_link.download = name, click(save_link), filesaver.readyState = filesaver.DONE, void dispatch_all()) : (view.chrome && type && type !== force_saveable_type && (slice = blob.slice || blob.webkitSlice, blob = slice.call(blob, 0, blob.size, force_saveable_type), blob_changed = !0), webkit_req_fs && "download" !== name && (name += ".download"), (type === force_saveable_type || webkit_req_fs) && (target_view = view), req_fs ? (fs_min_size += blob.size, void req_fs(view.TEMPORARY, fs_min_size, abortable(function (fs) {
                        fs.root.getDirectory("saved", create_if_not_found, abortable(function (dir) {
                            var save = function () {
                                dir.getFile(name, create_if_not_found, abortable(function (file) {
                                    file.createWriter(abortable(function (writer) {
                                        writer.onwriteend = function (event) {
                                                target_view.location.href = file.toURL(),
                                                    deletion_queue.push(file),
                                                    filesaver.readyState = filesaver.DONE,
                                                    dispatch(filesaver, "writeend", event)
                                            },
                                            writer.onerror = function () {
                                                var error = writer.error;
                                                error.code !== error.ABORT_ERR && fs_error()
                                            },
                                            "writestart progress write abort".split(" ").forEach(function (event) {
                                                writer["on" + event] = filesaver["on" + event]
                                            }),
                                            writer.write(blob),
                                            filesaver.abort = function () {
                                                writer.abort(),
                                                    filesaver.readyState = filesaver.DONE
                                            },
                                            filesaver.readyState = filesaver.WRITING
                                    }), fs_error)
                                }), fs_error)
                            };
                            dir.getFile(name, {
                                    create: !1
                                },
                                abortable(function (file) {
                                    file.remove(),
                                        save()
                                }), abortable(function (ex) {
                                    ex.code === ex.NOT_FOUND_ERR ? save() : fs_error()
                                }))
                        }), fs_error)
                    }), fs_error)) : void fs_error())
            },
            FS_proto = FileSaver.prototype,
            saveAs = function (blob, name) {
                return new FileSaver(blob, name)
            };
        return FS_proto.abort = function () {
                var filesaver = this;
                filesaver.readyState = filesaver.DONE,
                    dispatch(filesaver, "abort")
            },
            FS_proto.readyState = FS_proto.INIT = 0,
            FS_proto.WRITING = 1,
            FS_proto.DONE = 2,
            FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null,
            view.addEventListener("unload", process_deletion_queue, !1),
            saveAs
    }(self);
(function (undefined) {
    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count)
        }
    }

    function ordinalizeToken(func, period) {
        return function (a) {
            return this.lang().ordinal(func.call(this, a), period)
        }
    }

    function Language() {}

    function Moment(config) {
        extend(this, config)
    }

    function Duration(duration) {
        var years = duration.years || duration.year || duration.y || 0,
            months = duration.months || duration.month || duration.M || 0,
            weeks = duration.weeks || duration.week || duration.w || 0,
            days = duration.days || duration.day || duration.d || 0,
            hours = duration.hours || duration.hour || duration.h || 0,
            minutes = duration.minutes || duration.minute || duration.m || 0,
            seconds = duration.seconds || duration.second || duration.s || 0,
            milliseconds = duration.milliseconds || duration.millisecond || duration.ms || 0;
        this._input = duration,
            this._milliseconds = milliseconds + 1e3 * seconds + 6e4 * minutes + 36e5 * hours,
            this._days = days + 7 * weeks,
            this._months = months + 12 * years,
            this._data = {},
            this._bubble()
    }

    function extend(a, b) {
        for (var i in b) b.hasOwnProperty(i) && (a[i] = b[i]);
        return a
    }

    function absRound(number) {
        return 0 > number ? Math.ceil(number) : Math.floor(number)
    }

    function leftZeroFill(number, targetLength) {
        for (var output = number + ""; output.length < targetLength;) output = "0" + output;
        return output
    }

    function addOrSubtractDurationFromMoment(mom, duration, isAdding, ignoreUpdateOffset) {
        var minutes, hours, milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        milliseconds && mom._d.setTime(+mom._d + milliseconds * isAdding),
            (days || months) && (minutes = mom.minute(), hours = mom.hour()),
            days && mom.date(mom.date() + days * isAdding),
            months && mom.month(mom.month() + months * isAdding),
            milliseconds && !ignoreUpdateOffset && moment.updateOffset(mom),
            (days || months) && (mom.minute(minutes), mom.hour(hours))
    }

    function isArray(input) {
        return "[object Array]" === Object.prototype.toString.call(input)
    }

    function compareArrays(array1, array2) {
        var i, len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0;
        for (i = 0; len > i; i++) ~~array1[i] !== ~~array2[i] && diffs++;
        return diffs + lengthDiff
    }

    function normalizeUnits(units) {
        return units ? unitAliases[units] || units.toLowerCase().replace(/(.)s$/, "$1") : units
    }

    function loadLang(key, values) {
        return values.abbr = key,
            languages[key] || (languages[key] = new Language),
            languages[key].set(values),
            languages[key]
    }

    function getLangDefinition(key) {
        if (!key) return moment.fn._lang;
        if (!languages[key] && hasModule) try {
            require("./lang/" + key)
        } catch (e) {
            return moment.fn._lang
        }
        return languages[key]
    }

    function removeFormattingTokens(input) {
        return input.match(/\[.*\]/) ? input.replace(/^\[|\]$/g, "") : input.replace(/\\/g, "")
    }

    function makeFormatFunction(format) {
        var i, length, array = format.match(formattingTokens);
        for (i = 0, length = array.length; length > i; i++) array[i] = formatTokenFunctions[array[i]] ? formatTokenFunctions[array[i]] : removeFormattingTokens(array[i]);
        return function (mom) {
            var output = "";
            for (i = 0; length > i; i++) output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            return output
        }
    }

    function formatMoment(m, format) {
        function replaceLongDateFormatTokens(input) {
            return m.lang().longDateFormat(input) || input
        }
        for (var i = 5; i-- && localFormattingTokens.test(format);) format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        return formatFunctions[format] || (formatFunctions[format] = makeFormatFunction(format)),
            formatFunctions[format](m)
    }

    function getParseRegexForToken(token, config) {
        switch (token) {
            case "DDDD":
                return parseTokenThreeDigits;
            case "YYYY":
                return parseTokenFourDigits;
            case "YYYYY":
                return parseTokenSixDigits;
            case "S":
            case "SS":
            case "SSS":
            case "DDD":
                return parseTokenOneToThreeDigits;
            case "MMM":
            case "MMMM":
            case "dd":
            case "ddd":
            case "dddd":
                return parseTokenWord;
            case "a":
            case "A":
                return getLangDefinition(config._l)._meridiemParse;
            case "X":
                return parseTokenTimestampMs;
            case "Z":
            case "ZZ":
                return parseTokenTimezone;
            case "T":
                return parseTokenT;
            case "MM":
            case "DD":
            case "YY":
            case "HH":
            case "hh":
            case "mm":
            case "ss":
            case "M":
            case "D":
            case "d":
            case "H":
            case "h":
            case "m":
            case "s":
                return parseTokenOneOrTwoDigits;
            default:
                return new RegExp(token.replace("\\", ""))
        }
    }

    function timezoneMinutesFromString(string) {
        var tzchunk = (parseTokenTimezone.exec(string) || [])[0],
            parts = (tzchunk + "").match(parseTimezoneChunker) || ["-", 0, 0],
            minutes = +(60 * parts[1]) + ~~parts[2];
        return "+" === parts[0] ? -minutes : minutes
    }

    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;
        switch (token) {
            case "M":
            case "MM":
                datePartArray[1] = null == input ? 0 : ~~input - 1;
                break;
            case "MMM":
            case "MMMM":
                a = getLangDefinition(config._l).monthsParse(input),
                    null != a ? datePartArray[1] = a : config._isValid = !1;
                break;
            case "D":
            case "DD":
            case "DDD":
            case "DDDD":
                null != input && (datePartArray[2] = ~~input);
                break;
            case "YY":
                datePartArray[0] = ~~input + (~~input > 68 ? 1900 : 2e3);
                break;
            case "YYYY":
            case "YYYYY":
                datePartArray[0] = ~~input;
                break;
            case "a":
            case "A":
                config._isPm = getLangDefinition(config._l).isPM(input);
                break;
            case "H":
            case "HH":
            case "h":
            case "hh":
                datePartArray[3] = ~~input;
                break;
            case "m":
            case "mm":
                datePartArray[4] = ~~input;
                break;
            case "s":
            case "ss":
                datePartArray[5] = ~~input;
                break;
            case "S":
            case "SS":
            case "SSS":
                datePartArray[6] = ~~(1e3 * ("0." + input));
                break;
            case "X":
                config._d = new Date(1e3 * parseFloat(input));
                break;
            case "Z":
            case "ZZ":
                config._useUTC = !0,
                    config._tzm = timezoneMinutesFromString(input)
        }
        null == input && (config._isValid = !1)
    }

    function dateFromArray(config) {
        var i, date, input = [];
        if (!config._d) {
            for (i = 0; 7 > i; i++) config._a[i] = input[i] = null == config._a[i] ? 2 === i ? 1 : 0 : config._a[i];
            input[3] += ~~((config._tzm || 0) / 60),
                input[4] += ~~((config._tzm || 0) % 60),
                date = new Date(0),
                config._useUTC ? (date.setUTCFullYear(input[0], input[1], input[2]), date.setUTCHours(input[3], input[4], input[5], input[6])) : (date.setFullYear(input[0], input[1], input[2]), date.setHours(input[3], input[4], input[5], input[6])),
                config._d = date
        }
    }

    function makeDateFromStringAndFormat(config) {
        var i, parsedInput, tokens = config._f.match(formattingTokens),
            string = config._i;
        for (config._a = [], i = 0; i < tokens.length; i++) parsedInput = (getParseRegexForToken(tokens[i], config).exec(string) || [])[0],
            parsedInput && (string = string.slice(string.indexOf(parsedInput) + parsedInput.length)),
            formatTokenFunctions[tokens[i]] && addTimeToArrayFromToken(tokens[i], parsedInput, config);
        string && (config._il = string),
            config._isPm && config._a[3] < 12 && (config._a[3] += 12),
            config._isPm === !1 && 12 === config._a[3] && (config._a[3] = 0),
            dateFromArray(config)
    }

    function makeDateFromStringAndArray(config) {
        var tempConfig, tempMoment, bestMoment, i, currentScore, scoreToBeat = 99;
        for (i = 0; i < config._f.length; i++) tempConfig = extend({},
                config),
            tempConfig._f = config._f[i],
            makeDateFromStringAndFormat(tempConfig),
            tempMoment = new Moment(tempConfig),
            currentScore = compareArrays(tempConfig._a, tempMoment.toArray()),
            tempMoment._il && (currentScore += tempMoment._il.length),
            scoreToBeat > currentScore && (scoreToBeat = currentScore, bestMoment = tempMoment);
        extend(config, bestMoment)
    }

    function makeDateFromString(config) {
        var i, string = config._i,
            match = isoRegex.exec(string);
        if (match) {
            for (config._f = "YYYY-MM-DD" + (match[2] || " "), i = 0; 4 > i; i++)
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break
                }
            parseTokenTimezone.exec(string) && (config._f += " Z"),
                makeDateFromStringAndFormat(config)
        } else config._d = new Date(string)
    }

    function makeDateFromInput(config) {
        var input = config._i,
            matched = aspNetJsonRegex.exec(input);
        input === undefined ? config._d = new Date : matched ? config._d = new Date(+matched[1]) : "string" == typeof input ? makeDateFromString(config) : isArray(input) ? (config._a = input.slice(0), dateFromArray(config)) : config._d = new Date(input instanceof Date ? +input : input)
    }

    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture)
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1e3),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = 45 > seconds && ["s", seconds] || 1 === minutes && ["m"] || 45 > minutes && ["mm", minutes] || 1 === hours && ["h"] || 22 > hours && ["hh", hours] || 1 === days && ["d"] || 25 >= days && ["dd", days] || 45 >= days && ["M"] || 345 > days && ["MM", round(days / 30)] || 1 === years && ["y"] || ["yy", years];
        return args[2] = withoutSuffix,
            args[3] = milliseconds > 0,
            args[4] = lang,
            substituteTimeAgo.apply({},
                args)
    }

    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var adjustedMoment, end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day();
        return daysToDayOfWeek > end && (daysToDayOfWeek -= 7),
            end - 7 > daysToDayOfWeek && (daysToDayOfWeek += 7),
            adjustedMoment = moment(mom).add("d", daysToDayOfWeek), {
                week: Math.ceil(adjustedMoment.dayOfYear() / 7),
                year: adjustedMoment.year()
            }
    }

    function makeMoment(config) {
        var input = config._i,
            format = config._f;
        return null === input || "" === input ? null : ("string" == typeof input && (config._i = input = getLangDefinition().preparse(input)), moment.isMoment(input) ? (config = extend({},
            input), config._d = new Date(+input._d)) : format ? isArray(format) ? makeDateFromStringAndArray(config) : makeDateFromStringAndFormat(config) : makeDateFromInput(config), new Moment(config))
    }

    function makeGetterAndSetter(name, key) {
        moment.fn[name] = moment.fn[name + "s"] = function (input) {
            var utc = this._isUTC ? "UTC" : "";
            return null != input ? (this._d["set" + utc + key](input), moment.updateOffset(this), this) : this._d["get" + utc + key]()
        }
    }

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name]
        }
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn["as" + name] = function () {
            return +this / factor
        }
    }
    for (var moment, i, VERSION = "2.1.0",
            round = Math.round,
            languages = {},
            hasModule = "undefined" != typeof module && module.exports,
            aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
            aspNetTimeSpanJsonRegex = /(\-)?(\d*)?\.?(\d+)\:(\d+)\:(\d+)\.?(\d{3})?/,
            formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|SS?S?|X|zz?|ZZ?|.)/g,
            localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,
            parseTokenOneOrTwoDigits = /\d\d?/,
            parseTokenOneToThreeDigits = /\d{1,3}/,
            parseTokenThreeDigits = /\d{3}/,
            parseTokenFourDigits = /\d{1,4}/,
            parseTokenSixDigits = /[+\-]?\d{1,6}/,
            parseTokenWord = /[0-9]*['a-z -׿܀-퟿豈-﷏ﷰ-￯]+|[؀-ۿ\/]+(\s*?[؀-ۿ]+){1,2}/i,
            parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/i,
            parseTokenT = /T/i,
            parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/,
            isoRegex = /^\s*\d{4}-\d\d-\d\d((T| )(\d\d(:\d\d(:\d\d(\.\d\d?\d?)?)?)?)?([\+\-]\d\d:?\d\d)?)?/,
            isoFormat = "YYYY-MM-DDTHH:mm:ssZ",
            isoTimes = [
                ["HH:mm:ss.S", /(T| )\d\d:\d\d:\d\d\.\d{1,3}/],
                ["HH:mm:ss", /(T| )\d\d:\d\d:\d\d/],
                ["HH:mm", /(T| )\d\d:\d\d/],
                ["HH", /(T| )\d\d/]
            ], parseTimezoneChunker = /([\+\-]|\d\d)/gi, proxyGettersAndSetters = "Date|Hours|Minutes|Seconds|Milliseconds".split("|"), unitMillisecondFactors = {
                Milliseconds: 1,
                Seconds: 1e3,
                Minutes: 6e4,
                Hours: 36e5,
                Days: 864e5,
                Months: 2592e6,
                Years: 31536e6
            },
            unitAliases = {
                ms: "millisecond",
                s: "second",
                m: "minute",
                h: "hour",
                d: "day",
                w: "week",
                M: "month",
                y: "year"
            },
            formatFunctions = {},
            ordinalizeTokens = "DDD w W M D d".split(" "), paddedTokens = "M D H h m s w W".split(" "), formatTokenFunctions = {
                M: function () {
                    return this.month() + 1
                },
                MMM: function (format) {
                    return this.lang().monthsShort(this, format)
                },
                MMMM: function (format) {
                    return this.lang().months(this, format)
                },
                D: function () {
                    return this.date()
                },
                DDD: function () {
                    return this.dayOfYear()
                },
                d: function () {
                    return this.day()
                },
                dd: function (format) {
                    return this.lang().weekdaysMin(this, format)
                },
                ddd: function (format) {
                    return this.lang().weekdaysShort(this, format)
                },
                dddd: function (format) {
                    return this.lang().weekdays(this, format)
                },
                w: function () {
                    return this.week()
                },
                W: function () {
                    return this.isoWeek()
                },
                YY: function () {
                    return leftZeroFill(this.year() % 100, 2)
                },
                YYYY: function () {
                    return leftZeroFill(this.year(), 4)
                },
                YYYYY: function () {
                    return leftZeroFill(this.year(), 5)
                },
                gg: function () {
                    return leftZeroFill(this.weekYear() % 100, 2)
                },
                gggg: function () {
                    return this.weekYear()
                },
                ggggg: function () {
                    return leftZeroFill(this.weekYear(), 5)
                },
                GG: function () {
                    return leftZeroFill(this.isoWeekYear() % 100, 2)
                },
                GGGG: function () {
                    return this.isoWeekYear()
                },
                GGGGG: function () {
                    return leftZeroFill(this.isoWeekYear(), 5)
                },
                e: function () {
                    return this.weekday()
                },
                E: function () {
                    return this.isoWeekday()
                },
                a: function () {
                    return this.lang().meridiem(this.hours(), this.minutes(), !0)
                },
                A: function () {
                    return this.lang().meridiem(this.hours(), this.minutes(), !1)
                },
                H: function () {
                    return this.hours()
                },
                h: function () {
                    return this.hours() % 12 || 12
                },
                m: function () {
                    return this.minutes()
                },
                s: function () {
                    return this.seconds()
                },
                S: function () {
                    return ~~(this.milliseconds() / 100)
                },
                SS: function () {
                    return leftZeroFill(~~(this.milliseconds() / 10), 2)
                },
                SSS: function () {
                    return leftZeroFill(this.milliseconds(), 3)
                },
                Z: function () {
                    var a = -this.zone(),
                        b = "+";
                    return 0 > a && (a = -a, b = "-"),
                        b + leftZeroFill(~~(a / 60), 2) + ":" + leftZeroFill(~~a % 60, 2)
                },
                ZZ: function () {
                    var a = -this.zone(),
                        b = "+";
                    return 0 > a && (a = -a, b = "-"),
                        b + leftZeroFill(~~(10 * a / 6), 4)
                },
                z: function () {
                    return this.zoneAbbr()
                },
                zz: function () {
                    return this.zoneName()
                },
                X: function () {
                    return this.unix()
                }
            }; ordinalizeTokens.length;) i = ordinalizeTokens.pop(),
        formatTokenFunctions[i + "o"] = ordinalizeToken(formatTokenFunctions[i], i);
    for (; paddedTokens.length;) i = paddedTokens.pop(),
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    for (formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3), Language.prototype = {
            set: function (config) {
                var prop, i;
                for (i in config) prop = config[i],
                    "function" == typeof prop ? this[i] = prop : this["_" + i] = prop
            },
            _months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            months: function (m) {
                return this._months[m.month()]
            },
            _monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            monthsShort: function (m) {
                return this._monthsShort[m.month()]
            },
            monthsParse: function (monthName) {
                var i, mom, regex;
                for (this._monthsParse || (this._monthsParse = []), i = 0; 12 > i; i++)
                    if (this._monthsParse[i] || (mom = moment([2e3, i]), regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, ""), this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i")), this._monthsParse[i].test(monthName)) return i
            },
            _weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdays: function (m) {
                return this._weekdays[m.day()]
            },
            _weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysShort: function (m) {
                return this._weekdaysShort[m.day()]
            },
            _weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            weekdaysMin: function (m) {
                return this._weekdaysMin[m.day()]
            },
            weekdaysParse: function (weekdayName) {
                var i, mom, regex;
                for (this._weekdaysParse || (this._weekdaysParse = []), i = 0; 7 > i; i++)
                    if (this._weekdaysParse[i] || (mom = moment([2e3, 1]).day(i), regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, ""), this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i")), this._weekdaysParse[i].test(weekdayName)) return i
            },
            _longDateFormat: {
                LT: "h:mm A",
                L: "MM/DD/YYYY",
                LL: "MMMM D YYYY",
                LLL: "MMMM D YYYY LT",
                LLLL: "dddd, MMMM D YYYY LT"
            },
            longDateFormat: function (key) {
                var output = this._longDateFormat[key];
                return !output && this._longDateFormat[key.toUpperCase()] && (output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g,
                        function (val) {
                            return val.slice(1)
                        }), this._longDateFormat[key] = output),
                    output
            },
            isPM: function (input) {
                return "p" === (input + "").toLowerCase()[0]
            },
            _meridiemParse: /[ap]\.?m?\.?/i,
            meridiem: function (hours, minutes, isLower) {
                return hours > 11 ? isLower ? "pm" : "PM" : isLower ? "am" : "AM"
            },
            _calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            calendar: function (key, mom) {
                var output = this._calendar[key];
                return "function" == typeof output ? output.apply(mom) : output
            },
            _relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            relativeTime: function (number, withoutSuffix, string, isFuture) {
                var output = this._relativeTime[string];
                return "function" == typeof output ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number)
            },
            pastFuture: function (diff, output) {
                var format = this._relativeTime[diff > 0 ? "future" : "past"];
                return "function" == typeof format ? format(output) : format.replace(/%s/i, output)
            },
            ordinal: function (number) {
                return this._ordinal.replace("%d", number)
            },
            _ordinal: "%d",
            preparse: function (string) {
                return string
            },
            postformat: function (string) {
                return string
            },
            week: function (mom) {
                return weekOfYear(mom, this._week.dow, this._week.doy).week
            },
            _week: {
                dow: 0,
                doy: 6
            }
        },
        moment = function (input, format, lang) {
            return makeMoment({
                _i: input,
                _f: format,
                _l: lang,
                _isUTC: !1
            })
        },
        moment.utc = function (input, format, lang) {
            return makeMoment({
                _useUTC: !0,
                _isUTC: !0,
                _l: lang,
                _i: input,
                _f: format
            })
        },
        moment.unix = function (input) {
            return moment(1e3 * input)
        },
        moment.duration = function (input, key) {
            var sign, ret, isDuration = moment.isDuration(input),
                isNumber = "number" == typeof input,
                duration = isDuration ? input._input : isNumber ? {} : input,
                matched = aspNetTimeSpanJsonRegex.exec(input);
            return isNumber ? key ? duration[key] = input : duration.milliseconds = input : matched && (sign = "-" === matched[1] ? -1 : 1, duration = {
                    y: 0,
                    d: ~~matched[2] * sign,
                    h: ~~matched[3] * sign,
                    m: ~~matched[4] * sign,
                    s: ~~matched[5] * sign,
                    ms: ~~matched[6] * sign
                }),
                ret = new Duration(duration),
                isDuration && input.hasOwnProperty("_lang") && (ret._lang = input._lang),
                ret
        },
        moment.version = VERSION, moment.defaultFormat = isoFormat, moment.updateOffset = function () {},
        moment.lang = function (key, values) {
            return key ? (values ? loadLang(key, values) : languages[key] || getLangDefinition(key), void(moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key))) : moment.fn._lang._abbr
        },
        moment.langData = function (key) {
            return key && key._lang && key._lang._abbr && (key = key._lang._abbr),
                getLangDefinition(key)
        },
        moment.isMoment = function (obj) {
            return obj instanceof Moment
        },
        moment.isDuration = function (obj) {
            return obj instanceof Duration
        },
        moment.fn = Moment.prototype = {
            clone: function () {
                return moment(this)
            },
            valueOf: function () {
                return +this._d + 6e4 * (this._offset || 0)
            },
            unix: function () {
                return Math.floor(+this / 1e3)
            },
            toString: function () {
                return this.format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
            },
            toDate: function () {
                return this._offset ? new Date(+this) : this._d
            },
            toISOString: function () {
                return formatMoment(moment(this).utc(), "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]")
            },
            toArray: function () {
                var m = this;
                return [m.year(), m.month(), m.date(), m.hours(), m.minutes(), m.seconds(), m.milliseconds()]
            },
            isValid: function () {
                return null == this._isValid && (this._isValid = this._a ? !compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) : !isNaN(this._d.getTime())), !!this._isValid
            },
            utc: function () {
                return this.zone(0)
            },
            local: function () {
                return this.zone(0),
                    this._isUTC = !1,
                    this
            },
            format: function (inputString) {
                var output = formatMoment(this, inputString || moment.defaultFormat);
                return this.lang().postformat(output)
            },
            add: function (input, val) {
                var dur;
                return dur = "string" == typeof input ? moment.duration(+val, input) : moment.duration(input, val),
                    addOrSubtractDurationFromMoment(this, dur, 1),
                    this
            },
            subtract: function (input, val) {
                var dur;
                return dur = "string" == typeof input ? moment.duration(+val, input) : moment.duration(input, val),
                    addOrSubtractDurationFromMoment(this, dur, -1),
                    this
            },
            diff: function (input, units, asFloat) {
                var diff, output, that = this._isUTC ? moment(input).zone(this._offset || 0) : moment(input).local(),
                    zoneDiff = 6e4 * (this.zone() - that.zone());
                return units = normalizeUnits(units),
                    "year" === units || "month" === units ? (diff = 432e5 * (this.daysInMonth() + that.daysInMonth()), output = 12 * (this.year() - that.year()) + (this.month() - that.month()), output += (this - moment(this).startOf("month") - (that - moment(that).startOf("month"))) / diff, output -= 6e4 * (this.zone() - moment(this).startOf("month").zone() - (that.zone() - moment(that).startOf("month").zone())) / diff, "year" === units && (output /= 12)) : (diff = this - that, output = "second" === units ? diff / 1e3 : "minute" === units ? diff / 6e4 : "hour" === units ? diff / 36e5 : "day" === units ? (diff - zoneDiff) / 864e5 : "week" === units ? (diff - zoneDiff) / 6048e5 : diff),
                    asFloat ? output : absRound(output)
            },
            from: function (time, withoutSuffix) {
                return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix)
            },
            fromNow: function (withoutSuffix) {
                return this.from(moment(), withoutSuffix)
            },
            calendar: function () {
                var diff = this.diff(moment().startOf("day"), "days", !0),
                    format = -6 > diff ? "sameElse" : -1 > diff ? "lastWeek" : 0 > diff ? "lastDay" : 1 > diff ? "sameDay" : 2 > diff ? "nextDay" : 7 > diff ? "nextWeek" : "sameElse";
                return this.format(this.lang().calendar(format, this))
            },
            isLeapYear: function () {
                var year = this.year();
                return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0
            },
            isDST: function () {
                return this.zone() < this.clone().month(0).zone() || this.zone() < this.clone().month(5).zone()
            },
            day: function (input) {
                var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
                return null != input ? "string" == typeof input && (input = this.lang().weekdaysParse(input), "number" != typeof input) ? this : this.add({
                    d: input - day
                }) : day
            },
            month: function (input) {
                var dayOfMonth, utc = this._isUTC ? "UTC" : "";
                return null != input ? "string" == typeof input && (input = this.lang().monthsParse(input), "number" != typeof input) ? this : (dayOfMonth = this.date(), this.date(1), this._d["set" + utc + "Month"](input), this.date(Math.min(dayOfMonth, this.daysInMonth())), moment.updateOffset(this), this) : this._d["get" + utc + "Month"]()
            },
            startOf: function (units) {
                switch (units = normalizeUnits(units)) {
                    case "year":
                        this.month(0);
                    case "month":
                        this.date(1);
                    case "week":
                    case "day":
                        this.hours(0);
                    case "hour":
                        this.minutes(0);
                    case "minute":
                        this.seconds(0);
                    case "second":
                        this.milliseconds(0)
                }
                return "week" === units && this.weekday(0),
                    this
            },
            endOf: function (units) {
                return this.startOf(units).add(units, 1).subtract("ms", 1)
            },
            isAfter: function (input, units) {
                return units = "undefined" != typeof units ? units : "millisecond", +this.clone().startOf(units) > +moment(input).startOf(units)
            },
            isBefore: function (input, units) {
                return units = "undefined" != typeof units ? units : "millisecond", +this.clone().startOf(units) < +moment(input).startOf(units)
            },
            isSame: function (input, units) {
                return units = "undefined" != typeof units ? units : "millisecond", +this.clone().startOf(units) === +moment(input).startOf(units)
            },
            min: function (other) {
                return other = moment.apply(null, arguments),
                    this > other ? this : other
            },
            max: function (other) {
                return other = moment.apply(null, arguments),
                    other > this ? this : other
            },
            zone: function (input) {
                var offset = this._offset || 0;
                return null == input ? this._isUTC ? offset : this._d.getTimezoneOffset() : ("string" == typeof input && (input = timezoneMinutesFromString(input)), Math.abs(input) < 16 && (input = 60 * input), this._offset = input, this._isUTC = !0, offset !== input && addOrSubtractDurationFromMoment(this, moment.duration(offset - input, "m"), 1, !0), this)
            },
            zoneAbbr: function () {
                return this._isUTC ? "UTC" : ""
            },
            zoneName: function () {
                return this._isUTC ? "Coordinated Universal Time" : ""
            },
            daysInMonth: function () {
                return moment.utc([this.year(), this.month() + 1, 0]).date()
            },
            dayOfYear: function (input) {
                var dayOfYear = round((moment(this).startOf("day") - moment(this).startOf("year")) / 864e5) + 1;
                return null == input ? dayOfYear : this.add("d", input - dayOfYear)
            },
            weekYear: function (input) {
                var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
                return null == input ? year : this.add("y", input - year)
            },
            isoWeekYear: function (input) {
                var year = weekOfYear(this, 1, 4).year;
                return null == input ? year : this.add("y", input - year)
            },
            week: function (input) {
                var week = this.lang().week(this);
                return null == input ? week : this.add("d", 7 * (input - week))
            },
            isoWeek: function (input) {
                var week = weekOfYear(this, 1, 4).week;
                return null == input ? week : this.add("d", 7 * (input - week))
            },
            weekday: function (input) {
                var weekday = (this._d.getDay() + 7 - this.lang()._week.dow) % 7;
                return null == input ? weekday : this.add("d", input - weekday)
            },
            isoWeekday: function (input) {
                return null == input ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7)
            },
            lang: function (key) {
                return key === undefined ? this._lang : (this._lang = getLangDefinition(key), this)
            }
        },
        i = 0; i < proxyGettersAndSetters.length; i++) makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase().replace(/s$/, ""), proxyGettersAndSetters[i]);
    makeGetterAndSetter("year", "FullYear"),
        moment.fn.days = moment.fn.day,
        moment.fn.months = moment.fn.month,
        moment.fn.weeks = moment.fn.week,
        moment.fn.isoWeeks = moment.fn.isoWeek,
        moment.fn.toJSON = moment.fn.toISOString,
        moment.duration.fn = Duration.prototype = {
            _bubble: function () {
                var seconds, minutes, hours, years, milliseconds = this._milliseconds,
                    days = this._days,
                    months = this._months,
                    data = this._data;
                data.milliseconds = milliseconds % 1e3,
                    seconds = absRound(milliseconds / 1e3),
                    data.seconds = seconds % 60,
                    minutes = absRound(seconds / 60),
                    data.minutes = minutes % 60,
                    hours = absRound(minutes / 60),
                    data.hours = hours % 24,
                    days += absRound(hours / 24),
                    data.days = days % 30,
                    months += absRound(days / 30),
                    data.months = months % 12,
                    years = absRound(months / 12),
                    data.years = years
            },
            weeks: function () {
                return absRound(this.days() / 7)
            },
            valueOf: function () {
                return this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * ~~(this._months / 12)
            },
            humanize: function (withSuffix) {
                var difference = +this,
                    output = relativeTime(difference, !withSuffix, this.lang());
                return withSuffix && (output = this.lang().pastFuture(difference, output)),
                    this.lang().postformat(output)
            },
            add: function (input, val) {
                var dur = moment.duration(input, val);
                return this._milliseconds += dur._milliseconds,
                    this._days += dur._days,
                    this._months += dur._months,
                    this._bubble(),
                    this
            },
            subtract: function (input, val) {
                var dur = moment.duration(input, val);
                return this._milliseconds -= dur._milliseconds,
                    this._days -= dur._days,
                    this._months -= dur._months,
                    this._bubble(),
                    this
            },
            get: function (units) {
                return units = normalizeUnits(units),
                    this[units.toLowerCase() + "s"]()
            },
            as: function (units) {
                return units = normalizeUnits(units),
                    this["as" + units.charAt(0).toUpperCase() + units.slice(1) + "s"]()
            },
            lang: moment.fn.lang
        };
    for (i in unitMillisecondFactors) unitMillisecondFactors.hasOwnProperty(i) && (makeDurationAsGetter(i, unitMillisecondFactors[i]), makeDurationGetter(i.toLowerCase()));
    makeDurationAsGetter("Weeks", 6048e5),
        moment.duration.fn.asMonths = function () {
            return (+this - 31536e6 * this.years()) / 2592e6 + 12 * this.years()
        },
        moment.lang("en", {
            ordinal: function (number) {
                var b = number % 10,
                    output = 1 === ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th";
                return number + output
            }
        }),
        hasModule && (module.exports = moment),
        "undefined" == typeof ender && (this.moment = moment),
        "function" == typeof define && define.amd && define("moment", [],
            function () {
                return moment
            })
}).call(this);
var UUID;
UUID = function (overwrittenUUID) {
        function UUID() {}
        return UUID.generate = function () {
                var rand = UUID._getRandomInt,
                    hex = UUID._hexAligner;
                return hex(rand(32), 8) + "-" + hex(rand(16), 4) + "-" + hex(16384 | rand(12), 4) + "-" + hex(32768 | rand(14), 4) + "-" + hex(rand(48), 12)
            },
            UUID._getRandomInt = function (x) {
                return 0 > x ? 0 / 0 : 30 >= x ? 0 | Math.random() * (1 << x) : 53 >= x ? (0 | Math.random() * (1 << 30)) + (0 | Math.random() * (1 << x - 30)) * (1 << 30) : 0 / 0
            },
            UUID._getIntAligner = function (radix) {
                return function (num, length) {
                    for (var str = num.toString(radix), i = length - str.length, z = "0"; i > 0; i >>>= 1, z += z) 1 & i && (str = z + str);
                    return str
                }
            },
            UUID._hexAligner = UUID._getIntAligner(16),
            UUID.FIELD_NAMES = ["timeLow", "timeMid", "timeHiAndVersion", "clockSeqHiAndReserved", "clockSeqLow", "node"],
            UUID.FIELD_SIZES = [32, 16, 16, 8, 8, 48],
            UUID.genV4 = function () {
                var rand = UUID._getRandomInt;
                return (new UUID)._init(rand(32), rand(16), 16384 | rand(12), 128 | rand(6), rand(8), rand(48))
            },
            UUID.parse = function (strId) {
                var r, p = /^\s*(urn:uuid:|\{)?([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{2})([0-9a-f]{2})-([0-9a-f]{12})(\})?\s*$/i;
                if (r = p.exec(strId)) {
                    var l = r[1] || "",
                        t = r[8] || "";
                    if (l + t === "" || "{" === l && "}" === t || "urn:uuid:" === l.toLowerCase() && "" === t) return (new UUID)._init(parseInt(r[2], 16), parseInt(r[3], 16), parseInt(r[4], 16), parseInt(r[5], 16), parseInt(r[6], 16), parseInt(r[7], 16))
                }
                return null
            },
            UUID.prototype._init = function () {
                var names = UUID.FIELD_NAMES,
                    sizes = UUID.FIELD_SIZES,
                    bin = UUID._binAligner,
                    hex = UUID._hexAligner;
                this.intFields = new Array(6),
                    this.bitFields = new Array(6),
                    this.hexFields = new Array(6);
                for (var i = 0; 6 > i; i++) {
                    var intValue = parseInt(arguments[i] || 0);
                    this.intFields[i] = this.intFields[names[i]] = intValue,
                        this.bitFields[i] = this.bitFields[names[i]] = bin(intValue, sizes[i]),
                        this.hexFields[i] = this.hexFields[names[i]] = hex(intValue, sizes[i] / 4)
                }
                return this.version = this.intFields.timeHiAndVersion >> 12 & 15,
                    this.bitString = this.bitFields.join(""),
                    this.hexString = this.hexFields[0] + "-" + this.hexFields[1] + "-" + this.hexFields[2] + "-" + this.hexFields[3] + this.hexFields[4] + "-" + this.hexFields[5],
                    this.urn = "urn:uuid:" + this.hexString,
                    this
            },
            UUID._binAligner = UUID._getIntAligner(2),
            UUID.prototype.toString = function () {
                return this.hexString
            },
            UUID.prototype.equals = function (uuid) {
                if (!(uuid instanceof UUID)) return !1;
                for (var i = 0; 6 > i; i++)
                    if (this.intFields[i] !== uuid.intFields[i]) return !1;
                return !0
            },
            UUID.genV1 = function () {
                var now = (new Date).getTime(),
                    st = UUID._state;
                now != st.timestamp ? (now < st.timestamp && st.sequence++, st.timestamp = now, st.tick = UUID._getRandomInt(4)) : Math.random() < UUID._tsRatio && st.tick < 9984 ? st.tick += 1 + UUID._getRandomInt(4) : st.sequence++;
                var tf = UUID._getTimeFieldValues(st.timestamp),
                    tl = tf.low + st.tick,
                    thav = 4095 & tf.hi | 4096;
                st.sequence &= 16383;
                var cshar = st.sequence >>> 8 | 128,
                    csl = 255 & st.sequence;
                return (new UUID)._init(tl, tf.mid, thav, cshar, csl, st.node)
            },
            UUID.resetState = function () {
                UUID._state = new UUID._state.constructor
            },
            UUID._tsRatio = .25,
            UUID._state = new

        function () {
            var rand = UUID._getRandomInt;
            this.timestamp = 0,
                this.sequence = rand(14),
                this.node = 1099511627776 * (1 | rand(8)) + rand(40),
                this.tick = rand(4)
        },
        UUID._getTimeFieldValues = function (time) {
                var ts = time - Date.UTC(1582, 9, 15),
                    hm = ts / 4294967296 * 1e4 & 268435455;
                return {
                    low: 1e4 * (268435455 & ts) % 4294967296,
                    mid: 65535 & hm,
                    hi: hm >>> 16,
                    timestamp: ts
                }
            },
            UUID.makeBackwardCompatible = function () {
                var f = UUID.generate;
                UUID.generate = function (o) {
                        return o && 1 == o.version ? UUID.genV1().hexString : f.call(UUID)
                    },
                    UUID.makeBackwardCompatible = function () {}
            },
            UUID.overwrittenUUID = overwrittenUUID,
            UUID
    }(UUID),
    window.Modernizr = function (window, document, undefined) {
        function setCss(str) {
            mStyle.cssText = str
        }

        function setCssAll(str1, str2) {
            return setCss(prefixes.join(str1 + ";") + (str2 || ""))
        }

        function is(obj, type) {
            return typeof obj === type
        }

        function contains(str, substr) {
            return !!~("" + str).indexOf(substr)
        }

        function testProps(props, prefixed) {
            for (var i in props) {
                var prop = props[i];
                if (!contains(prop, "-") && mStyle[prop] !== undefined) return "pfx" == prefixed ? prop : !0
            }
            return !1
        }

        function testDOMProps(props, obj, elem) {
            for (var i in props) {
                var item = obj[props[i]];
                if (item !== undefined) return elem === !1 ? props[i] : is(item, "function") ? item.bind(elem || obj) : item
            }
            return !1
        }

        function testPropsAll(prop, prefixed, elem) {
            var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),
                props = (prop + " " + cssomPrefixes.join(ucProp + " ") + ucProp).split(" ");
            return is(prefixed, "string") || is(prefixed, "undefined") ? testProps(props, prefixed) : (props = (prop + " " + domPrefixes.join(ucProp + " ") + ucProp).split(" "), testDOMProps(props, prefixed, elem))
        }

        function webforms() {
            Modernizr.input = function (props) {
                    for (var i = 0,
                            len = props.length; len > i; i++) attrs[props[i]] = !!(props[i] in inputElem);
                    return attrs.list && (attrs.list = !(!document.createElement("datalist") || !window.HTMLDataListElement)),
                        attrs
                }("autocomplete autofocus list placeholder max min multiple pattern required step".split(" ")),
                Modernizr.inputtypes = function (props) {
                    for (var bool, inputElemType, defaultView, i = 0,
                            len = props.length; len > i; i++) inputElem.setAttribute("type", inputElemType = props[i]),
                        bool = "text" !== inputElem.type,
                        bool && (inputElem.value = smile, inputElem.style.cssText = "position:absolute;visibility:hidden;", /^range$/.test(inputElemType) && inputElem.style.WebkitAppearance !== undefined ? (docElement.appendChild(inputElem), defaultView = document.defaultView, bool = defaultView.getComputedStyle && "textfield" !== defaultView.getComputedStyle(inputElem, null).WebkitAppearance && 0 !== inputElem.offsetHeight, docElement.removeChild(inputElem)) : /^(search|tel)$/.test(inputElemType) || (bool = /^(url|email)$/.test(inputElemType) ? inputElem.checkValidity && inputElem.checkValidity() === !1 : inputElem.value != smile)),
                        inputs[props[i]] = !!bool;
                    return inputs
                }("search tel url email datetime date month week time datetime-local number range color".split(" "))
        }
        var featureName, hasOwnProp, version = "2.6.2",
            Modernizr = {},
            enableClasses = !0,
            docElement = document.documentElement,
            mod = "modernizr",
            modElem = document.createElement(mod),
            mStyle = modElem.style,
            inputElem = document.createElement("input"),
            smile = ":)",
            toString = {}.toString,
            prefixes = " -webkit- -moz- -o- -ms- ".split(" "),
            omPrefixes = "Webkit Moz O ms",
            cssomPrefixes = omPrefixes.split(" "),
            domPrefixes = omPrefixes.toLowerCase().split(" "),
            ns = {
                svg: "http://www.w3.org/2000/svg"
            },
            tests = {},
            inputs = {},
            attrs = {},
            classes = [],
            slice = classes.slice,
            injectElementWithStyles = function (rule, callback, nodes, testnames) {
                var style, ret, node, docOverflow, div = document.createElement("div"),
                    body = document.body,
                    fakeBody = body || document.createElement("body");
                if (parseInt(nodes, 10))
                    for (; nodes--;) node = document.createElement("div"),
                        node.id = testnames ? testnames[nodes] : mod + (nodes + 1),
                        div.appendChild(node);
                return style = ["&#173;", '<style id="s', mod, '">', rule, "</style>"].join(""),
                    div.id = mod,
                    (body ? div : fakeBody).innerHTML += style,
                    fakeBody.appendChild(div),
                    body || (fakeBody.style.background = "", fakeBody.style.overflow = "hidden", docOverflow = docElement.style.overflow, docElement.style.overflow = "hidden", docElement.appendChild(fakeBody)),
                    ret = callback(div, rule),
                    body ? div.parentNode.removeChild(div) : (fakeBody.parentNode.removeChild(fakeBody), docElement.style.overflow = docOverflow), !!ret
            },
            testMediaQuery = function (mq) {
                var matchMedia = window.matchMedia || window.msMatchMedia;
                if (matchMedia) return matchMedia(mq).matches;
                var bool;
                return injectElementWithStyles("@media " + mq + " { #" + mod + " { position: absolute; } }",
                        function (node) {
                            bool = "absolute" == (window.getComputedStyle ? getComputedStyle(node, null) : node.currentStyle).position
                        }),
                    bool
            },
            isEventSupported = function () {
                function isEventSupported(eventName, element) {
                    element = element || document.createElement(TAGNAMES[eventName] || "div"),
                        eventName = "on" + eventName;
                    var isSupported = eventName in element;
                    return isSupported || (element.setAttribute || (element = document.createElement("div")), element.setAttribute && element.removeAttribute && (element.setAttribute(eventName, ""), isSupported = is(element[eventName], "function"), is(element[eventName], "undefined") || (element[eventName] = undefined), element.removeAttribute(eventName))),
                        element = null,
                        isSupported
                }
                var TAGNAMES = {
                    select: "input",
                    change: "input",
                    submit: "form",
                    reset: "form",
                    error: "img",
                    load: "img",
                    abort: "img"
                };
                return isEventSupported
            }(),
            _hasOwnProperty = {}.hasOwnProperty;
        hasOwnProp = is(_hasOwnProperty, "undefined") || is(_hasOwnProperty.call, "undefined") ?
            function (object, property) {
                return property in object && is(object.constructor.prototype[property], "undefined")
            } : function (object, property) {
                return _hasOwnProperty.call(object, property)
            },
            Function.prototype.bind || (Function.prototype.bind = function (that) {
                var target = this;
                if ("function" != typeof target) throw new TypeError;
                var args = slice.call(arguments, 1),
                    bound = function () {
                        if (this instanceof bound) {
                            var F = function () {};
                            F.prototype = target.prototype;
                            var self = new F,
                                result = target.apply(self, args.concat(slice.call(arguments)));
                            return Object(result) === result ? result : self
                        }
                        return target.apply(that, args.concat(slice.call(arguments)))
                    };
                return bound
            }),
            tests.flexbox = function () {
                return testPropsAll("flexWrap")
            },
            tests.flexboxlegacy = function () {
                return testPropsAll("boxDirection")
            },
            tests.canvas = function () {
                var elem = document.createElement("canvas");
                return !(!elem.getContext || !elem.getContext("2d"))
            },
            tests.canvastext = function () {
                return !(!Modernizr.canvas || !is(document.createElement("canvas").getContext("2d").fillText, "function"))
            },
            tests.webgl = function () {
                return !!window.WebGLRenderingContext
            },
            tests.touch = function () {
                var bool;
                return "ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch ? bool = !0 : injectElementWithStyles(["@media (", prefixes.join("touch-enabled),("), mod, ")", "{#modernizr{top:9px;position:absolute}}"].join(""),
                        function (node) {
                            bool = 9 === node.offsetTop
                        }),
                    bool
            },
            tests.geolocation = function () {
                return "geolocation" in navigator
            },
            tests.postmessage = function () {
                return !!window.postMessage
            },
            tests.websqldatabase = function () {
                return !!window.openDatabase
            },
            tests.indexedDB = function () {
                return !!testPropsAll("indexedDB", window)
            },
            tests.hashchange = function () {
                return isEventSupported("hashchange", window) && (document.documentMode === undefined || document.documentMode > 7)
            },
            tests.history = function () {
                return !(!window.history || !history.pushState)
            },
            tests.draganddrop = function () {
                var div = document.createElement("div");
                return "draggable" in div || "ondragstart" in div && "ondrop" in div
            },
            tests.websockets = function () {
                return "WebSocket" in window || "MozWebSocket" in window
            },
            tests.rgba = function () {
                return setCss("background-color:rgba(150,255,150,.5)"),
                    contains(mStyle.backgroundColor, "rgba")
            },
            tests.hsla = function () {
                return setCss("background-color:hsla(120,40%,100%,.5)"),
                    contains(mStyle.backgroundColor, "rgba") || contains(mStyle.backgroundColor, "hsla")
            },
            tests.multiplebgs = function () {
                return setCss("background:url(https://),url(https://),red url(https://)"),
                    /(url\s*\(.*?){3}/.test(mStyle.background)
            },
            tests.backgroundsize = function () {
                return testPropsAll("backgroundSize")
            },
            tests.borderimage = function () {
                return testPropsAll("borderImage")
            },
            tests.borderradius = function () {
                return testPropsAll("borderRadius")
            },
            tests.boxshadow = function () {
                return testPropsAll("boxShadow")
            },
            tests.textshadow = function () {
                return "" === document.createElement("div").style.textShadow
            },
            tests.opacity = function () {
                return setCssAll("opacity:.55"),
                    /^0.55$/.test(mStyle.opacity)
            },
            tests.cssanimations = function () {
                return testPropsAll("animationName")
            },
            tests.csscolumns = function () {
                return testPropsAll("columnCount")
            },
            tests.cssgradients = function () {
                var str1 = "background-image:",
                    str2 = "gradient(linear,left top,right bottom,from(#9f9),to(white));",
                    str3 = "linear-gradient(left top,#9f9, white);";
                return setCss((str1 + "-webkit- ".split(" ").join(str2 + str1) + prefixes.join(str3 + str1)).slice(0, -str1.length)),
                    contains(mStyle.backgroundImage, "gradient")
            },
            tests.cssreflections = function () {
                return testPropsAll("boxReflect")
            },
            tests.csstransforms = function () {
                return !!testPropsAll("transform")
            },
            tests.csstransforms3d = function () {
                var ret = !!testPropsAll("perspective");
                return ret && "webkitPerspective" in docElement.style && injectElementWithStyles("@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}",
                        function (node) {
                            ret = 9 === node.offsetLeft && 3 === node.offsetHeight
                        }),
                    ret
            },
            tests.csstransitions = function () {
                return testPropsAll("transition")
            },
            tests.fontface = function () {
                var bool;
                return injectElementWithStyles('@font-face {font-family:"font";src:url("https://")}',
                        function (node, rule) {
                            var style = document.getElementById("smodernizr"),
                                sheet = style.sheet || style.styleSheet,
                                cssText = sheet ? sheet.cssRules && sheet.cssRules[0] ? sheet.cssRules[0].cssText : sheet.cssText || "" : "";
                            bool = /src/i.test(cssText) && 0 === cssText.indexOf(rule.split(" ")[0])
                        }),
                    bool
            },
            tests.generatedcontent = function () {
                var bool;
                return injectElementWithStyles(["#", mod, "{font:0/0 a}#", mod, ':after{content:"', smile, '";visibility:hidden;font:3px/1 a}'].join(""),
                        function (node) {
                            bool = node.offsetHeight >= 3
                        }),
                    bool
            },
            tests.video = function () {
                var elem = document.createElement("video"),
                    bool = !1;
                try {
                    (bool = !!elem.canPlayType) && (bool = new Boolean(bool), bool.ogg = elem.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, ""), bool.h264 = elem.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, ""), bool.webm = elem.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, ""))
                } catch (e) {}
                return bool
            },
            tests.audio = function () {
                var elem = document.createElement("audio"),
                    bool = !1;
                try {
                    (bool = !!elem.canPlayType) && (bool = new Boolean(bool), bool.ogg = elem.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), bool.mp3 = elem.canPlayType("audio/mpeg;").replace(/^no$/, ""), bool.wav = elem.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""), bool.m4a = (elem.canPlayType("audio/x-m4a;") || elem.canPlayType("audio/aac;")).replace(/^no$/, ""))
                } catch (e) {}
                return bool
            },
            tests.localstorage = function () {
                try {
                    return localStorage.setItem(mod, mod),
                        localStorage.removeItem(mod), !0
                } catch (e) {
                    return !1
                }
            },
            tests.sessionstorage = function () {
                try {
                    return sessionStorage.setItem(mod, mod),
                        sessionStorage.removeItem(mod), !0
                } catch (e) {
                    return !1
                }
            },
            tests.webworkers = function () {
                return !!window.Worker
            },
            tests.applicationcache = function () {
                return !!window.applicationCache
            },
            tests.svg = function () {
                return !!document.createElementNS && !!document.createElementNS(ns.svg, "svg").createSVGRect
            },
            tests.inlinesvg = function () {
                var div = document.createElement("div");
                return div.innerHTML = "<svg/>",
                    (div.firstChild && div.firstChild.namespaceURI) == ns.svg
            },
            tests.smil = function () {
                return !!document.createElementNS && /SVGAnimate/.test(toString.call(document.createElementNS(ns.svg, "animate")))
            },
            tests.svgclippaths = function () {
                return !!document.createElementNS && /SVGClipPath/.test(toString.call(document.createElementNS(ns.svg, "clipPath")))
            };
        for (var feature in tests) hasOwnProp(tests, feature) && (featureName = feature.toLowerCase(), Modernizr[featureName] = tests[feature](), classes.push((Modernizr[featureName] ? "" : "no-") + featureName));
        return Modernizr.input || webforms(),
            Modernizr.addTest = function (feature, test) {
                if ("object" == typeof feature)
                    for (var key in feature) hasOwnProp(feature, key) && Modernizr.addTest(key, feature[key]);
                else {
                    if (feature = feature.toLowerCase(), Modernizr[feature] !== undefined) return Modernizr;
                    test = "function" == typeof test ? test() : test,
                        "undefined" != typeof enableClasses && enableClasses && (docElement.className += " " + (test ? "" : "no-") + feature),
                        Modernizr[feature] = test
                }
                return Modernizr
            },
            setCss(""),
            modElem = inputElem = null,
            function (window, document) {
                function addStyleSheet(ownerDocument, cssText) {
                    var p = ownerDocument.createElement("p"),
                        parent = ownerDocument.getElementsByTagName("head")[0] || ownerDocument.documentElement;
                    return p.innerHTML = "x<style>" + cssText + "</style>",
                        parent.insertBefore(p.lastChild, parent.firstChild)
                }

                function getElements() {
                    var elements = html5.elements;
                    return "string" == typeof elements ? elements.split(" ") : elements
                }

                function getExpandoData(ownerDocument) {
                    var data = expandoData[ownerDocument[expando]];
                    return data || (data = {},
                            expanID++, ownerDocument[expando] = expanID, expandoData[expanID] = data),
                        data
                }

                function createElement(nodeName, ownerDocument, data) {
                    if (ownerDocument || (ownerDocument = document), supportsUnknownElements) return ownerDocument.createElement(nodeName);
                    data || (data = getExpandoData(ownerDocument));
                    var node;
                    return node = data.cache[nodeName] ? data.cache[nodeName].cloneNode() : saveClones.test(nodeName) ? (data.cache[nodeName] = data.createElem(nodeName)).cloneNode() : data.createElem(nodeName),
                        node.canHaveChildren && !reSkip.test(nodeName) ? data.frag.appendChild(node) : node
                }

                function createDocumentFragment(ownerDocument, data) {
                    if (ownerDocument || (ownerDocument = document), supportsUnknownElements) return ownerDocument.createDocumentFragment();
                    data = data || getExpandoData(ownerDocument);
                    for (var clone = data.frag.cloneNode(), i = 0, elems = getElements(), l = elems.length; l > i; i++) clone.createElement(elems[i]);
                    return clone
                }

                function shivMethods(ownerDocument, data) {
                    data.cache || (data.cache = {},
                            data.createElem = ownerDocument.createElement, data.createFrag = ownerDocument.createDocumentFragment, data.frag = data.createFrag()),
                        ownerDocument.createElement = function (nodeName) {
                            return html5.shivMethods ? createElement(nodeName, ownerDocument, data) : data.createElem(nodeName)
                        },
                        ownerDocument.createDocumentFragment = Function("h,f", "return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&(" + getElements().join().replace(/\w+/g,
                            function (nodeName) {
                                return data.createElem(nodeName),
                                    data.frag.createElement(nodeName),
                                    'c("' + nodeName + '")'
                            }) + ");return n}")(html5, data.frag)
                }

                function shivDocument(ownerDocument) {
                    ownerDocument || (ownerDocument = document);
                    var data = getExpandoData(ownerDocument);
                    return !html5.shivCSS || supportsHtml5Styles || data.hasCSS || (data.hasCSS = !!addStyleSheet(ownerDocument, "article,aside,figcaption,figure,footer,header,hgroup,nav,section{display:block}mark{background:#FF0;color:#000}")),
                        supportsUnknownElements || shivMethods(ownerDocument, data),
                        ownerDocument
                }
                var supportsHtml5Styles, supportsUnknownElements, options = window.html5 || {},
                    reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,
                    saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,
                    expando = "_html5shiv",
                    expanID = 0,
                    expandoData = {};
                !
                function () {
                    try {
                        var a = document.createElement("a");
                        a.innerHTML = "<xyz></xyz>",
                            supportsHtml5Styles = "hidden" in a,
                            supportsUnknownElements = 1 == a.childNodes.length ||
                            function () {
                                document.createElement("a");
                                var frag = document.createDocumentFragment();
                                return "undefined" == typeof frag.cloneNode || "undefined" == typeof frag.createDocumentFragment || "undefined" == typeof frag.createElement
                            }()
                    } catch (e) {
                        supportsHtml5Styles = !0,
                            supportsUnknownElements = !0
                    }
                }();
                var html5 = {
                    elements: options.elements || "abbr article aside audio bdi canvas data datalist details figcaption figure footer header hgroup mark meter nav output progress section summary time video",
                    shivCSS: options.shivCSS !== !1,
                    supportsUnknownElements: supportsUnknownElements,
                    shivMethods: options.shivMethods !== !1,
                    type: "default",
                    shivDocument: shivDocument,
                    createElement: createElement,
                    createDocumentFragment: createDocumentFragment
                };
                window.html5 = html5,
                    shivDocument(document)
            }(this, document),
            Modernizr._version = version,
            Modernizr._prefixes = prefixes,
            Modernizr._domPrefixes = domPrefixes,
            Modernizr._cssomPrefixes = cssomPrefixes,
            Modernizr.mq = testMediaQuery,
            Modernizr.hasEvent = isEventSupported,
            Modernizr.testProp = function (prop) {
                return testProps([prop])
            },
            Modernizr.testAllProps = testPropsAll,
            Modernizr.testStyles = injectElementWithStyles,
            Modernizr.prefixed = function (prop, obj, elem) {
                return obj ? testPropsAll(prop, obj, elem) : testPropsAll(prop, "pfx")
            },
            docElement.className = docElement.className.replace(/(^|\s)no-js(\s|$)/, "$1$2") + (enableClasses ? " js " + classes.join(" ") : ""),
            Modernizr
    }(this, this.document),
    jQuery.easing.jswing = jQuery.easing.swing,
    jQuery.extend(jQuery.easing, {
        def: "easeOutQuad",
        swing: function (x, t, b, c, d) {
            return jQuery.easing[jQuery.easing.def](x, t, b, c, d)
        },
        easeInQuad: function (x, t, b, c, d) {
            return c * (t /= d) * t + b
        },
        easeOutQuad: function (x, t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b
        },
        easeInOutQuad: function (x, t, b, c, d) {
            return (t /= d / 2) < 1 ? c / 2 * t * t + b : -c / 2 * (--t * (t - 2) - 1) + b
        },
        easeInCubic: function (x, t, b, c, d) {
            return c * (t /= d) * t * t + b
        },
        easeOutCubic: function (x, t, b, c, d) {
            return c * ((t = t / d - 1) * t * t + 1) + b
        },
        easeInOutCubic: function (x, t, b, c, d) {
            return (t /= d / 2) < 1 ? c / 2 * t * t * t + b : c / 2 * ((t -= 2) * t * t + 2) + b
        },
        easeInQuart: function (x, t, b, c, d) {
            return c * (t /= d) * t * t * t + b
        },
        easeOutQuart: function (x, t, b, c, d) {
            return -c * ((t = t / d - 1) * t * t * t - 1) + b
        },
        easeInOutQuart: function (x, t, b, c, d) {
            return (t /= d / 2) < 1 ? c / 2 * t * t * t * t + b : -c / 2 * ((t -= 2) * t * t * t - 2) + b
        },
        easeInQuint: function (x, t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b
        },
        easeOutQuint: function (x, t, b, c, d) {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b
        },
        easeInOutQuint: function (x, t, b, c, d) {
            return (t /= d / 2) < 1 ? c / 2 * t * t * t * t * t + b : c / 2 * ((t -= 2) * t * t * t * t + 2) + b
        },
        easeInSine: function (x, t, b, c, d) {
            return -c * Math.cos(t / d * (Math.PI / 2)) + c + b
        },
        easeOutSine: function (x, t, b, c, d) {
            return c * Math.sin(t / d * (Math.PI / 2)) + b
        },
        easeInOutSine: function (x, t, b, c, d) {
            return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b
        },
        easeInExpo: function (x, t, b, c, d) {
            return 0 == t ? b : c * Math.pow(2, 10 * (t / d - 1)) + b
        },
        easeOutExpo: function (x, t, b, c, d) {
            return t == d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b
        },
        easeInOutExpo: function (x, t, b, c, d) {
            return 0 == t ? b : t == d ? b + c : (t /= d / 2) < 1 ? c / 2 * Math.pow(2, 10 * (t - 1)) + b : c / 2 * (-Math.pow(2, -10 * --t) + 2) + b
        },
        easeInCirc: function (x, t, b, c, d) {
            return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b
        },
        easeOutCirc: function (x, t, b, c, d) {
            return c * Math.sqrt(1 - (t = t / d - 1) * t) + b
        },
        easeInOutCirc: function (x, t, b, c, d) {
            return (t /= d / 2) < 1 ? -c / 2 * (Math.sqrt(1 - t * t) - 1) + b : c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b
        },
        easeInElastic: function (x, t, b, c, d) {
            var s = 1.70158,
                p = 0,
                a = c;
            if (0 == t) return b;
            if (1 == (t /= d)) return b + c;
            if (p || (p = .3 * d), a < Math.abs(c)) {
                a = c;
                var s = p / 4
            } else var s = p / (2 * Math.PI) * Math.asin(c / a);
            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t * d - s) * Math.PI / p)) + b
        },
        easeOutElastic: function (x, t, b, c, d) {
            var s = 1.70158,
                p = 0,
                a = c;
            if (0 == t) return b;
            if (1 == (t /= d)) return b + c;
            if (p || (p = .3 * d), a < Math.abs(c)) {
                a = c;
                var s = p / 4
            } else var s = p / (2 * Math.PI) * Math.asin(c / a);
            return a * Math.pow(2, -10 * t) * Math.sin(2 * (t * d - s) * Math.PI / p) + c + b
        },
        easeInOutElastic: function (x, t, b, c, d) {
            var s = 1.70158,
                p = 0,
                a = c;
            if (0 == t) return b;
            if (2 == (t /= d / 2)) return b + c;
            if (p || (p = .3 * d * 1.5), a < Math.abs(c)) {
                a = c;
                var s = p / 4
            } else var s = p / (2 * Math.PI) * Math.asin(c / a);
            return 1 > t ? -.5 * a * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t * d - s) * Math.PI / p) + b : a * Math.pow(2, -10 * (t -= 1)) * Math.sin(2 * (t * d - s) * Math.PI / p) * .5 + c + b
        },
        easeInBack: function (x, t, b, c, d, s) {
            return void 0 == s && (s = 1.70158),
                c * (t /= d) * t * ((s + 1) * t - s) + b
        },
        easeOutBack: function (x, t, b, c, d, s) {
            return void 0 == s && (s = 1.70158),
                c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b
        },
        easeInOutBack: function (x, t, b, c, d, s) {
            return void 0 == s && (s = 1.70158),
                (t /= d / 2) < 1 ? c / 2 * t * t * (((s *= 1.525) + 1) * t - s) + b : c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b
        },
        easeInBounce: function (x, t, b, c, d) {
            return c - jQuery.easing.easeOutBounce(x, d - t, 0, c, d) + b
        },
        easeOutBounce: function (x, t, b, c, d) {
            return (t /= d) < 1 / 2.75 ? 7.5625 * c * t * t + b : 2 / 2.75 > t ? c * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + b : 2.5 / 2.75 > t ? c * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + b : c * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + b
        },
        easeInOutBounce: function (x, t, b, c, d) {
            return d / 2 > t ? .5 * jQuery.easing.easeInBounce(x, 2 * t, 0, c, d) + b : .5 * jQuery.easing.easeOutBounce(x, 2 * t - d, 0, c, d) + .5 * c + b
        }
    });